<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>INLA_DIST: PostTheta Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">INLA_DIST
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classPostTheta-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">PostTheta Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Computes the Posterior of the hyperparameters theta.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="INLA__CPUonly_2PostTheta_8h_source.html">PostTheta.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a56db4c858de1c0dc0721bf19e60c493c" id="r_a56db4c858de1c0dc0721bf19e60c493c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56db4c858de1c0dc0721bf19e60c493c">PostTheta</a> (int <a class="el" href="#a4def6d3a66d18ebb36f3db4e533626f6">ns</a>, int <a class="el" href="#ac84bd657538bc782335e992055a0817e">nt</a>, int <a class="el" href="#a90f7a7de632412bd9017e33a594105f4">nb</a>, int <a class="el" href="#aec066996693ada57084aa1ee52f04948">no</a>, MatrixXd <a class="el" href="#acc70e6f2659235075873ecee40a126cf">B</a>, Vect <a class="el" href="#a762b11a93e586f00ded70b7776e075ad">y</a>, Vect theta_prior, string solver_type, const bool <a class="el" href="#adc24faaa8937de8de88dde11fa9020f7">constr</a>, const MatrixXd <a class="el" href="#a5a765bc4a434d2c4926b7c035984dd66">Dxy</a>, const bool validate, const Vect w)</td></tr>
<tr class="memdesc:a56db4c858de1c0dc0721bf19e60c493c"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for regression model (no random effects).  <br /></td></tr>
<tr class="separator:a56db4c858de1c0dc0721bf19e60c493c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff16e221ec1a93e07d27553fb817c6d" id="r_a4ff16e221ec1a93e07d27553fb817c6d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ff16e221ec1a93e07d27553fb817c6d">PostTheta</a> (int <a class="el" href="#a4def6d3a66d18ebb36f3db4e533626f6">ns</a>, int <a class="el" href="#ac84bd657538bc782335e992055a0817e">nt</a>, int <a class="el" href="#a90f7a7de632412bd9017e33a594105f4">nb</a>, int <a class="el" href="#aec066996693ada57084aa1ee52f04948">no</a>, SpMat <a class="el" href="#a87a3adb6b92056e8dacea22fa894300a">Ax</a>, Vect <a class="el" href="#a762b11a93e586f00ded70b7776e075ad">y</a>, SpMat <a class="el" href="#a71833a89a8c3dc58117eb467feac7674">c0</a>, SpMat <a class="el" href="#ade2defef59b9295d794620fefb7c8b05">g1</a>, SpMat <a class="el" href="#ae1be0d6e322a26924b67b6258cf55b08">g2</a>, Vect theta_prior, string solver_type, const bool <a class="el" href="#adc24faaa8937de8de88dde11fa9020f7">constr</a>, const MatrixXd <a class="el" href="#af80d7b7e847c30706a826a1c6d7c2fc1">Dx</a>, const MatrixXd <a class="el" href="#a5a765bc4a434d2c4926b7c035984dd66">Dxy</a>, const bool validate, const Vect w)</td></tr>
<tr class="memdesc:a4ff16e221ec1a93e07d27553fb817c6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for spatial model (order 2).  <br /></td></tr>
<tr class="separator:a4ff16e221ec1a93e07d27553fb817c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35269dd8407ce1c126a4b87a31b7a310" id="r_a35269dd8407ce1c126a4b87a31b7a310"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35269dd8407ce1c126a4b87a31b7a310">PostTheta</a> (int <a class="el" href="#a4def6d3a66d18ebb36f3db4e533626f6">ns</a>, int <a class="el" href="#ac84bd657538bc782335e992055a0817e">nt</a>, int <a class="el" href="#a90f7a7de632412bd9017e33a594105f4">nb</a>, int <a class="el" href="#aec066996693ada57084aa1ee52f04948">no</a>, SpMat <a class="el" href="#a87a3adb6b92056e8dacea22fa894300a">Ax</a>, Vect <a class="el" href="#a762b11a93e586f00ded70b7776e075ad">y</a>, SpMat <a class="el" href="#a71833a89a8c3dc58117eb467feac7674">c0</a>, SpMat <a class="el" href="#ade2defef59b9295d794620fefb7c8b05">g1</a>, SpMat <a class="el" href="#ae1be0d6e322a26924b67b6258cf55b08">g2</a>, SpMat <a class="el" href="#ac59ad0f384dc3d3f73c6f340aaac2996">g3</a>, SpMat <a class="el" href="#a06391c3ed3d8368da520d465cc909bc0">M0</a>, SpMat <a class="el" href="#af97e49a98f2a9f390abb52cdaf998577">M1</a>, SpMat <a class="el" href="#a93e3e540d2f3d3cd343f9a66867ec03a">M2</a>, Vect theta_prior, string solver_type, const bool <a class="el" href="#adc24faaa8937de8de88dde11fa9020f7">constr</a>, const MatrixXd <a class="el" href="#af80d7b7e847c30706a826a1c6d7c2fc1">Dx</a>, const MatrixXd <a class="el" href="#a5a765bc4a434d2c4926b7c035984dd66">Dxy</a>, const bool validate, const Vect w)</td></tr>
<tr class="memdesc:a35269dd8407ce1c126a4b87a31b7a310"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for spatial temporal model.  <br /></td></tr>
<tr class="separator:a35269dd8407ce1c126a4b87a31b7a310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c031e4b1773db975d3038ac01b0977" id="r_a42c031e4b1773db975d3038ac01b0977"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42c031e4b1773db975d3038ac01b0977">operator()</a> (Vect &amp;theta, Vect &amp;grad)</td></tr>
<tr class="memdesc:a42c031e4b1773db975d3038ac01b0977"><td class="mdescLeft">&#160;</td><td class="mdescRight">structure required by <a class="el" href="classBFGS.html">BFGS</a> solver, requires : theta, gradient theta  <br /></td></tr>
<tr class="separator:a42c031e4b1773db975d3038ac01b0977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a7918139c515f19f4663057ca3e5cc" id="r_a33a7918139c515f19f4663057ca3e5cc"><td class="memItemLeft" align="right" valign="top"><a id="a33a7918139c515f19f4663057ca3e5cc" name="a33a7918139c515f19f4663057ca3e5cc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>computeG</b> (Vect &amp;theta)</td></tr>
<tr class="memdesc:a33a7918139c515f19f4663057ca3e5cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">overwriting G every time, not explicitly listed, better way to do this? needs to be stored after every iteration for smart hessian ... <br  />
 <br /></td></tr>
<tr class="separator:a33a7918139c515f19f4663057ca3e5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc197a1ae82c5265a0a465c4cfa2727" id="r_a4fc197a1ae82c5265a0a465c4cfa2727"><td class="memItemLeft" align="right" valign="top"><a id="a4fc197a1ae82c5265a0a465c4cfa2727" name="a4fc197a1ae82c5265a0a465c4cfa2727"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>get_fct_count</b> ()</td></tr>
<tr class="separator:a4fc197a1ae82c5265a0a465c4cfa2727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfdc66118e93525b7814f53c6b50e652" id="r_adfdc66118e93525b7814f53c6b50e652"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfdc66118e93525b7814f53c6b50e652">convert_theta2interpret</a> (double lgamE, double lgamS, double lgamT, double &amp;sigU, double &amp;ranS, double &amp;ranT)</td></tr>
<tr class="memdesc:adfdc66118e93525b7814f53c6b50e652"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert hyperparameters theta from the model parametrisation to the interpretable parametrisation ie. from log(gamma_E, gamma_s, gamma_t) to log(sigma.u, rangeS, rangeT)  <br /></td></tr>
<tr class="separator:adfdc66118e93525b7814f53c6b50e652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada9c36637820d3eaad19d4b3449c98ad" id="r_ada9c36637820d3eaad19d4b3449c98ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada9c36637820d3eaad19d4b3449c98ad">convert_interpret2theta</a> (double sigU, double ranS, double ranT, double &amp;lgamE, double &amp;lgamS, double &amp;lgamT)</td></tr>
<tr class="memdesc:ada9c36637820d3eaad19d4b3449c98ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert hyperparameters theta from the interpretable parametrisation to the model parametrisation ie. from log(sigma.u, rangeS, rangeT) to log(gamma_E, gamma_s, gamma_t)  <br /></td></tr>
<tr class="separator:ada9c36637820d3eaad19d4b3449c98ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ffad9798426544c91b1f3420e9c8c9" id="r_ac6ffad9798426544c91b1f3420e9c8c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6ffad9798426544c91b1f3420e9c8c9">get_mu</a> (Vect &amp;theta, Vect &amp;<a class="el" href="#aa6d3402de41235b5226e1e93be4a9dbe">mu</a>, ArrayXi &amp;fact_to_rank_list)</td></tr>
<tr class="memdesc:ac6ffad9798426544c91b1f3420e9c8c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">get conditional mean mu for theta.  <br /></td></tr>
<tr class="separator:ac6ffad9798426544c91b1f3420e9c8c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b59d9c23fb21cf517f281ae48ac970d" id="r_a6b59d9c23fb21cf517f281ae48ac970d"><td class="memItemLeft" align="right" valign="top">Vect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b59d9c23fb21cf517f281ae48ac970d">get_grad</a> ()</td></tr>
<tr class="memdesc:a6b59d9c23fb21cf517f281ae48ac970d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns current gradient of theta.  <br /></td></tr>
<tr class="separator:a6b59d9c23fb21cf517f281ae48ac970d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb8efdc44447d6224893f6debf29540" id="r_a9eb8efdc44447d6224893f6debf29540"><td class="memItemLeft" align="right" valign="top">MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9eb8efdc44447d6224893f6debf29540">get_Covariance</a> (Vect &amp;theta, double eps)</td></tr>
<tr class="memdesc:a9eb8efdc44447d6224893f6debf29540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute Covariance matrix of hyperparameters theta, at theta.  <br /></td></tr>
<tr class="separator:a9eb8efdc44447d6224893f6debf29540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2589db16c7d4784189d003016d99cf89" id="r_a2589db16c7d4784189d003016d99cf89"><td class="memItemLeft" align="right" valign="top"><a id="a2589db16c7d4784189d003016d99cf89" name="a2589db16c7d4784189d003016d99cf89"></a>
MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><b>get_Cov_interpret_param</b> (Vect &amp;interpret_theta, double eps)</td></tr>
<tr class="separator:a2589db16c7d4784189d003016d99cf89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52398b5f03001d24a9bd69d02e7c9773" id="r_a52398b5f03001d24a9bd69d02e7c9773"><td class="memItemLeft" align="right" valign="top"><a id="a52398b5f03001d24a9bd69d02e7c9773" name="a52398b5f03001d24a9bd69d02e7c9773"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>f_eval</b> (Vect &amp;theta)</td></tr>
<tr class="separator:a52398b5f03001d24a9bd69d02e7c9773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f0a2f1e8653c50fa9d4c3c24469ea06" id="r_a5f0a2f1e8653c50fa9d4c3c24469ea06"><td class="memItemLeft" align="right" valign="top"><a id="a5f0a2f1e8653c50fa9d4c3c24469ea06" name="a5f0a2f1e8653c50fa9d4c3c24469ea06"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>compute_error_bfgs</b> (Vect &amp;theta)</td></tr>
<tr class="separator:a5f0a2f1e8653c50fa9d4c3c24469ea06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d01ba1dcfedc1e9b250586c0f6ab98" id="r_ab6d01ba1dcfedc1e9b250586c0f6ab98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6d01ba1dcfedc1e9b250586c0f6ab98">get_marginals_f</a> (Vect &amp;theta, Vect &amp;vars)</td></tr>
<tr class="memdesc:ab6d01ba1dcfedc1e9b250586c0f6ab98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the marginal variances of the latent parameters at theta. Using selected inversion procedure.  <br /></td></tr>
<tr class="separator:ab6d01ba1dcfedc1e9b250586c0f6ab98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba126f6b1bc95b8815465debaedd650" id="r_a8ba126f6b1bc95b8815465debaedd650"><td class="memItemLeft" align="right" valign="top">MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ba126f6b1bc95b8815465debaedd650">hess_eval</a> (Vect &amp;theta, double eps)</td></tr>
<tr class="memdesc:a8ba126f6b1bc95b8815465debaedd650"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the hessian at theta using second order finite difference. Is used be get_Covariance.  <br /></td></tr>
<tr class="separator:a8ba126f6b1bc95b8815465debaedd650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67ecf629a6a81db6966614517acfbbb" id="r_ae67ecf629a6a81db6966614517acfbbb"><td class="memItemLeft" align="right" valign="top"><a id="ae67ecf629a6a81db6966614517acfbbb" name="ae67ecf629a6a81db6966614517acfbbb"></a>
MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><b>hess_eval_interpret_theta</b> (Vect &amp;interpret_theta, double eps)</td></tr>
<tr class="separator:ae67ecf629a6a81db6966614517acfbbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240a43fde6a2e26c30275b24f99f5d4e" id="r_a240a43fde6a2e26c30275b24f99f5d4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a240a43fde6a2e26c30275b24f99f5d4e">check_pos_def</a> (MatrixXd &amp;hess)</td></tr>
<tr class="memdesc:a240a43fde6a2e26c30275b24f99f5d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if Hessian positive definite (matrix assumed to be dense &amp; small since dim(theta) small)  <br /></td></tr>
<tr class="separator:a240a43fde6a2e26c30275b24f99f5d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a3133494a5479b3f1f8a557e9490a35" id="r_a6a3133494a5479b3f1f8a557e9490a35"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a3133494a5479b3f1f8a557e9490a35">eval_post_theta</a> (Vect &amp;theta, Vect &amp;<a class="el" href="#aa6d3402de41235b5226e1e93be4a9dbe">mu</a>, ArrayXi &amp;fact_to_rank_list)</td></tr>
<tr class="memdesc:a6a3133494a5479b3f1f8a557e9490a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Core function. Evaluate posterior of theta. mu are latent parameters.  <br /></td></tr>
<tr class="separator:a6a3133494a5479b3f1f8a557e9490a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52137ac2ce65806e9b9e99177adecd33" id="r_a52137ac2ce65806e9b9e99177adecd33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52137ac2ce65806e9b9e99177adecd33">eval_log_gaussian_prior_hp</a> (double &amp;log_prior, double *thetai, double *thetai_original)</td></tr>
<tr class="memdesc:a52137ac2ce65806e9b9e99177adecd33"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate log prior of the hyperparameters using original theta value  <br /></td></tr>
<tr class="separator:a52137ac2ce65806e9b9e99177adecd33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f7a4987eeb15a84b1af7c784c3b6ff" id="r_a66f7a4987eeb15a84b1af7c784c3b6ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66f7a4987eeb15a84b1af7c784c3b6ff">eval_log_pc_prior_hp</a> (double &amp;log_sum, Vect &amp;lambda, Vect &amp;theta_interpret)</td></tr>
<tr class="memdesc:a66f7a4987eeb15a84b1af7c784c3b6ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate log prior using PC prior  <br /></td></tr>
<tr class="separator:a66f7a4987eeb15a84b1af7c784c3b6ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a1b9ac95394ba1992ed25b4b34e128" id="r_a79a1b9ac95394ba1992ed25b4b34e128"><td class="memItemLeft" align="right" valign="top"><a id="a79a1b9ac95394ba1992ed25b4b34e128" name="a79a1b9ac95394ba1992ed25b4b34e128"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>update_mean_constr</b> (const MatrixXd &amp;D, Vect &amp;e, Vect &amp;sol, MatrixXd &amp;V, MatrixXd &amp;W, MatrixXd &amp;U, Vect &amp;updated_sol)</td></tr>
<tr class="separator:a79a1b9ac95394ba1992ed25b4b34e128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4973d0c8335220faafa3bdb2fcfeb331" id="r_a4973d0c8335220faafa3bdb2fcfeb331"><td class="memItemLeft" align="right" valign="top"><a id="a4973d0c8335220faafa3bdb2fcfeb331" name="a4973d0c8335220faafa3bdb2fcfeb331"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>eval_log_dens_constr</b> (Vect &amp;x, Vect &amp;<a class="el" href="#aa6d3402de41235b5226e1e93be4a9dbe">mu</a>, SpMat &amp;Q, double &amp;log_det_Q, const MatrixXd &amp;D, MatrixXd &amp;W, double &amp;val_log_dens)</td></tr>
<tr class="separator:a4973d0c8335220faafa3bdb2fcfeb331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a981439fd52c6b46c1666fd45eb5faa92" id="r_a981439fd52c6b46c1666fd45eb5faa92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a981439fd52c6b46c1666fd45eb5faa92">eval_log_prior_lat</a> (Vect &amp;theta, double &amp;val)</td></tr>
<tr class="memdesc:a981439fd52c6b46c1666fd45eb5faa92"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate log prior of random effects  <br /></td></tr>
<tr class="separator:a981439fd52c6b46c1666fd45eb5faa92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97173a441c0f2f6b9dc2a5fe85e1d6ad" id="r_a97173a441c0f2f6b9dc2a5fe85e1d6ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97173a441c0f2f6b9dc2a5fe85e1d6ad">eval_likelihood</a> (Vect &amp;theta, double &amp;log_det, double &amp;val)</td></tr>
<tr class="memdesc:a97173a441c0f2f6b9dc2a5fe85e1d6ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute log likelihood : log_det tau*no and value -theta*yTy  <br /></td></tr>
<tr class="separator:a97173a441c0f2f6b9dc2a5fe85e1d6ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ceec7e512bf71ca7267f01733ec8719" id="r_a2ceec7e512bf71ca7267f01733ec8719"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ceec7e512bf71ca7267f01733ec8719">construct_Q_spatial</a> (Vect &amp;theta, SpMat &amp;Qs)</td></tr>
<tr class="memdesc:a2ceec7e512bf71ca7267f01733ec8719"><td class="mdescLeft">&#160;</td><td class="mdescRight">spatial model : SPDE discretisation &ndash; matrix construction  <br /></td></tr>
<tr class="separator:a2ceec7e512bf71ca7267f01733ec8719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41faf4a6b8b2a30168f35805c2c7b3f" id="r_ac41faf4a6b8b2a30168f35805c2c7b3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac41faf4a6b8b2a30168f35805c2c7b3f">construct_Q_spat_temp</a> (Vect &amp;theta, SpMat &amp;Qst)</td></tr>
<tr class="memdesc:ac41faf4a6b8b2a30168f35805c2c7b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">spatial temporal model : SPDE discretisation. DEMF(1,2,1) model.  <br /></td></tr>
<tr class="separator:ac41faf4a6b8b2a30168f35805c2c7b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb642337f6f4db477be2318bb9796f2c" id="r_acb642337f6f4db477be2318bb9796f2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb642337f6f4db477be2318bb9796f2c">construct_Q</a> (Vect &amp;theta, SpMat &amp;Q)</td></tr>
<tr class="memdesc:acb642337f6f4db477be2318bb9796f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct precision matrix. Calls spatial, spatial-temporal, etc.  <br /></td></tr>
<tr class="separator:acb642337f6f4db477be2318bb9796f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69559f2f98cbdd4b844a9e0c571d64d" id="r_af69559f2f98cbdd4b844a9e0c571d64d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af69559f2f98cbdd4b844a9e0c571d64d">construct_b</a> (Vect &amp;theta, Vect &amp;rhs)</td></tr>
<tr class="memdesc:af69559f2f98cbdd4b844a9e0c571d64d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble right-handside.  <br /></td></tr>
<tr class="separator:af69559f2f98cbdd4b844a9e0c571d64d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af7519622a314b59a75f5b84f15ad9a" id="r_a5af7519622a314b59a75f5b84f15ad9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5af7519622a314b59a75f5b84f15ad9a">eval_denominator</a> (Vect &amp;theta, double &amp;val, SpMat &amp;Q, Vect &amp;rhs, Vect &amp;<a class="el" href="#aa6d3402de41235b5226e1e93be4a9dbe">mu</a>)</td></tr>
<tr class="memdesc:a5af7519622a314b59a75f5b84f15ad9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate denominator: conditional probability of Qx|y.  <br /></td></tr>
<tr class="separator:a5af7519622a314b59a75f5b84f15ad9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d7a18584db9aace5d217437bdfe84fa" id="r_a3d7a18584db9aace5d217437bdfe84fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d7a18584db9aace5d217437bdfe84fa">eval_gradient</a> (Vect &amp;theta, double f_theta, Vect &amp;<a class="el" href="#aa6d3402de41235b5226e1e93be4a9dbe">mu</a>, Vect &amp;grad)</td></tr>
<tr class="memdesc:a3d7a18584db9aace5d217437bdfe84fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute gradient using central finite difference stencil. Parallelised with OpenMP.  <br /></td></tr>
<tr class="separator:a3d7a18584db9aace5d217437bdfe84fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f05821cf3af095b3a9fa66919266bf" id="r_a29f05821cf3af095b3a9fa66919266bf"><td class="memItemLeft" align="right" valign="top"><a id="a29f05821cf3af095b3a9fa66919266bf" name="a29f05821cf3af095b3a9fa66919266bf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>record_times</b> (std::string file_name, int <a class="el" href="#a6f35b1d4e2eb881fd0b8513571874bc0">iter_count</a>, double t_Ftheta_ext, double t_thread_nom, double t_priorHyp, double t_priorLat, double t_priorLatAMat, double t_priorLatChol, double t_likel, double t_thread_denom, double t_condLat, double t_condLatAMat, double t_condLatChol, double t_condLatSolve)</td></tr>
<tr class="separator:a29f05821cf3af095b3a9fa66919266bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d5640ff12bb9e2828559153c61f352" id="r_a72d5640ff12bb9e2828559153c61f352"><td class="memItemLeft" align="right" valign="top"><a id="a72d5640ff12bb9e2828559153c61f352" name="a72d5640ff12bb9e2828559153c61f352"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~PostTheta</b> ()</td></tr>
<tr class="memdesc:a72d5640ff12bb9e2828559153c61f352"><td class="mdescLeft">&#160;</td><td class="mdescRight">class destructor. Frees memory allocated by <a class="el" href="classPostTheta.html" title="Computes the Posterior of the hyperparameters theta.">PostTheta</a> class. <br /></td></tr>
<tr class="separator:a72d5640ff12bb9e2828559153c61f352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56db4c858de1c0dc0721bf19e60c493c" id="r_a56db4c858de1c0dc0721bf19e60c493c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56db4c858de1c0dc0721bf19e60c493c">PostTheta</a> (int <a class="el" href="#a4def6d3a66d18ebb36f3db4e533626f6">ns</a>, int <a class="el" href="#ac84bd657538bc782335e992055a0817e">nt</a>, int <a class="el" href="#a90f7a7de632412bd9017e33a594105f4">nb</a>, int <a class="el" href="#aec066996693ada57084aa1ee52f04948">no</a>, MatrixXd <a class="el" href="#acc70e6f2659235075873ecee40a126cf">B</a>, Vect <a class="el" href="#a762b11a93e586f00ded70b7776e075ad">y</a>, Vect theta_prior, string solver_type, const bool <a class="el" href="#adc24faaa8937de8de88dde11fa9020f7">constr</a>, const MatrixXd <a class="el" href="#a5a765bc4a434d2c4926b7c035984dd66">Dxy</a>, const bool validate, const Vect w)</td></tr>
<tr class="memdesc:a56db4c858de1c0dc0721bf19e60c493c"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for regression model (no random effects).  <br /></td></tr>
<tr class="separator:a56db4c858de1c0dc0721bf19e60c493c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff16e221ec1a93e07d27553fb817c6d" id="r_a4ff16e221ec1a93e07d27553fb817c6d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ff16e221ec1a93e07d27553fb817c6d">PostTheta</a> (int <a class="el" href="#a4def6d3a66d18ebb36f3db4e533626f6">ns</a>, int <a class="el" href="#ac84bd657538bc782335e992055a0817e">nt</a>, int <a class="el" href="#a90f7a7de632412bd9017e33a594105f4">nb</a>, int <a class="el" href="#aec066996693ada57084aa1ee52f04948">no</a>, SpMat <a class="el" href="#a87a3adb6b92056e8dacea22fa894300a">Ax</a>, Vect <a class="el" href="#a762b11a93e586f00ded70b7776e075ad">y</a>, SpMat <a class="el" href="#a71833a89a8c3dc58117eb467feac7674">c0</a>, SpMat <a class="el" href="#ade2defef59b9295d794620fefb7c8b05">g1</a>, SpMat <a class="el" href="#ae1be0d6e322a26924b67b6258cf55b08">g2</a>, Vect theta_prior, string solver_type, const bool <a class="el" href="#adc24faaa8937de8de88dde11fa9020f7">constr</a>, const MatrixXd <a class="el" href="#af80d7b7e847c30706a826a1c6d7c2fc1">Dx</a>, const MatrixXd <a class="el" href="#a5a765bc4a434d2c4926b7c035984dd66">Dxy</a>, const bool validate, const Vect w)</td></tr>
<tr class="memdesc:a4ff16e221ec1a93e07d27553fb817c6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for spatial model (order 2).  <br /></td></tr>
<tr class="separator:a4ff16e221ec1a93e07d27553fb817c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35269dd8407ce1c126a4b87a31b7a310" id="r_a35269dd8407ce1c126a4b87a31b7a310"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35269dd8407ce1c126a4b87a31b7a310">PostTheta</a> (int <a class="el" href="#a4def6d3a66d18ebb36f3db4e533626f6">ns</a>, int <a class="el" href="#ac84bd657538bc782335e992055a0817e">nt</a>, int <a class="el" href="#a90f7a7de632412bd9017e33a594105f4">nb</a>, int <a class="el" href="#aec066996693ada57084aa1ee52f04948">no</a>, SpMat <a class="el" href="#a87a3adb6b92056e8dacea22fa894300a">Ax</a>, Vect <a class="el" href="#a762b11a93e586f00ded70b7776e075ad">y</a>, SpMat <a class="el" href="#a71833a89a8c3dc58117eb467feac7674">c0</a>, SpMat <a class="el" href="#ade2defef59b9295d794620fefb7c8b05">g1</a>, SpMat <a class="el" href="#ae1be0d6e322a26924b67b6258cf55b08">g2</a>, SpMat <a class="el" href="#ac59ad0f384dc3d3f73c6f340aaac2996">g3</a>, SpMat <a class="el" href="#a06391c3ed3d8368da520d465cc909bc0">M0</a>, SpMat <a class="el" href="#af97e49a98f2a9f390abb52cdaf998577">M1</a>, SpMat <a class="el" href="#a93e3e540d2f3d3cd343f9a66867ec03a">M2</a>, Vect theta_prior, string solver_type, const bool <a class="el" href="#adc24faaa8937de8de88dde11fa9020f7">constr</a>, const MatrixXd <a class="el" href="#af80d7b7e847c30706a826a1c6d7c2fc1">Dx</a>, const MatrixXd <a class="el" href="#a5a765bc4a434d2c4926b7c035984dd66">Dxy</a>, const bool validate, const Vect w)</td></tr>
<tr class="memdesc:a35269dd8407ce1c126a4b87a31b7a310"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for spatial temporal model.  <br /></td></tr>
<tr class="separator:a35269dd8407ce1c126a4b87a31b7a310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c031e4b1773db975d3038ac01b0977" id="r_a42c031e4b1773db975d3038ac01b0977"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42c031e4b1773db975d3038ac01b0977">operator()</a> (Vect &amp;theta, Vect &amp;grad)</td></tr>
<tr class="memdesc:a42c031e4b1773db975d3038ac01b0977"><td class="mdescLeft">&#160;</td><td class="mdescRight">structure required by <a class="el" href="classBFGS.html">BFGS</a> solver, requires : theta, gradient theta  <br /></td></tr>
<tr class="separator:a42c031e4b1773db975d3038ac01b0977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a7918139c515f19f4663057ca3e5cc" id="r_a33a7918139c515f19f4663057ca3e5cc"><td class="memItemLeft" align="right" valign="top"><a id="a33a7918139c515f19f4663057ca3e5cc" name="a33a7918139c515f19f4663057ca3e5cc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>computeG</b> (Vect &amp;theta)</td></tr>
<tr class="memdesc:a33a7918139c515f19f4663057ca3e5cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">overwriting G every time, not explicitly listed, better way to do this? needs to be stored after every iteration for smart hessian ... <br  />
 <br /></td></tr>
<tr class="separator:a33a7918139c515f19f4663057ca3e5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc197a1ae82c5265a0a465c4cfa2727" id="r_a4fc197a1ae82c5265a0a465c4cfa2727"><td class="memItemLeft" align="right" valign="top"><a id="a4fc197a1ae82c5265a0a465c4cfa2727" name="a4fc197a1ae82c5265a0a465c4cfa2727"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>get_fct_count</b> ()</td></tr>
<tr class="separator:a4fc197a1ae82c5265a0a465c4cfa2727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfdc66118e93525b7814f53c6b50e652" id="r_adfdc66118e93525b7814f53c6b50e652"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfdc66118e93525b7814f53c6b50e652">convert_theta2interpret</a> (double lgamE, double lgamS, double lgamT, double &amp;sigU, double &amp;ranS, double &amp;ranT)</td></tr>
<tr class="memdesc:adfdc66118e93525b7814f53c6b50e652"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert hyperparameters theta from the model parametrisation to the interpretable parametrisation ie. from log(gamma_E, gamma_s, gamma_t) to log(sigma.u, rangeS, rangeT)  <br /></td></tr>
<tr class="separator:adfdc66118e93525b7814f53c6b50e652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada9c36637820d3eaad19d4b3449c98ad" id="r_ada9c36637820d3eaad19d4b3449c98ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada9c36637820d3eaad19d4b3449c98ad">convert_interpret2theta</a> (double sigU, double ranS, double ranT, double &amp;lgamE, double &amp;lgamS, double &amp;lgamT)</td></tr>
<tr class="memdesc:ada9c36637820d3eaad19d4b3449c98ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert hyperparameters theta from the interpretable parametrisation to the model parametrisation ie. from log(sigma.u, rangeS, rangeT) to log(gamma_E, gamma_s, gamma_t)  <br /></td></tr>
<tr class="separator:ada9c36637820d3eaad19d4b3449c98ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ffad9798426544c91b1f3420e9c8c9" id="r_ac6ffad9798426544c91b1f3420e9c8c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6ffad9798426544c91b1f3420e9c8c9">get_mu</a> (Vect &amp;theta, Vect &amp;<a class="el" href="#aa6d3402de41235b5226e1e93be4a9dbe">mu</a>, ArrayXi &amp;fact_to_rank_list)</td></tr>
<tr class="memdesc:ac6ffad9798426544c91b1f3420e9c8c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">get conditional mean mu for theta.  <br /></td></tr>
<tr class="separator:ac6ffad9798426544c91b1f3420e9c8c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b59d9c23fb21cf517f281ae48ac970d" id="r_a6b59d9c23fb21cf517f281ae48ac970d"><td class="memItemLeft" align="right" valign="top">Vect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b59d9c23fb21cf517f281ae48ac970d">get_grad</a> ()</td></tr>
<tr class="memdesc:a6b59d9c23fb21cf517f281ae48ac970d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns current gradient of theta.  <br /></td></tr>
<tr class="separator:a6b59d9c23fb21cf517f281ae48ac970d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb8efdc44447d6224893f6debf29540" id="r_a9eb8efdc44447d6224893f6debf29540"><td class="memItemLeft" align="right" valign="top">MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9eb8efdc44447d6224893f6debf29540">get_Covariance</a> (Vect &amp;theta, double eps)</td></tr>
<tr class="memdesc:a9eb8efdc44447d6224893f6debf29540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute Covariance matrix of hyperparameters theta, at theta.  <br /></td></tr>
<tr class="separator:a9eb8efdc44447d6224893f6debf29540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2589db16c7d4784189d003016d99cf89" id="r_a2589db16c7d4784189d003016d99cf89"><td class="memItemLeft" align="right" valign="top"><a id="a2589db16c7d4784189d003016d99cf89" name="a2589db16c7d4784189d003016d99cf89"></a>
MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><b>get_Cov_interpret_param</b> (Vect &amp;interpret_theta, double eps)</td></tr>
<tr class="separator:a2589db16c7d4784189d003016d99cf89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52398b5f03001d24a9bd69d02e7c9773" id="r_a52398b5f03001d24a9bd69d02e7c9773"><td class="memItemLeft" align="right" valign="top"><a id="a52398b5f03001d24a9bd69d02e7c9773" name="a52398b5f03001d24a9bd69d02e7c9773"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>f_eval</b> (Vect &amp;theta)</td></tr>
<tr class="separator:a52398b5f03001d24a9bd69d02e7c9773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d01ba1dcfedc1e9b250586c0f6ab98" id="r_ab6d01ba1dcfedc1e9b250586c0f6ab98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6d01ba1dcfedc1e9b250586c0f6ab98">get_marginals_f</a> (Vect &amp;theta, Vect &amp;vars)</td></tr>
<tr class="memdesc:ab6d01ba1dcfedc1e9b250586c0f6ab98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the marginal variances of the latent parameters at theta. Using selected inversion procedure.  <br /></td></tr>
<tr class="separator:ab6d01ba1dcfedc1e9b250586c0f6ab98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba126f6b1bc95b8815465debaedd650" id="r_a8ba126f6b1bc95b8815465debaedd650"><td class="memItemLeft" align="right" valign="top">MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ba126f6b1bc95b8815465debaedd650">hess_eval</a> (Vect &amp;theta, double eps)</td></tr>
<tr class="memdesc:a8ba126f6b1bc95b8815465debaedd650"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the hessian at theta using second order finite difference. Is used be get_Covariance.  <br /></td></tr>
<tr class="separator:a8ba126f6b1bc95b8815465debaedd650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67ecf629a6a81db6966614517acfbbb" id="r_ae67ecf629a6a81db6966614517acfbbb"><td class="memItemLeft" align="right" valign="top"><a id="ae67ecf629a6a81db6966614517acfbbb" name="ae67ecf629a6a81db6966614517acfbbb"></a>
MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><b>hess_eval_interpret_theta</b> (Vect &amp;interpret_theta, double eps)</td></tr>
<tr class="separator:ae67ecf629a6a81db6966614517acfbbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240a43fde6a2e26c30275b24f99f5d4e" id="r_a240a43fde6a2e26c30275b24f99f5d4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a240a43fde6a2e26c30275b24f99f5d4e">check_pos_def</a> (MatrixXd &amp;hess)</td></tr>
<tr class="memdesc:a240a43fde6a2e26c30275b24f99f5d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if Hessian positive definite (matrix assumed to be dense &amp; small since dim(theta) small)  <br /></td></tr>
<tr class="separator:a240a43fde6a2e26c30275b24f99f5d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a3133494a5479b3f1f8a557e9490a35" id="r_a6a3133494a5479b3f1f8a557e9490a35"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a3133494a5479b3f1f8a557e9490a35">eval_post_theta</a> (Vect &amp;theta, Vect &amp;<a class="el" href="#aa6d3402de41235b5226e1e93be4a9dbe">mu</a>, ArrayXi &amp;fact_to_rank_list)</td></tr>
<tr class="memdesc:a6a3133494a5479b3f1f8a557e9490a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Core function. Evaluate posterior of theta. mu are latent parameters.  <br /></td></tr>
<tr class="separator:a6a3133494a5479b3f1f8a557e9490a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52137ac2ce65806e9b9e99177adecd33" id="r_a52137ac2ce65806e9b9e99177adecd33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52137ac2ce65806e9b9e99177adecd33">eval_log_gaussian_prior_hp</a> (double &amp;log_prior, double *thetai, double *thetai_original)</td></tr>
<tr class="memdesc:a52137ac2ce65806e9b9e99177adecd33"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate log prior of the hyperparameters using original theta value  <br /></td></tr>
<tr class="separator:a52137ac2ce65806e9b9e99177adecd33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f7a4987eeb15a84b1af7c784c3b6ff" id="r_a66f7a4987eeb15a84b1af7c784c3b6ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66f7a4987eeb15a84b1af7c784c3b6ff">eval_log_pc_prior_hp</a> (double &amp;log_sum, Vect &amp;lambda, Vect &amp;theta_interpret)</td></tr>
<tr class="memdesc:a66f7a4987eeb15a84b1af7c784c3b6ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate log prior using PC prior  <br /></td></tr>
<tr class="separator:a66f7a4987eeb15a84b1af7c784c3b6ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a1b9ac95394ba1992ed25b4b34e128" id="r_a79a1b9ac95394ba1992ed25b4b34e128"><td class="memItemLeft" align="right" valign="top"><a id="a79a1b9ac95394ba1992ed25b4b34e128" name="a79a1b9ac95394ba1992ed25b4b34e128"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>update_mean_constr</b> (const MatrixXd &amp;D, Vect &amp;e, Vect &amp;sol, MatrixXd &amp;V, MatrixXd &amp;W, MatrixXd &amp;U, Vect &amp;updated_sol)</td></tr>
<tr class="separator:a79a1b9ac95394ba1992ed25b4b34e128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4973d0c8335220faafa3bdb2fcfeb331" id="r_a4973d0c8335220faafa3bdb2fcfeb331"><td class="memItemLeft" align="right" valign="top"><a id="a4973d0c8335220faafa3bdb2fcfeb331" name="a4973d0c8335220faafa3bdb2fcfeb331"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>eval_log_dens_constr</b> (Vect &amp;x, Vect &amp;<a class="el" href="#aa6d3402de41235b5226e1e93be4a9dbe">mu</a>, SpMat &amp;Q, double &amp;log_det_Q, const MatrixXd &amp;D, MatrixXd &amp;W, double &amp;val_log_dens)</td></tr>
<tr class="separator:a4973d0c8335220faafa3bdb2fcfeb331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a981439fd52c6b46c1666fd45eb5faa92" id="r_a981439fd52c6b46c1666fd45eb5faa92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a981439fd52c6b46c1666fd45eb5faa92">eval_log_prior_lat</a> (Vect &amp;theta, double &amp;val)</td></tr>
<tr class="memdesc:a981439fd52c6b46c1666fd45eb5faa92"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate log prior of random effects  <br /></td></tr>
<tr class="separator:a981439fd52c6b46c1666fd45eb5faa92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97173a441c0f2f6b9dc2a5fe85e1d6ad" id="r_a97173a441c0f2f6b9dc2a5fe85e1d6ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97173a441c0f2f6b9dc2a5fe85e1d6ad">eval_likelihood</a> (Vect &amp;theta, double &amp;log_det, double &amp;val)</td></tr>
<tr class="memdesc:a97173a441c0f2f6b9dc2a5fe85e1d6ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute log likelihood : log_det tau*no and value -theta*yTy  <br /></td></tr>
<tr class="separator:a97173a441c0f2f6b9dc2a5fe85e1d6ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ceec7e512bf71ca7267f01733ec8719" id="r_a2ceec7e512bf71ca7267f01733ec8719"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ceec7e512bf71ca7267f01733ec8719">construct_Q_spatial</a> (Vect &amp;theta, SpMat &amp;Qs)</td></tr>
<tr class="memdesc:a2ceec7e512bf71ca7267f01733ec8719"><td class="mdescLeft">&#160;</td><td class="mdescRight">spatial model : SPDE discretisation &ndash; matrix construction  <br /></td></tr>
<tr class="separator:a2ceec7e512bf71ca7267f01733ec8719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41faf4a6b8b2a30168f35805c2c7b3f" id="r_ac41faf4a6b8b2a30168f35805c2c7b3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac41faf4a6b8b2a30168f35805c2c7b3f">construct_Q_spat_temp</a> (Vect &amp;theta, SpMat &amp;Qst)</td></tr>
<tr class="memdesc:ac41faf4a6b8b2a30168f35805c2c7b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">spatial temporal model : SPDE discretisation. DEMF(1,2,1) model.  <br /></td></tr>
<tr class="separator:ac41faf4a6b8b2a30168f35805c2c7b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb642337f6f4db477be2318bb9796f2c" id="r_acb642337f6f4db477be2318bb9796f2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb642337f6f4db477be2318bb9796f2c">construct_Q</a> (Vect &amp;theta, SpMat &amp;Q)</td></tr>
<tr class="memdesc:acb642337f6f4db477be2318bb9796f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct precision matrix. Calls spatial, spatial-temporal, etc.  <br /></td></tr>
<tr class="separator:acb642337f6f4db477be2318bb9796f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69559f2f98cbdd4b844a9e0c571d64d" id="r_af69559f2f98cbdd4b844a9e0c571d64d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af69559f2f98cbdd4b844a9e0c571d64d">construct_b</a> (Vect &amp;theta, Vect &amp;rhs)</td></tr>
<tr class="memdesc:af69559f2f98cbdd4b844a9e0c571d64d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble right-handside.  <br /></td></tr>
<tr class="separator:af69559f2f98cbdd4b844a9e0c571d64d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7bf017b26af54eb68645b49a2c99fcb" id="r_ae7bf017b26af54eb68645b49a2c99fcb"><td class="memItemLeft" align="right" valign="top"><a id="ae7bf017b26af54eb68645b49a2c99fcb" name="ae7bf017b26af54eb68645b49a2c99fcb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>update_mean_constr</b> (MatrixXd &amp;D, Vect &amp;e, Vect &amp;sol, MatrixXd &amp;V, MatrixXd &amp;W)</td></tr>
<tr class="separator:ae7bf017b26af54eb68645b49a2c99fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af7519622a314b59a75f5b84f15ad9a" id="r_a5af7519622a314b59a75f5b84f15ad9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5af7519622a314b59a75f5b84f15ad9a">eval_denominator</a> (Vect &amp;theta, double &amp;val, SpMat &amp;Q, Vect &amp;rhs, Vect &amp;<a class="el" href="#aa6d3402de41235b5226e1e93be4a9dbe">mu</a>)</td></tr>
<tr class="memdesc:a5af7519622a314b59a75f5b84f15ad9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate denominator: conditional probability of Qx|y.  <br /></td></tr>
<tr class="separator:a5af7519622a314b59a75f5b84f15ad9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d7a18584db9aace5d217437bdfe84fa" id="r_a3d7a18584db9aace5d217437bdfe84fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d7a18584db9aace5d217437bdfe84fa">eval_gradient</a> (Vect &amp;theta, double f_theta, Vect &amp;<a class="el" href="#aa6d3402de41235b5226e1e93be4a9dbe">mu</a>, Vect &amp;grad)</td></tr>
<tr class="memdesc:a3d7a18584db9aace5d217437bdfe84fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute gradient using central finite difference stencil. Parallelised with OpenMP.  <br /></td></tr>
<tr class="separator:a3d7a18584db9aace5d217437bdfe84fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f05821cf3af095b3a9fa66919266bf" id="r_a29f05821cf3af095b3a9fa66919266bf"><td class="memItemLeft" align="right" valign="top"><a id="a29f05821cf3af095b3a9fa66919266bf" name="a29f05821cf3af095b3a9fa66919266bf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>record_times</b> (std::string file_name, int <a class="el" href="#a6f35b1d4e2eb881fd0b8513571874bc0">iter_count</a>, double t_Ftheta_ext, double t_thread_nom, double t_priorHyp, double t_priorLat, double t_priorLatAMat, double t_priorLatChol, double t_likel, double t_thread_denom, double t_condLat, double t_condLatAMat, double t_condLatChol, double t_condLatSolve)</td></tr>
<tr class="separator:a29f05821cf3af095b3a9fa66919266bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d5640ff12bb9e2828559153c61f352" id="r_a72d5640ff12bb9e2828559153c61f352"><td class="memItemLeft" align="right" valign="top"><a id="a72d5640ff12bb9e2828559153c61f352" name="a72d5640ff12bb9e2828559153c61f352"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~PostTheta</b> ()</td></tr>
<tr class="memdesc:a72d5640ff12bb9e2828559153c61f352"><td class="mdescLeft">&#160;</td><td class="mdescRight">class destructor. Frees memory allocated by <a class="el" href="classPostTheta.html" title="Computes the Posterior of the hyperparameters theta.">PostTheta</a> class. <br /></td></tr>
<tr class="separator:a72d5640ff12bb9e2828559153c61f352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56db4c858de1c0dc0721bf19e60c493c" id="r_a56db4c858de1c0dc0721bf19e60c493c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56db4c858de1c0dc0721bf19e60c493c">PostTheta</a> (int <a class="el" href="#a4def6d3a66d18ebb36f3db4e533626f6">ns</a>, int <a class="el" href="#ac84bd657538bc782335e992055a0817e">nt</a>, int <a class="el" href="#a90f7a7de632412bd9017e33a594105f4">nb</a>, int <a class="el" href="#aec066996693ada57084aa1ee52f04948">no</a>, MatrixXd <a class="el" href="#acc70e6f2659235075873ecee40a126cf">B</a>, Vect <a class="el" href="#a762b11a93e586f00ded70b7776e075ad">y</a>, Vect theta_prior, string solver_type, const bool <a class="el" href="#adc24faaa8937de8de88dde11fa9020f7">constr</a>, const MatrixXd <a class="el" href="#a5a765bc4a434d2c4926b7c035984dd66">Dxy</a>, const bool validate, const Vect w)</td></tr>
<tr class="memdesc:a56db4c858de1c0dc0721bf19e60c493c"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for regression model (no random effects).  <br /></td></tr>
<tr class="separator:a56db4c858de1c0dc0721bf19e60c493c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff16e221ec1a93e07d27553fb817c6d" id="r_a4ff16e221ec1a93e07d27553fb817c6d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ff16e221ec1a93e07d27553fb817c6d">PostTheta</a> (int <a class="el" href="#a4def6d3a66d18ebb36f3db4e533626f6">ns</a>, int <a class="el" href="#ac84bd657538bc782335e992055a0817e">nt</a>, int <a class="el" href="#a90f7a7de632412bd9017e33a594105f4">nb</a>, int <a class="el" href="#aec066996693ada57084aa1ee52f04948">no</a>, SpMat <a class="el" href="#a87a3adb6b92056e8dacea22fa894300a">Ax</a>, Vect <a class="el" href="#a762b11a93e586f00ded70b7776e075ad">y</a>, SpMat <a class="el" href="#a71833a89a8c3dc58117eb467feac7674">c0</a>, SpMat <a class="el" href="#ade2defef59b9295d794620fefb7c8b05">g1</a>, SpMat <a class="el" href="#ae1be0d6e322a26924b67b6258cf55b08">g2</a>, Vect theta_prior, string solver_type, const bool <a class="el" href="#adc24faaa8937de8de88dde11fa9020f7">constr</a>, const MatrixXd <a class="el" href="#af80d7b7e847c30706a826a1c6d7c2fc1">Dx</a>, const MatrixXd <a class="el" href="#a5a765bc4a434d2c4926b7c035984dd66">Dxy</a>, const bool validate, const Vect w)</td></tr>
<tr class="memdesc:a4ff16e221ec1a93e07d27553fb817c6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for spatial model (order 2).  <br /></td></tr>
<tr class="separator:a4ff16e221ec1a93e07d27553fb817c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35269dd8407ce1c126a4b87a31b7a310" id="r_a35269dd8407ce1c126a4b87a31b7a310"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35269dd8407ce1c126a4b87a31b7a310">PostTheta</a> (int <a class="el" href="#a4def6d3a66d18ebb36f3db4e533626f6">ns</a>, int <a class="el" href="#ac84bd657538bc782335e992055a0817e">nt</a>, int <a class="el" href="#a90f7a7de632412bd9017e33a594105f4">nb</a>, int <a class="el" href="#aec066996693ada57084aa1ee52f04948">no</a>, SpMat <a class="el" href="#a87a3adb6b92056e8dacea22fa894300a">Ax</a>, Vect <a class="el" href="#a762b11a93e586f00ded70b7776e075ad">y</a>, SpMat <a class="el" href="#a71833a89a8c3dc58117eb467feac7674">c0</a>, SpMat <a class="el" href="#ade2defef59b9295d794620fefb7c8b05">g1</a>, SpMat <a class="el" href="#ae1be0d6e322a26924b67b6258cf55b08">g2</a>, SpMat <a class="el" href="#ac59ad0f384dc3d3f73c6f340aaac2996">g3</a>, SpMat <a class="el" href="#a06391c3ed3d8368da520d465cc909bc0">M0</a>, SpMat <a class="el" href="#af97e49a98f2a9f390abb52cdaf998577">M1</a>, SpMat <a class="el" href="#a93e3e540d2f3d3cd343f9a66867ec03a">M2</a>, Vect theta_prior, string solver_type, const bool <a class="el" href="#adc24faaa8937de8de88dde11fa9020f7">constr</a>, const MatrixXd <a class="el" href="#af80d7b7e847c30706a826a1c6d7c2fc1">Dx</a>, const MatrixXd <a class="el" href="#a5a765bc4a434d2c4926b7c035984dd66">Dxy</a>, const bool validate, const Vect w)</td></tr>
<tr class="memdesc:a35269dd8407ce1c126a4b87a31b7a310"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for spatial temporal model.  <br /></td></tr>
<tr class="separator:a35269dd8407ce1c126a4b87a31b7a310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c031e4b1773db975d3038ac01b0977" id="r_a42c031e4b1773db975d3038ac01b0977"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42c031e4b1773db975d3038ac01b0977">operator()</a> (Vect &amp;theta, Vect &amp;grad)</td></tr>
<tr class="memdesc:a42c031e4b1773db975d3038ac01b0977"><td class="mdescLeft">&#160;</td><td class="mdescRight">structure required by <a class="el" href="classBFGS.html">BFGS</a> solver, requires : theta, gradient theta  <br /></td></tr>
<tr class="separator:a42c031e4b1773db975d3038ac01b0977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a7918139c515f19f4663057ca3e5cc" id="r_a33a7918139c515f19f4663057ca3e5cc"><td class="memItemLeft" align="right" valign="top"><a id="a33a7918139c515f19f4663057ca3e5cc" name="a33a7918139c515f19f4663057ca3e5cc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>computeG</b> (Vect &amp;theta)</td></tr>
<tr class="memdesc:a33a7918139c515f19f4663057ca3e5cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">overwriting G every time, not explicitly listed, better way to do this? needs to be stored after every iteration for smart hessian ... <br  />
 <br /></td></tr>
<tr class="separator:a33a7918139c515f19f4663057ca3e5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc197a1ae82c5265a0a465c4cfa2727" id="r_a4fc197a1ae82c5265a0a465c4cfa2727"><td class="memItemLeft" align="right" valign="top"><a id="a4fc197a1ae82c5265a0a465c4cfa2727" name="a4fc197a1ae82c5265a0a465c4cfa2727"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>get_fct_count</b> ()</td></tr>
<tr class="separator:a4fc197a1ae82c5265a0a465c4cfa2727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfdc66118e93525b7814f53c6b50e652" id="r_adfdc66118e93525b7814f53c6b50e652"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfdc66118e93525b7814f53c6b50e652">convert_theta2interpret</a> (double lgamE, double lgamS, double lgamT, double &amp;sigU, double &amp;ranS, double &amp;ranT)</td></tr>
<tr class="memdesc:adfdc66118e93525b7814f53c6b50e652"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert hyperparameters theta from the model parametrisation to the interpretable parametrisation ie. from log(gamma_E, gamma_s, gamma_t) to log(sigma.u, rangeS, rangeT)  <br /></td></tr>
<tr class="separator:adfdc66118e93525b7814f53c6b50e652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada9c36637820d3eaad19d4b3449c98ad" id="r_ada9c36637820d3eaad19d4b3449c98ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada9c36637820d3eaad19d4b3449c98ad">convert_interpret2theta</a> (double sigU, double ranS, double ranT, double &amp;lgamE, double &amp;lgamS, double &amp;lgamT)</td></tr>
<tr class="memdesc:ada9c36637820d3eaad19d4b3449c98ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert hyperparameters theta from the interpretable parametrisation to the model parametrisation ie. from log(sigma.u, rangeS, rangeT) to log(gamma_E, gamma_s, gamma_t)  <br /></td></tr>
<tr class="separator:ada9c36637820d3eaad19d4b3449c98ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0f3a13e200dc7833ad7297dc67d0b9" id="r_aff0f3a13e200dc7833ad7297dc67d0b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff0f3a13e200dc7833ad7297dc67d0b9">get_mu</a> (Vect &amp;theta, Vect &amp;<a class="el" href="#aa6d3402de41235b5226e1e93be4a9dbe">mu</a>)</td></tr>
<tr class="memdesc:aff0f3a13e200dc7833ad7297dc67d0b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">get conditional mean mu for theta.  <br /></td></tr>
<tr class="separator:aff0f3a13e200dc7833ad7297dc67d0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b59d9c23fb21cf517f281ae48ac970d" id="r_a6b59d9c23fb21cf517f281ae48ac970d"><td class="memItemLeft" align="right" valign="top">Vect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b59d9c23fb21cf517f281ae48ac970d">get_grad</a> ()</td></tr>
<tr class="memdesc:a6b59d9c23fb21cf517f281ae48ac970d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns current gradient of theta.  <br /></td></tr>
<tr class="separator:a6b59d9c23fb21cf517f281ae48ac970d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb8efdc44447d6224893f6debf29540" id="r_a9eb8efdc44447d6224893f6debf29540"><td class="memItemLeft" align="right" valign="top">MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9eb8efdc44447d6224893f6debf29540">get_Covariance</a> (Vect &amp;theta, double eps)</td></tr>
<tr class="memdesc:a9eb8efdc44447d6224893f6debf29540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute Covariance matrix of hyperparameters theta, at theta.  <br /></td></tr>
<tr class="separator:a9eb8efdc44447d6224893f6debf29540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2589db16c7d4784189d003016d99cf89" id="r_a2589db16c7d4784189d003016d99cf89"><td class="memItemLeft" align="right" valign="top"><a id="a2589db16c7d4784189d003016d99cf89" name="a2589db16c7d4784189d003016d99cf89"></a>
MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><b>get_Cov_interpret_param</b> (Vect &amp;interpret_theta, double eps)</td></tr>
<tr class="separator:a2589db16c7d4784189d003016d99cf89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52398b5f03001d24a9bd69d02e7c9773" id="r_a52398b5f03001d24a9bd69d02e7c9773"><td class="memItemLeft" align="right" valign="top"><a id="a52398b5f03001d24a9bd69d02e7c9773" name="a52398b5f03001d24a9bd69d02e7c9773"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>f_eval</b> (Vect &amp;theta)</td></tr>
<tr class="separator:a52398b5f03001d24a9bd69d02e7c9773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d01ba1dcfedc1e9b250586c0f6ab98" id="r_ab6d01ba1dcfedc1e9b250586c0f6ab98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6d01ba1dcfedc1e9b250586c0f6ab98">get_marginals_f</a> (Vect &amp;theta, Vect &amp;vars)</td></tr>
<tr class="memdesc:ab6d01ba1dcfedc1e9b250586c0f6ab98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the marginal variances of the latent parameters at theta. Using selected inversion procedure.  <br /></td></tr>
<tr class="separator:ab6d01ba1dcfedc1e9b250586c0f6ab98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba126f6b1bc95b8815465debaedd650" id="r_a8ba126f6b1bc95b8815465debaedd650"><td class="memItemLeft" align="right" valign="top">MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ba126f6b1bc95b8815465debaedd650">hess_eval</a> (Vect &amp;theta, double eps)</td></tr>
<tr class="memdesc:a8ba126f6b1bc95b8815465debaedd650"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the hessian at theta using second order finite difference. Is used be get_Covariance.  <br /></td></tr>
<tr class="separator:a8ba126f6b1bc95b8815465debaedd650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67ecf629a6a81db6966614517acfbbb" id="r_ae67ecf629a6a81db6966614517acfbbb"><td class="memItemLeft" align="right" valign="top"><a id="ae67ecf629a6a81db6966614517acfbbb" name="ae67ecf629a6a81db6966614517acfbbb"></a>
MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><b>hess_eval_interpret_theta</b> (Vect &amp;interpret_theta, double eps)</td></tr>
<tr class="separator:ae67ecf629a6a81db6966614517acfbbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240a43fde6a2e26c30275b24f99f5d4e" id="r_a240a43fde6a2e26c30275b24f99f5d4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a240a43fde6a2e26c30275b24f99f5d4e">check_pos_def</a> (MatrixXd &amp;hess)</td></tr>
<tr class="memdesc:a240a43fde6a2e26c30275b24f99f5d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if Hessian positive definite (matrix assumed to be dense &amp; small since dim(theta) small)  <br /></td></tr>
<tr class="separator:a240a43fde6a2e26c30275b24f99f5d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a437a6716c8fe32396f0643f3dba43e5b" id="r_a437a6716c8fe32396f0643f3dba43e5b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a437a6716c8fe32396f0643f3dba43e5b">eval_post_theta</a> (Vect &amp;theta, Vect &amp;<a class="el" href="#aa6d3402de41235b5226e1e93be4a9dbe">mu</a>)</td></tr>
<tr class="memdesc:a437a6716c8fe32396f0643f3dba43e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Core function. Evaluate posterior of theta. mu are latent parameters.  <br /></td></tr>
<tr class="separator:a437a6716c8fe32396f0643f3dba43e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52137ac2ce65806e9b9e99177adecd33" id="r_a52137ac2ce65806e9b9e99177adecd33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52137ac2ce65806e9b9e99177adecd33">eval_log_gaussian_prior_hp</a> (double &amp;log_prior, double *thetai, double *thetai_original)</td></tr>
<tr class="memdesc:a52137ac2ce65806e9b9e99177adecd33"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate log prior of the hyperparameters using original theta value  <br /></td></tr>
<tr class="separator:a52137ac2ce65806e9b9e99177adecd33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f7a4987eeb15a84b1af7c784c3b6ff" id="r_a66f7a4987eeb15a84b1af7c784c3b6ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66f7a4987eeb15a84b1af7c784c3b6ff">eval_log_pc_prior_hp</a> (double &amp;log_sum, Vect &amp;lambda, Vect &amp;theta_interpret)</td></tr>
<tr class="memdesc:a66f7a4987eeb15a84b1af7c784c3b6ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate log prior using PC prior  <br /></td></tr>
<tr class="separator:a66f7a4987eeb15a84b1af7c784c3b6ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a1b9ac95394ba1992ed25b4b34e128" id="r_a79a1b9ac95394ba1992ed25b4b34e128"><td class="memItemLeft" align="right" valign="top"><a id="a79a1b9ac95394ba1992ed25b4b34e128" name="a79a1b9ac95394ba1992ed25b4b34e128"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>update_mean_constr</b> (const MatrixXd &amp;D, Vect &amp;e, Vect &amp;sol, MatrixXd &amp;V, MatrixXd &amp;W, MatrixXd &amp;U, Vect &amp;updated_sol)</td></tr>
<tr class="separator:a79a1b9ac95394ba1992ed25b4b34e128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4973d0c8335220faafa3bdb2fcfeb331" id="r_a4973d0c8335220faafa3bdb2fcfeb331"><td class="memItemLeft" align="right" valign="top"><a id="a4973d0c8335220faafa3bdb2fcfeb331" name="a4973d0c8335220faafa3bdb2fcfeb331"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>eval_log_dens_constr</b> (Vect &amp;x, Vect &amp;<a class="el" href="#aa6d3402de41235b5226e1e93be4a9dbe">mu</a>, SpMat &amp;Q, double &amp;log_det_Q, const MatrixXd &amp;D, MatrixXd &amp;W, double &amp;val_log_dens)</td></tr>
<tr class="separator:a4973d0c8335220faafa3bdb2fcfeb331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a981439fd52c6b46c1666fd45eb5faa92" id="r_a981439fd52c6b46c1666fd45eb5faa92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a981439fd52c6b46c1666fd45eb5faa92">eval_log_prior_lat</a> (Vect &amp;theta, double &amp;val)</td></tr>
<tr class="memdesc:a981439fd52c6b46c1666fd45eb5faa92"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate log prior of random effects  <br /></td></tr>
<tr class="separator:a981439fd52c6b46c1666fd45eb5faa92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97173a441c0f2f6b9dc2a5fe85e1d6ad" id="r_a97173a441c0f2f6b9dc2a5fe85e1d6ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97173a441c0f2f6b9dc2a5fe85e1d6ad">eval_likelihood</a> (Vect &amp;theta, double &amp;log_det, double &amp;val)</td></tr>
<tr class="memdesc:a97173a441c0f2f6b9dc2a5fe85e1d6ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute log likelihood : log_det tau*no and value -theta*yTy  <br /></td></tr>
<tr class="separator:a97173a441c0f2f6b9dc2a5fe85e1d6ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ceec7e512bf71ca7267f01733ec8719" id="r_a2ceec7e512bf71ca7267f01733ec8719"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ceec7e512bf71ca7267f01733ec8719">construct_Q_spatial</a> (Vect &amp;theta, SpMat &amp;Qs)</td></tr>
<tr class="memdesc:a2ceec7e512bf71ca7267f01733ec8719"><td class="mdescLeft">&#160;</td><td class="mdescRight">spatial model : SPDE discretisation &ndash; matrix construction  <br /></td></tr>
<tr class="separator:a2ceec7e512bf71ca7267f01733ec8719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41faf4a6b8b2a30168f35805c2c7b3f" id="r_ac41faf4a6b8b2a30168f35805c2c7b3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac41faf4a6b8b2a30168f35805c2c7b3f">construct_Q_spat_temp</a> (Vect &amp;theta, SpMat &amp;Qst)</td></tr>
<tr class="memdesc:ac41faf4a6b8b2a30168f35805c2c7b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">spatial temporal model : SPDE discretisation. DEMF(1,2,1) model.  <br /></td></tr>
<tr class="separator:ac41faf4a6b8b2a30168f35805c2c7b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb642337f6f4db477be2318bb9796f2c" id="r_acb642337f6f4db477be2318bb9796f2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb642337f6f4db477be2318bb9796f2c">construct_Q</a> (Vect &amp;theta, SpMat &amp;Q)</td></tr>
<tr class="memdesc:acb642337f6f4db477be2318bb9796f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct precision matrix. Calls spatial, spatial-temporal, etc.  <br /></td></tr>
<tr class="separator:acb642337f6f4db477be2318bb9796f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69559f2f98cbdd4b844a9e0c571d64d" id="r_af69559f2f98cbdd4b844a9e0c571d64d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af69559f2f98cbdd4b844a9e0c571d64d">construct_b</a> (Vect &amp;theta, Vect &amp;rhs)</td></tr>
<tr class="memdesc:af69559f2f98cbdd4b844a9e0c571d64d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble right-handside.  <br /></td></tr>
<tr class="separator:af69559f2f98cbdd4b844a9e0c571d64d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7bf017b26af54eb68645b49a2c99fcb" id="r_ae7bf017b26af54eb68645b49a2c99fcb"><td class="memItemLeft" align="right" valign="top"><a id="ae7bf017b26af54eb68645b49a2c99fcb" name="ae7bf017b26af54eb68645b49a2c99fcb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>update_mean_constr</b> (MatrixXd &amp;D, Vect &amp;e, Vect &amp;sol, MatrixXd &amp;V, MatrixXd &amp;W)</td></tr>
<tr class="separator:ae7bf017b26af54eb68645b49a2c99fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af7519622a314b59a75f5b84f15ad9a" id="r_a5af7519622a314b59a75f5b84f15ad9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5af7519622a314b59a75f5b84f15ad9a">eval_denominator</a> (Vect &amp;theta, double &amp;val, SpMat &amp;Q, Vect &amp;rhs, Vect &amp;<a class="el" href="#aa6d3402de41235b5226e1e93be4a9dbe">mu</a>)</td></tr>
<tr class="memdesc:a5af7519622a314b59a75f5b84f15ad9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate denominator: conditional probability of Qx|y.  <br /></td></tr>
<tr class="separator:a5af7519622a314b59a75f5b84f15ad9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d7a18584db9aace5d217437bdfe84fa" id="r_a3d7a18584db9aace5d217437bdfe84fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d7a18584db9aace5d217437bdfe84fa">eval_gradient</a> (Vect &amp;theta, double f_theta, Vect &amp;<a class="el" href="#aa6d3402de41235b5226e1e93be4a9dbe">mu</a>, Vect &amp;grad)</td></tr>
<tr class="memdesc:a3d7a18584db9aace5d217437bdfe84fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute gradient using central finite difference stencil. Parallelised with OpenMP.  <br /></td></tr>
<tr class="separator:a3d7a18584db9aace5d217437bdfe84fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f05821cf3af095b3a9fa66919266bf" id="r_a29f05821cf3af095b3a9fa66919266bf"><td class="memItemLeft" align="right" valign="top"><a id="a29f05821cf3af095b3a9fa66919266bf" name="a29f05821cf3af095b3a9fa66919266bf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>record_times</b> (std::string file_name, int <a class="el" href="#a6f35b1d4e2eb881fd0b8513571874bc0">iter_count</a>, double t_Ftheta_ext, double t_thread_nom, double t_priorHyp, double t_priorLat, double t_priorLatAMat, double t_priorLatChol, double t_likel, double t_thread_denom, double t_condLat, double t_condLatAMat, double t_condLatChol, double t_condLatSolve)</td></tr>
<tr class="separator:a29f05821cf3af095b3a9fa66919266bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d5640ff12bb9e2828559153c61f352" id="r_a72d5640ff12bb9e2828559153c61f352"><td class="memItemLeft" align="right" valign="top"><a id="a72d5640ff12bb9e2828559153c61f352" name="a72d5640ff12bb9e2828559153c61f352"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~PostTheta</b> ()</td></tr>
<tr class="memdesc:a72d5640ff12bb9e2828559153c61f352"><td class="mdescLeft">&#160;</td><td class="mdescRight">class destructor. Frees memory allocated by <a class="el" href="classPostTheta.html" title="Computes the Posterior of the hyperparameters theta.">PostTheta</a> class. <br /></td></tr>
<tr class="separator:a72d5640ff12bb9e2828559153c61f352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45441d61f13cadb72c8fd19ba7047c9" id="r_ad45441d61f13cadb72c8fd19ba7047c9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad45441d61f13cadb72c8fd19ba7047c9">PostTheta</a> (int <a class="el" href="#a4def6d3a66d18ebb36f3db4e533626f6">ns</a>, int <a class="el" href="#ac84bd657538bc782335e992055a0817e">nt</a>, int <a class="el" href="#a90f7a7de632412bd9017e33a594105f4">nb</a>, int <a class="el" href="#aec066996693ada57084aa1ee52f04948">no</a>, MatrixXd <a class="el" href="#acc70e6f2659235075873ecee40a126cf">B</a>, Vect <a class="el" href="#a762b11a93e586f00ded70b7776e075ad">y</a>, Vect theta_prior, Vect mu_initial, string <a class="el" href="#ae3a7060408a27de614cc1cc8c8bdbd7c">likelihood</a>, Vect extraCoeffVecLik, string solver_type, const bool <a class="el" href="#adc24faaa8937de8de88dde11fa9020f7">constr</a>, const MatrixXd <a class="el" href="#a5a765bc4a434d2c4926b7c035984dd66">Dxy</a>, const bool validate, const Vect w)</td></tr>
<tr class="memdesc:ad45441d61f13cadb72c8fd19ba7047c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for regression model (no random effects).  <br /></td></tr>
<tr class="separator:ad45441d61f13cadb72c8fd19ba7047c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a152ca7756a325c1a1b7d334332578a25" id="r_a152ca7756a325c1a1b7d334332578a25"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a152ca7756a325c1a1b7d334332578a25">PostTheta</a> (int <a class="el" href="#a4def6d3a66d18ebb36f3db4e533626f6">ns</a>, int <a class="el" href="#ac84bd657538bc782335e992055a0817e">nt</a>, int <a class="el" href="#a90f7a7de632412bd9017e33a594105f4">nb</a>, int <a class="el" href="#aec066996693ada57084aa1ee52f04948">no</a>, SpMat <a class="el" href="#a87a3adb6b92056e8dacea22fa894300a">Ax</a>, Vect <a class="el" href="#a762b11a93e586f00ded70b7776e075ad">y</a>, SpMat <a class="el" href="#a71833a89a8c3dc58117eb467feac7674">c0</a>, SpMat <a class="el" href="#ade2defef59b9295d794620fefb7c8b05">g1</a>, SpMat <a class="el" href="#ae1be0d6e322a26924b67b6258cf55b08">g2</a>, Vect theta_prior, Vect mu_initial, string <a class="el" href="#ae3a7060408a27de614cc1cc8c8bdbd7c">likelihood</a>, Vect extraCoeffVecLik, string solver_type, int dim_spatial_domain, string <a class="el" href="#a48f86e8f68bce72ec4f0aed80ebebce7">manifold</a>, const bool <a class="el" href="#adc24faaa8937de8de88dde11fa9020f7">constr</a>, const MatrixXd <a class="el" href="#af80d7b7e847c30706a826a1c6d7c2fc1">Dx</a>, const MatrixXd <a class="el" href="#a5a765bc4a434d2c4926b7c035984dd66">Dxy</a>, const bool validate, const Vect w)</td></tr>
<tr class="memdesc:a152ca7756a325c1a1b7d334332578a25"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for spatial model (order 2).  <br /></td></tr>
<tr class="separator:a152ca7756a325c1a1b7d334332578a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac476b37613676dee3959a63978501bc7" id="r_ac476b37613676dee3959a63978501bc7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac476b37613676dee3959a63978501bc7">PostTheta</a> (int <a class="el" href="#a4def6d3a66d18ebb36f3db4e533626f6">ns</a>, int <a class="el" href="#ac84bd657538bc782335e992055a0817e">nt</a>, int <a class="el" href="#a90f7a7de632412bd9017e33a594105f4">nb</a>, int <a class="el" href="#aec066996693ada57084aa1ee52f04948">no</a>, SpMat <a class="el" href="#a87a3adb6b92056e8dacea22fa894300a">Ax</a>, Vect <a class="el" href="#a762b11a93e586f00ded70b7776e075ad">y</a>, SpMat <a class="el" href="#a71833a89a8c3dc58117eb467feac7674">c0</a>, SpMat <a class="el" href="#ade2defef59b9295d794620fefb7c8b05">g1</a>, SpMat <a class="el" href="#ae1be0d6e322a26924b67b6258cf55b08">g2</a>, SpMat <a class="el" href="#ac59ad0f384dc3d3f73c6f340aaac2996">g3</a>, SpMat <a class="el" href="#a06391c3ed3d8368da520d465cc909bc0">M0</a>, SpMat <a class="el" href="#af97e49a98f2a9f390abb52cdaf998577">M1</a>, SpMat <a class="el" href="#a93e3e540d2f3d3cd343f9a66867ec03a">M2</a>, Vect theta_prior, Vect mu_initial, string <a class="el" href="#ae3a7060408a27de614cc1cc8c8bdbd7c">likelihood</a>, Vect extraCoeffVecLik, string solver_type, int dim_spatial_domain, string <a class="el" href="#a48f86e8f68bce72ec4f0aed80ebebce7">manifold</a>, const bool <a class="el" href="#adc24faaa8937de8de88dde11fa9020f7">constr</a>, const MatrixXd <a class="el" href="#af80d7b7e847c30706a826a1c6d7c2fc1">Dx</a>, const MatrixXd <a class="el" href="#a5a765bc4a434d2c4926b7c035984dd66">Dxy</a>, const bool validate, const Vect w)</td></tr>
<tr class="memdesc:ac476b37613676dee3959a63978501bc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for spatial temporal model.  <br /></td></tr>
<tr class="separator:ac476b37613676dee3959a63978501bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa09b11852e0230bb4c9b174cc03f5c44" id="r_aa09b11852e0230bb4c9b174cc03f5c44"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa09b11852e0230bb4c9b174cc03f5c44">PostTheta</a> (int <a class="el" href="#a4def6d3a66d18ebb36f3db4e533626f6">ns</a>, int <a class="el" href="#ac84bd657538bc782335e992055a0817e">nt</a>, int <a class="el" href="#a81228e6fc37955941268fbbb7d019b86">nss</a>, int <a class="el" href="#a90f7a7de632412bd9017e33a594105f4">nb</a>, int <a class="el" href="#aec066996693ada57084aa1ee52f04948">no</a>, SpMat <a class="el" href="#a87a3adb6b92056e8dacea22fa894300a">Ax</a>, Vect <a class="el" href="#a762b11a93e586f00ded70b7776e075ad">y</a>, SpMat <a class="el" href="#a71833a89a8c3dc58117eb467feac7674">c0</a>, SpMat <a class="el" href="#ade2defef59b9295d794620fefb7c8b05">g1</a>, SpMat <a class="el" href="#ae1be0d6e322a26924b67b6258cf55b08">g2</a>, SpMat <a class="el" href="#ac59ad0f384dc3d3f73c6f340aaac2996">g3</a>, SpMat <a class="el" href="#a06391c3ed3d8368da520d465cc909bc0">M0</a>, SpMat <a class="el" href="#af97e49a98f2a9f390abb52cdaf998577">M1</a>, SpMat <a class="el" href="#a93e3e540d2f3d3cd343f9a66867ec03a">M2</a>, Vect <a class="el" href="#a4c8a5c414b883fbc1b9566d38fa27f2d">theta_prior_param</a>, Vect mu_initial, string <a class="el" href="#ae3a7060408a27de614cc1cc8c8bdbd7c">likelihood</a>, Vect extraCoeffVecLik, string solver_type, int dim_spatial_domain, string <a class="el" href="#a48f86e8f68bce72ec4f0aed80ebebce7">manifold</a>, const bool <a class="el" href="#adc24faaa8937de8de88dde11fa9020f7">constr</a>, const MatrixXd <a class="el" href="#af80d7b7e847c30706a826a1c6d7c2fc1">Dx</a>, const MatrixXd <a class="el" href="#a5a765bc4a434d2c4926b7c035984dd66">Dxy</a>, const bool validate, const Vect w)</td></tr>
<tr class="memdesc:aa09b11852e0230bb4c9b174cc03f5c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for spatial temporal model w/ add. spatial field  <br /></td></tr>
<tr class="separator:aa09b11852e0230bb4c9b174cc03f5c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c031e4b1773db975d3038ac01b0977" id="r_a42c031e4b1773db975d3038ac01b0977"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42c031e4b1773db975d3038ac01b0977">operator()</a> (Vect &amp;theta, Vect &amp;grad)</td></tr>
<tr class="memdesc:a42c031e4b1773db975d3038ac01b0977"><td class="mdescLeft">&#160;</td><td class="mdescRight">structure required by <a class="el" href="classBFGS.html">BFGS</a> solver, requires : theta, gradient theta  <br /></td></tr>
<tr class="separator:a42c031e4b1773db975d3038ac01b0977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f0a2f1e8653c50fa9d4c3c24469ea06" id="r_a5f0a2f1e8653c50fa9d4c3c24469ea06"><td class="memItemLeft" align="right" valign="top"><a id="a5f0a2f1e8653c50fa9d4c3c24469ea06" name="a5f0a2f1e8653c50fa9d4c3c24469ea06"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>compute_error_bfgs</b> (Vect &amp;theta)</td></tr>
<tr class="separator:a5f0a2f1e8653c50fa9d4c3c24469ea06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a7918139c515f19f4663057ca3e5cc" id="r_a33a7918139c515f19f4663057ca3e5cc"><td class="memItemLeft" align="right" valign="top"><a id="a33a7918139c515f19f4663057ca3e5cc" name="a33a7918139c515f19f4663057ca3e5cc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>computeG</b> (Vect &amp;theta)</td></tr>
<tr class="memdesc:a33a7918139c515f19f4663057ca3e5cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">overwriting G every time, not explicitly listed, better way to do this? needs to be stored after every iteration for smart hessian ... <br  />
 <br /></td></tr>
<tr class="separator:a33a7918139c515f19f4663057ca3e5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc197a1ae82c5265a0a465c4cfa2727" id="r_a4fc197a1ae82c5265a0a465c4cfa2727"><td class="memItemLeft" align="right" valign="top"><a id="a4fc197a1ae82c5265a0a465c4cfa2727" name="a4fc197a1ae82c5265a0a465c4cfa2727"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>get_fct_count</b> ()</td></tr>
<tr class="separator:a4fc197a1ae82c5265a0a465c4cfa2727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2fa35d92ca09dffff938ab6b4efa7d5" id="r_aa2fa35d92ca09dffff938ab6b4efa7d5"><td class="memItemLeft" align="right" valign="top"><a id="aa2fa35d92ca09dffff938ab6b4efa7d5" name="aa2fa35d92ca09dffff938ab6b4efa7d5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>convert_theta2interpret</b> (Vect &amp;theta, Vect &amp;theta_interpret)</td></tr>
<tr class="separator:aa2fa35d92ca09dffff938ab6b4efa7d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc533e9afbd654745585c646ac828180" id="r_afc533e9afbd654745585c646ac828180"><td class="memItemLeft" align="right" valign="top"><a id="afc533e9afbd654745585c646ac828180" name="afc533e9afbd654745585c646ac828180"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>convert_interpret2theta</b> (Vect &amp;theta_interpret, Vect &amp;theta)</td></tr>
<tr class="separator:afc533e9afbd654745585c646ac828180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed82a7d83d895a856f6841b9ef701783" id="r_aed82a7d83d895a856f6841b9ef701783"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed82a7d83d895a856f6841b9ef701783">convert_theta2interpret_spatTemp</a> (double lgamE, double lgamS, double lgamT, double &amp;sigU, double &amp;ranS, double &amp;ranT)</td></tr>
<tr class="memdesc:aed82a7d83d895a856f6841b9ef701783"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert hyperparameters theta from the model parametrisation to the interpretable parametrisation ie. from log(gamma_E, gamma_s, gamma_t) to log(sigma.u, rangeS, rangeT)  <br /></td></tr>
<tr class="separator:aed82a7d83d895a856f6841b9ef701783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fecf779db9e24870fa0c21ac556399e" id="r_a9fecf779db9e24870fa0c21ac556399e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9fecf779db9e24870fa0c21ac556399e">convert_interpret2theta_spatTemp</a> (double sigU, double ranS, double ranT, double &amp;lgamE, double &amp;lgamS, double &amp;lgamT)</td></tr>
<tr class="memdesc:a9fecf779db9e24870fa0c21ac556399e"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert hyperparameters theta from the interpretable parametrisation to the model parametrisation ie. from log(sigma.u, rangeS, rangeT) to log(gamma_E, gamma_s, gamma_t)  <br /></td></tr>
<tr class="separator:a9fecf779db9e24870fa0c21ac556399e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1106be4ac083bf08aa93fd38e7a24764" id="r_a1106be4ac083bf08aa93fd38e7a24764"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1106be4ac083bf08aa93fd38e7a24764">convert_interpret2theta_spat</a> (double lranS, double lsigU, double &amp;lgamS, double &amp;lgamE)</td></tr>
<tr class="memdesc:a1106be4ac083bf08aa93fd38e7a24764"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert hyperparameters theta from the interpretable parametrisation to the model parametrisation ie. from log(rangeS, sigma.u) to log(gamma_s, gamma_E) for spatial model order 2  <br /></td></tr>
<tr class="separator:a1106be4ac083bf08aa93fd38e7a24764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9138a56d91cdca73cc350d3d5011734" id="r_ae9138a56d91cdca73cc350d3d5011734"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9138a56d91cdca73cc350d3d5011734">convert_theta2interpret_spat</a> (double lgamS, double lgamE, double &amp;lranS, double &amp;lsigU)</td></tr>
<tr class="memdesc:ae9138a56d91cdca73cc350d3d5011734"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert hyperparameters theta from the interpretable parametrisation to the model parametrisation ie. from log(rangeS, sigma.u) to log(gamma_s, gamma_E) for spatial model order 2  <br /></td></tr>
<tr class="separator:ae9138a56d91cdca73cc350d3d5011734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67817f8f6c3b54ccdeee1dafd20d124b" id="r_a67817f8f6c3b54ccdeee1dafd20d124b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67817f8f6c3b54ccdeee1dafd20d124b">get_mu</a> (Vect &amp;theta, Vect &amp;mu_)</td></tr>
<tr class="memdesc:a67817f8f6c3b54ccdeee1dafd20d124b"><td class="mdescLeft">&#160;</td><td class="mdescRight">get conditional mean mu for theta &ndash; Gaussian case.  <br /></td></tr>
<tr class="separator:a67817f8f6c3b54ccdeee1dafd20d124b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b59d9c23fb21cf517f281ae48ac970d" id="r_a6b59d9c23fb21cf517f281ae48ac970d"><td class="memItemLeft" align="right" valign="top">Vect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b59d9c23fb21cf517f281ae48ac970d">get_grad</a> ()</td></tr>
<tr class="memdesc:a6b59d9c23fb21cf517f281ae48ac970d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns current gradient of theta.  <br /></td></tr>
<tr class="separator:a6b59d9c23fb21cf517f281ae48ac970d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae43d9b25fd1205b316ded5dbf3460aff" id="r_ae43d9b25fd1205b316ded5dbf3460aff"><td class="memItemLeft" align="right" valign="top"><a id="ae43d9b25fd1205b316ded5dbf3460aff" name="ae43d9b25fd1205b316ded5dbf3460aff"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>get_Qprior</b> (Vect theta, SpMat &amp;Qprior)</td></tr>
<tr class="separator:ae43d9b25fd1205b316ded5dbf3460aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8824cb165bee60e50b66f0b753428ed" id="r_ab8824cb165bee60e50b66f0b753428ed"><td class="memItemLeft" align="right" valign="top">MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8824cb165bee60e50b66f0b753428ed">get_Covariance</a> (Vect theta, double eps)</td></tr>
<tr class="memdesc:ab8824cb165bee60e50b66f0b753428ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute Covariance matrix of hyperparameters theta, at theta.  <br /></td></tr>
<tr class="separator:ab8824cb165bee60e50b66f0b753428ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd17dbee2d4dcfb63778570748f19cb" id="r_a6dd17dbee2d4dcfb63778570748f19cb"><td class="memItemLeft" align="right" valign="top"><a id="a6dd17dbee2d4dcfb63778570748f19cb" name="a6dd17dbee2d4dcfb63778570748f19cb"></a>
MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><b>get_Cov_interpret_param</b> (Vect interpret_theta, double eps)</td></tr>
<tr class="separator:a6dd17dbee2d4dcfb63778570748f19cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52398b5f03001d24a9bd69d02e7c9773" id="r_a52398b5f03001d24a9bd69d02e7c9773"><td class="memItemLeft" align="right" valign="top"><a id="a52398b5f03001d24a9bd69d02e7c9773" name="a52398b5f03001d24a9bd69d02e7c9773"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>f_eval</b> (Vect &amp;theta)</td></tr>
<tr class="separator:a52398b5f03001d24a9bd69d02e7c9773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a304945cc0ac88a80717dfd2f6975a" id="r_a59a304945cc0ac88a80717dfd2f6975a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59a304945cc0ac88a80717dfd2f6975a">get_marginals_f</a> (Vect &amp;theta, Vect &amp;<a class="el" href="#aa6d3402de41235b5226e1e93be4a9dbe">mu</a>, Vect &amp;vars)</td></tr>
<tr class="memdesc:a59a304945cc0ac88a80717dfd2f6975a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the marginal variances of the latent parameters at theta. Using selected inversion procedure.  <br /></td></tr>
<tr class="separator:a59a304945cc0ac88a80717dfd2f6975a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe3237450eed420a2a2bb8217afaa428" id="r_afe3237450eed420a2a2bb8217afaa428"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe3237450eed420a2a2bb8217afaa428">get_fullFact_marginals_f</a> (Vect &amp;theta, SpMat &amp;Qinv)</td></tr>
<tr class="memdesc:afe3237450eed420a2a2bb8217afaa428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the marginal variances of the latent parameters at theta. Using selected inversion procedure.  <br /></td></tr>
<tr class="separator:afe3237450eed420a2a2bb8217afaa428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f3147a4bf4bf830d04b5424818b82c5" id="r_a6f3147a4bf4bf830d04b5424818b82c5"><td class="memItemLeft" align="right" valign="top"><a id="a6f3147a4bf4bf830d04b5424818b82c5" name="a6f3147a4bf4bf830d04b5424818b82c5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>compute_fullInverseQ</b> (Vect &amp;theta, MatrixXd &amp;Qinv)</td></tr>
<tr class="separator:a6f3147a4bf4bf830d04b5424818b82c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3507f9afff34433fbec653cc82e0bee0" id="r_a3507f9afff34433fbec653cc82e0bee0"><td class="memItemLeft" align="right" valign="top">MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3507f9afff34433fbec653cc82e0bee0">hess_eval</a> (Vect theta, double eps)</td></tr>
<tr class="memdesc:a3507f9afff34433fbec653cc82e0bee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the hessian at theta using second order finite difference. Is used be get_Covariance.  <br /></td></tr>
<tr class="separator:a3507f9afff34433fbec653cc82e0bee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7baecb3114570380a458703aaf5f542d" id="r_a7baecb3114570380a458703aaf5f542d"><td class="memItemLeft" align="right" valign="top"><a id="a7baecb3114570380a458703aaf5f542d" name="a7baecb3114570380a458703aaf5f542d"></a>
MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><b>hess_eval_interpret_theta</b> (Vect interpret_theta, double eps)</td></tr>
<tr class="separator:a7baecb3114570380a458703aaf5f542d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240a43fde6a2e26c30275b24f99f5d4e" id="r_a240a43fde6a2e26c30275b24f99f5d4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a240a43fde6a2e26c30275b24f99f5d4e">check_pos_def</a> (MatrixXd &amp;hess)</td></tr>
<tr class="memdesc:a240a43fde6a2e26c30275b24f99f5d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if Hessian positive definite (matrix assumed to be dense &amp; small since dim(theta) small)  <br /></td></tr>
<tr class="separator:a240a43fde6a2e26c30275b24f99f5d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a437a6716c8fe32396f0643f3dba43e5b" id="r_a437a6716c8fe32396f0643f3dba43e5b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a437a6716c8fe32396f0643f3dba43e5b">eval_post_theta</a> (Vect &amp;theta, Vect &amp;<a class="el" href="#aa6d3402de41235b5226e1e93be4a9dbe">mu</a>)</td></tr>
<tr class="memdesc:a437a6716c8fe32396f0643f3dba43e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Core function. Evaluate posterior of theta. mu are latent parameters.  <br /></td></tr>
<tr class="separator:a437a6716c8fe32396f0643f3dba43e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c18f0138b2cce7d71181bf57261bf5" id="r_a97c18f0138b2cce7d71181bf57261bf5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97c18f0138b2cce7d71181bf57261bf5">eval_log_gaussian_prior_hp</a> (Vect &amp;theta_param, Vect &amp;<a class="el" href="#a4c8a5c414b883fbc1b9566d38fa27f2d">theta_prior_param</a>, double &amp;log_prior)</td></tr>
<tr class="memdesc:a97c18f0138b2cce7d71181bf57261bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate log prior of the hyperparameters using original theta value  <br /></td></tr>
<tr class="separator:a97c18f0138b2cce7d71181bf57261bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f7a4987eeb15a84b1af7c784c3b6ff" id="r_a66f7a4987eeb15a84b1af7c784c3b6ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66f7a4987eeb15a84b1af7c784c3b6ff">eval_log_pc_prior_hp</a> (double &amp;log_sum, Vect &amp;lambda, Vect &amp;theta_interpret)</td></tr>
<tr class="memdesc:a66f7a4987eeb15a84b1af7c784c3b6ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate log prior using PC prior  <br /></td></tr>
<tr class="separator:a66f7a4987eeb15a84b1af7c784c3b6ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a1b9ac95394ba1992ed25b4b34e128" id="r_a79a1b9ac95394ba1992ed25b4b34e128"><td class="memItemLeft" align="right" valign="top"><a id="a79a1b9ac95394ba1992ed25b4b34e128" name="a79a1b9ac95394ba1992ed25b4b34e128"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>update_mean_constr</b> (const MatrixXd &amp;D, Vect &amp;e, Vect &amp;sol, MatrixXd &amp;V, MatrixXd &amp;W, MatrixXd &amp;U, Vect &amp;updated_sol)</td></tr>
<tr class="separator:a79a1b9ac95394ba1992ed25b4b34e128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4973d0c8335220faafa3bdb2fcfeb331" id="r_a4973d0c8335220faafa3bdb2fcfeb331"><td class="memItemLeft" align="right" valign="top"><a id="a4973d0c8335220faafa3bdb2fcfeb331" name="a4973d0c8335220faafa3bdb2fcfeb331"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>eval_log_dens_constr</b> (Vect &amp;x, Vect &amp;<a class="el" href="#aa6d3402de41235b5226e1e93be4a9dbe">mu</a>, SpMat &amp;Q, double &amp;log_det_Q, const MatrixXd &amp;D, MatrixXd &amp;W, double &amp;val_log_dens)</td></tr>
<tr class="separator:a4973d0c8335220faafa3bdb2fcfeb331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39be6fb891850dcb5d3042fc20cf9e51" id="r_a39be6fb891850dcb5d3042fc20cf9e51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39be6fb891850dcb5d3042fc20cf9e51">eval_log_prior_lat</a> (Vect &amp;theta, Vect &amp;<a class="el" href="#aa6d3402de41235b5226e1e93be4a9dbe">mu</a>, double &amp;val)</td></tr>
<tr class="memdesc:a39be6fb891850dcb5d3042fc20cf9e51"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate log prior of random effects  <br /></td></tr>
<tr class="separator:a39be6fb891850dcb5d3042fc20cf9e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae938a9d6de15e0512300f8ce00d8ffea" id="r_ae938a9d6de15e0512300f8ce00d8ffea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae938a9d6de15e0512300f8ce00d8ffea">eval_likelihood</a> (Vect &amp;theta, Vect &amp;<a class="el" href="#aa6d3402de41235b5226e1e93be4a9dbe">mu</a>, double &amp;log_det, double &amp;val)</td></tr>
<tr class="memdesc:ae938a9d6de15e0512300f8ce00d8ffea"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute log likelihood : log_det tau*no and value -theta*yTy  <br /></td></tr>
<tr class="separator:ae938a9d6de15e0512300f8ce00d8ffea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ceec7e512bf71ca7267f01733ec8719" id="r_a2ceec7e512bf71ca7267f01733ec8719"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ceec7e512bf71ca7267f01733ec8719">construct_Q_spatial</a> (Vect &amp;theta, SpMat &amp;Qs)</td></tr>
<tr class="memdesc:a2ceec7e512bf71ca7267f01733ec8719"><td class="mdescLeft">&#160;</td><td class="mdescRight">spatial model : SPDE discretisation &ndash; matrix construction  <br /></td></tr>
<tr class="separator:a2ceec7e512bf71ca7267f01733ec8719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41faf4a6b8b2a30168f35805c2c7b3f" id="r_ac41faf4a6b8b2a30168f35805c2c7b3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac41faf4a6b8b2a30168f35805c2c7b3f">construct_Q_spat_temp</a> (Vect &amp;theta, SpMat &amp;Qst)</td></tr>
<tr class="memdesc:ac41faf4a6b8b2a30168f35805c2c7b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">spatial temporal model : SPDE discretisation. DEMF(1,2,1) model.  <br /></td></tr>
<tr class="separator:ac41faf4a6b8b2a30168f35805c2c7b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0997791c5ca3fe1423ef6d0e6e2c4c96" id="r_a0997791c5ca3fe1423ef6d0e6e2c4c96"><td class="memItemLeft" align="right" valign="top"><a id="a0997791c5ca3fe1423ef6d0e6e2c4c96" name="a0997791c5ca3fe1423ef6d0e6e2c4c96"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>construct_Qprior</b> (Vect &amp;theta, SpMat &amp;<a class="el" href="#a6309a79e5c90152408aa04e0bb6cc722">Qx</a>)</td></tr>
<tr class="separator:a0997791c5ca3fe1423ef6d0e6e2c4c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d95efb35ba09080558cb9817deed67" id="r_a75d95efb35ba09080558cb9817deed67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75d95efb35ba09080558cb9817deed67">construct_Q</a> (Vect &amp;theta, Vect &amp;<a class="el" href="#aa6d3402de41235b5226e1e93be4a9dbe">mu</a>, SpMat &amp;Q)</td></tr>
<tr class="memdesc:a75d95efb35ba09080558cb9817deed67"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct precision matrix. Calls spatial, spatial-temporal, etc.  <br /></td></tr>
<tr class="separator:a75d95efb35ba09080558cb9817deed67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69559f2f98cbdd4b844a9e0c571d64d" id="r_af69559f2f98cbdd4b844a9e0c571d64d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af69559f2f98cbdd4b844a9e0c571d64d">construct_b</a> (Vect &amp;theta, Vect &amp;rhs)</td></tr>
<tr class="memdesc:af69559f2f98cbdd4b844a9e0c571d64d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble right-handside.  <br /></td></tr>
<tr class="separator:af69559f2f98cbdd4b844a9e0c571d64d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af7519622a314b59a75f5b84f15ad9a" id="r_a5af7519622a314b59a75f5b84f15ad9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5af7519622a314b59a75f5b84f15ad9a">eval_denominator</a> (Vect &amp;theta, double &amp;val, SpMat &amp;Q, Vect &amp;rhs, Vect &amp;<a class="el" href="#aa6d3402de41235b5226e1e93be4a9dbe">mu</a>)</td></tr>
<tr class="memdesc:a5af7519622a314b59a75f5b84f15ad9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate denominator: conditional probability of Qx|y.  <br /></td></tr>
<tr class="separator:a5af7519622a314b59a75f5b84f15ad9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab609440015d89151088d88d22743a9" id="r_acab609440015d89151088d88d22743a9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acab609440015d89151088d88d22743a9">cond_LogPriorLat</a> (SpMat &amp;Qprior, Vect &amp;x)</td></tr>
<tr class="memdesc:acab609440015d89151088d88d22743a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate Gaussian log prior (without log determinant!!), mean assumed to be zero  <br /></td></tr>
<tr class="separator:acab609440015d89151088d88d22743a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ccd433b0980957378ce768d1edd1fa" id="r_af4ccd433b0980957378ce768d1edd1fa"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4ccd433b0980957378ce768d1edd1fa">cond_LogPoisLik</a> (Vect &amp;eta)</td></tr>
<tr class="memdesc:af4ccd433b0980957378ce768d1edd1fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate log Poisson likelihood  <br /></td></tr>
<tr class="separator:af4ccd433b0980957378ce768d1edd1fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebfe9fe1b43f43755e663c10b539b4df" id="r_aebfe9fe1b43f43755e663c10b539b4df"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebfe9fe1b43f43755e663c10b539b4df">cond_negLogPoisLik</a> (Vect &amp;eta)</td></tr>
<tr class="memdesc:aebfe9fe1b43f43755e663c10b539b4df"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate negative log Poisson likelihood  <br /></td></tr>
<tr class="separator:aebfe9fe1b43f43755e663c10b539b4df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9869ed1f62b2833100e38412658fdd64" id="r_a9869ed1f62b2833100e38412658fdd64"><td class="memItemLeft" align="right" valign="top">Vect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9869ed1f62b2833100e38412658fdd64">grad_cond_negLogPoisLik</a> (Vect &amp;eta)</td></tr>
<tr class="memdesc:a9869ed1f62b2833100e38412658fdd64"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate analytical negative gradient log Poisson likelihood  <br /></td></tr>
<tr class="separator:a9869ed1f62b2833100e38412658fdd64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada8322161a4b456296baa49a3b02c159" id="r_ada8322161a4b456296baa49a3b02c159"><td class="memItemLeft" align="right" valign="top">Vect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada8322161a4b456296baa49a3b02c159">diagHess_cond_negLogPoisLik</a> (Vect &amp;eta)</td></tr>
<tr class="memdesc:ada8322161a4b456296baa49a3b02c159"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate analytical negative diagonal Hessian of log Poisson likelihood  <br /></td></tr>
<tr class="separator:ada8322161a4b456296baa49a3b02c159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f55646f57619e97c20489ec846c984f" id="r_a4f55646f57619e97c20489ec846c984f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f55646f57619e97c20489ec846c984f">cond_negLogPois</a> (SpMat &amp;Qprior, Vect &amp;x)</td></tr>
<tr class="memdesc:a4f55646f57619e97c20489ec846c984f"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate negative condiational log Poisson + Gaussian prior  <br /></td></tr>
<tr class="separator:a4f55646f57619e97c20489ec846c984f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b31d37c9d4ac9caffc332132b39e80" id="r_a25b31d37c9d4ac9caffc332132b39e80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25b31d37c9d4ac9caffc332132b39e80">link_f_sigmoid</a> (Vect &amp;x, Vect &amp;sigmoidX)</td></tr>
<tr class="memdesc:a25b31d37c9d4ac9caffc332132b39e80"><td class="mdescLeft">&#160;</td><td class="mdescRight">link function. vectorized evaluation of sigmoid function for each entry  <br /></td></tr>
<tr class="separator:a25b31d37c9d4ac9caffc332132b39e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8164624f557686c53b8710370f8e284" id="r_ae8164624f557686c53b8710370f8e284"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8164624f557686c53b8710370f8e284">cond_negLogBinomLik</a> (Vect &amp;eta)</td></tr>
<tr class="memdesc:ae8164624f557686c53b8710370f8e284"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate negative log Binomial likelihood  <br /></td></tr>
<tr class="separator:ae8164624f557686c53b8710370f8e284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae16e0d7a8f7be90183994aa20bead02" id="r_aae16e0d7a8f7be90183994aa20bead02"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae16e0d7a8f7be90183994aa20bead02">cond_negLogBinom</a> (SpMat &amp;Qprior, Vect &amp;x)</td></tr>
<tr class="memdesc:aae16e0d7a8f7be90183994aa20bead02"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate negative condiational log Poisson + Gaussian prior  <br /></td></tr>
<tr class="separator:aae16e0d7a8f7be90183994aa20bead02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e1701ddb453651f4cfb4cb55090212" id="r_ad7e1701ddb453651f4cfb4cb55090212"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad7e1701ddb453651f4cfb4cb55090212">cond_negLogDist</a> (SpMat &amp;Qprior, Vect &amp;x, function&lt; double(Vect &amp;, Vect &amp;)&gt; lik_func)</td></tr>
<tr class="memdesc:ad7e1701ddb453651f4cfb4cb55090212"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate negative condiational log likelihood + Gaussian prior  <br /></td></tr>
<tr class="separator:ad7e1701ddb453651f4cfb4cb55090212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7787133900ea7bed116af5ea6cf46d91" id="r_a7787133900ea7bed116af5ea6cf46d91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7787133900ea7bed116af5ea6cf46d91">FD_gradient</a> (Vect &amp;eta, Vect &amp;grad)</td></tr>
<tr class="memdesc:a7787133900ea7bed116af5ea6cf46d91"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute finite difference gradient. 1st order central difference. currently stepsize h fixed.  <br /></td></tr>
<tr class="separator:a7787133900ea7bed116af5ea6cf46d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94652237d86e5b575f65b7bdaf97b02e" id="r_a94652237d86e5b575f65b7bdaf97b02e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94652237d86e5b575f65b7bdaf97b02e">FD_diag_hessian</a> (Vect &amp;eta, Vect &amp;diag_hess)</td></tr>
<tr class="memdesc:a94652237d86e5b575f65b7bdaf97b02e"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute finite difference diagonal of hessian. 2nd order central difference. currently stepsize h fixed.  <br /></td></tr>
<tr class="separator:a94652237d86e5b575f65b7bdaf97b02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add8b0bea25da71ca6071a3a3fc2fa1ea" id="r_add8b0bea25da71ca6071a3a3fc2fa1ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add8b0bea25da71ca6071a3a3fc2fa1ea">NewtonIter</a> (Vect &amp;theta, Vect &amp;x, SpMat &amp;Q, double &amp;log_det)</td></tr>
<tr class="memdesc:add8b0bea25da71ca6071a3a3fc2fa1ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Newton iteration to find optimum of conditional distribution latent parameters of prior &amp; likelihood.  <br /></td></tr>
<tr class="separator:add8b0bea25da71ca6071a3a3fc2fa1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f05821cf3af095b3a9fa66919266bf" id="r_a29f05821cf3af095b3a9fa66919266bf"><td class="memItemLeft" align="right" valign="top"><a id="a29f05821cf3af095b3a9fa66919266bf" name="a29f05821cf3af095b3a9fa66919266bf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>record_times</b> (std::string file_name, int <a class="el" href="#a6f35b1d4e2eb881fd0b8513571874bc0">iter_count</a>, double t_Ftheta_ext, double t_thread_nom, double t_priorHyp, double t_priorLat, double t_priorLatAMat, double t_priorLatChol, double t_likel, double t_thread_denom, double t_condLat, double t_condLatAMat, double t_condLatChol, double t_condLatSolve)</td></tr>
<tr class="separator:a29f05821cf3af095b3a9fa66919266bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d5640ff12bb9e2828559153c61f352" id="r_a72d5640ff12bb9e2828559153c61f352"><td class="memItemLeft" align="right" valign="top"><a id="a72d5640ff12bb9e2828559153c61f352" name="a72d5640ff12bb9e2828559153c61f352"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~PostTheta</b> ()</td></tr>
<tr class="memdesc:a72d5640ff12bb9e2828559153c61f352"><td class="mdescLeft">&#160;</td><td class="mdescRight">class destructor. Frees memory allocated by <a class="el" href="classPostTheta.html" title="Computes the Posterior of the hyperparameters theta.">PostTheta</a> class. <br /></td></tr>
<tr class="separator:a72d5640ff12bb9e2828559153c61f352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56db4c858de1c0dc0721bf19e60c493c" id="r_a56db4c858de1c0dc0721bf19e60c493c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56db4c858de1c0dc0721bf19e60c493c">PostTheta</a> (int <a class="el" href="#a4def6d3a66d18ebb36f3db4e533626f6">ns</a>, int <a class="el" href="#ac84bd657538bc782335e992055a0817e">nt</a>, int <a class="el" href="#a90f7a7de632412bd9017e33a594105f4">nb</a>, int <a class="el" href="#aec066996693ada57084aa1ee52f04948">no</a>, MatrixXd <a class="el" href="#acc70e6f2659235075873ecee40a126cf">B</a>, Vect <a class="el" href="#a762b11a93e586f00ded70b7776e075ad">y</a>, Vect theta_prior, string solver_type, const bool <a class="el" href="#adc24faaa8937de8de88dde11fa9020f7">constr</a>, const MatrixXd <a class="el" href="#a5a765bc4a434d2c4926b7c035984dd66">Dxy</a>, const bool validate, const Vect w)</td></tr>
<tr class="memdesc:a56db4c858de1c0dc0721bf19e60c493c"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for regression model (no random effects).  <br /></td></tr>
<tr class="separator:a56db4c858de1c0dc0721bf19e60c493c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff16e221ec1a93e07d27553fb817c6d" id="r_a4ff16e221ec1a93e07d27553fb817c6d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ff16e221ec1a93e07d27553fb817c6d">PostTheta</a> (int <a class="el" href="#a4def6d3a66d18ebb36f3db4e533626f6">ns</a>, int <a class="el" href="#ac84bd657538bc782335e992055a0817e">nt</a>, int <a class="el" href="#a90f7a7de632412bd9017e33a594105f4">nb</a>, int <a class="el" href="#aec066996693ada57084aa1ee52f04948">no</a>, SpMat <a class="el" href="#a87a3adb6b92056e8dacea22fa894300a">Ax</a>, Vect <a class="el" href="#a762b11a93e586f00ded70b7776e075ad">y</a>, SpMat <a class="el" href="#a71833a89a8c3dc58117eb467feac7674">c0</a>, SpMat <a class="el" href="#ade2defef59b9295d794620fefb7c8b05">g1</a>, SpMat <a class="el" href="#ae1be0d6e322a26924b67b6258cf55b08">g2</a>, Vect theta_prior, string solver_type, const bool <a class="el" href="#adc24faaa8937de8de88dde11fa9020f7">constr</a>, const MatrixXd <a class="el" href="#af80d7b7e847c30706a826a1c6d7c2fc1">Dx</a>, const MatrixXd <a class="el" href="#a5a765bc4a434d2c4926b7c035984dd66">Dxy</a>, const bool validate, const Vect w)</td></tr>
<tr class="memdesc:a4ff16e221ec1a93e07d27553fb817c6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for spatial model (order 2).  <br /></td></tr>
<tr class="separator:a4ff16e221ec1a93e07d27553fb817c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35269dd8407ce1c126a4b87a31b7a310" id="r_a35269dd8407ce1c126a4b87a31b7a310"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35269dd8407ce1c126a4b87a31b7a310">PostTheta</a> (int <a class="el" href="#a4def6d3a66d18ebb36f3db4e533626f6">ns</a>, int <a class="el" href="#ac84bd657538bc782335e992055a0817e">nt</a>, int <a class="el" href="#a90f7a7de632412bd9017e33a594105f4">nb</a>, int <a class="el" href="#aec066996693ada57084aa1ee52f04948">no</a>, SpMat <a class="el" href="#a87a3adb6b92056e8dacea22fa894300a">Ax</a>, Vect <a class="el" href="#a762b11a93e586f00ded70b7776e075ad">y</a>, SpMat <a class="el" href="#a71833a89a8c3dc58117eb467feac7674">c0</a>, SpMat <a class="el" href="#ade2defef59b9295d794620fefb7c8b05">g1</a>, SpMat <a class="el" href="#ae1be0d6e322a26924b67b6258cf55b08">g2</a>, SpMat <a class="el" href="#ac59ad0f384dc3d3f73c6f340aaac2996">g3</a>, SpMat <a class="el" href="#a06391c3ed3d8368da520d465cc909bc0">M0</a>, SpMat <a class="el" href="#af97e49a98f2a9f390abb52cdaf998577">M1</a>, SpMat <a class="el" href="#a93e3e540d2f3d3cd343f9a66867ec03a">M2</a>, Vect theta_prior, string solver_type, const bool <a class="el" href="#adc24faaa8937de8de88dde11fa9020f7">constr</a>, const MatrixXd <a class="el" href="#af80d7b7e847c30706a826a1c6d7c2fc1">Dx</a>, const MatrixXd <a class="el" href="#a5a765bc4a434d2c4926b7c035984dd66">Dxy</a>, const bool validate, const Vect w)</td></tr>
<tr class="memdesc:a35269dd8407ce1c126a4b87a31b7a310"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for spatial temporal model.  <br /></td></tr>
<tr class="separator:a35269dd8407ce1c126a4b87a31b7a310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c031e4b1773db975d3038ac01b0977" id="r_a42c031e4b1773db975d3038ac01b0977"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42c031e4b1773db975d3038ac01b0977">operator()</a> (Vect &amp;theta, Vect &amp;grad)</td></tr>
<tr class="memdesc:a42c031e4b1773db975d3038ac01b0977"><td class="mdescLeft">&#160;</td><td class="mdescRight">structure required by <a class="el" href="classBFGS.html">BFGS</a> solver, requires : theta, gradient theta  <br /></td></tr>
<tr class="separator:a42c031e4b1773db975d3038ac01b0977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a7918139c515f19f4663057ca3e5cc" id="r_a33a7918139c515f19f4663057ca3e5cc"><td class="memItemLeft" align="right" valign="top"><a id="a33a7918139c515f19f4663057ca3e5cc" name="a33a7918139c515f19f4663057ca3e5cc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>computeG</b> (Vect &amp;theta)</td></tr>
<tr class="memdesc:a33a7918139c515f19f4663057ca3e5cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">overwriting G every time, not explicitly listed, better way to do this? needs to be stored after every iteration for smart hessian ... <br  />
 <br /></td></tr>
<tr class="separator:a33a7918139c515f19f4663057ca3e5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc197a1ae82c5265a0a465c4cfa2727" id="r_a4fc197a1ae82c5265a0a465c4cfa2727"><td class="memItemLeft" align="right" valign="top"><a id="a4fc197a1ae82c5265a0a465c4cfa2727" name="a4fc197a1ae82c5265a0a465c4cfa2727"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>get_fct_count</b> ()</td></tr>
<tr class="separator:a4fc197a1ae82c5265a0a465c4cfa2727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfdc66118e93525b7814f53c6b50e652" id="r_adfdc66118e93525b7814f53c6b50e652"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfdc66118e93525b7814f53c6b50e652">convert_theta2interpret</a> (double lgamE, double lgamS, double lgamT, double &amp;sigU, double &amp;ranS, double &amp;ranT)</td></tr>
<tr class="memdesc:adfdc66118e93525b7814f53c6b50e652"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert hyperparameters theta from the model parametrisation to the interpretable parametrisation ie. from log(gamma_E, gamma_s, gamma_t) to log(sigma.u, rangeS, rangeT)  <br /></td></tr>
<tr class="separator:adfdc66118e93525b7814f53c6b50e652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada9c36637820d3eaad19d4b3449c98ad" id="r_ada9c36637820d3eaad19d4b3449c98ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada9c36637820d3eaad19d4b3449c98ad">convert_interpret2theta</a> (double sigU, double ranS, double ranT, double &amp;lgamE, double &amp;lgamS, double &amp;lgamT)</td></tr>
<tr class="memdesc:ada9c36637820d3eaad19d4b3449c98ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert hyperparameters theta from the interpretable parametrisation to the model parametrisation ie. from log(sigma.u, rangeS, rangeT) to log(gamma_E, gamma_s, gamma_t)  <br /></td></tr>
<tr class="separator:ada9c36637820d3eaad19d4b3449c98ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ffad9798426544c91b1f3420e9c8c9" id="r_ac6ffad9798426544c91b1f3420e9c8c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6ffad9798426544c91b1f3420e9c8c9">get_mu</a> (Vect &amp;theta, Vect &amp;<a class="el" href="#aa6d3402de41235b5226e1e93be4a9dbe">mu</a>, ArrayXi &amp;fact_to_rank_list)</td></tr>
<tr class="memdesc:ac6ffad9798426544c91b1f3420e9c8c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">get conditional mean mu for theta.  <br /></td></tr>
<tr class="separator:ac6ffad9798426544c91b1f3420e9c8c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b59d9c23fb21cf517f281ae48ac970d" id="r_a6b59d9c23fb21cf517f281ae48ac970d"><td class="memItemLeft" align="right" valign="top">Vect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b59d9c23fb21cf517f281ae48ac970d">get_grad</a> ()</td></tr>
<tr class="memdesc:a6b59d9c23fb21cf517f281ae48ac970d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns current gradient of theta.  <br /></td></tr>
<tr class="separator:a6b59d9c23fb21cf517f281ae48ac970d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb8efdc44447d6224893f6debf29540" id="r_a9eb8efdc44447d6224893f6debf29540"><td class="memItemLeft" align="right" valign="top">MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9eb8efdc44447d6224893f6debf29540">get_Covariance</a> (Vect &amp;theta, double eps)</td></tr>
<tr class="memdesc:a9eb8efdc44447d6224893f6debf29540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute Covariance matrix of hyperparameters theta, at theta.  <br /></td></tr>
<tr class="separator:a9eb8efdc44447d6224893f6debf29540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2589db16c7d4784189d003016d99cf89" id="r_a2589db16c7d4784189d003016d99cf89"><td class="memItemLeft" align="right" valign="top"><a id="a2589db16c7d4784189d003016d99cf89" name="a2589db16c7d4784189d003016d99cf89"></a>
MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><b>get_Cov_interpret_param</b> (Vect &amp;interpret_theta, double eps)</td></tr>
<tr class="separator:a2589db16c7d4784189d003016d99cf89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52398b5f03001d24a9bd69d02e7c9773" id="r_a52398b5f03001d24a9bd69d02e7c9773"><td class="memItemLeft" align="right" valign="top"><a id="a52398b5f03001d24a9bd69d02e7c9773" name="a52398b5f03001d24a9bd69d02e7c9773"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>f_eval</b> (Vect &amp;theta)</td></tr>
<tr class="separator:a52398b5f03001d24a9bd69d02e7c9773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f0a2f1e8653c50fa9d4c3c24469ea06" id="r_a5f0a2f1e8653c50fa9d4c3c24469ea06"><td class="memItemLeft" align="right" valign="top"><a id="a5f0a2f1e8653c50fa9d4c3c24469ea06" name="a5f0a2f1e8653c50fa9d4c3c24469ea06"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>compute_error_bfgs</b> (Vect &amp;theta)</td></tr>
<tr class="separator:a5f0a2f1e8653c50fa9d4c3c24469ea06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d01ba1dcfedc1e9b250586c0f6ab98" id="r_ab6d01ba1dcfedc1e9b250586c0f6ab98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6d01ba1dcfedc1e9b250586c0f6ab98">get_marginals_f</a> (Vect &amp;theta, Vect &amp;vars)</td></tr>
<tr class="memdesc:ab6d01ba1dcfedc1e9b250586c0f6ab98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the marginal variances of the latent parameters at theta. Using selected inversion procedure.  <br /></td></tr>
<tr class="separator:ab6d01ba1dcfedc1e9b250586c0f6ab98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba126f6b1bc95b8815465debaedd650" id="r_a8ba126f6b1bc95b8815465debaedd650"><td class="memItemLeft" align="right" valign="top">MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ba126f6b1bc95b8815465debaedd650">hess_eval</a> (Vect &amp;theta, double eps)</td></tr>
<tr class="memdesc:a8ba126f6b1bc95b8815465debaedd650"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the hessian at theta using second order finite difference. Is used be get_Covariance.  <br /></td></tr>
<tr class="separator:a8ba126f6b1bc95b8815465debaedd650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67ecf629a6a81db6966614517acfbbb" id="r_ae67ecf629a6a81db6966614517acfbbb"><td class="memItemLeft" align="right" valign="top"><a id="ae67ecf629a6a81db6966614517acfbbb" name="ae67ecf629a6a81db6966614517acfbbb"></a>
MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><b>hess_eval_interpret_theta</b> (Vect &amp;interpret_theta, double eps)</td></tr>
<tr class="separator:ae67ecf629a6a81db6966614517acfbbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240a43fde6a2e26c30275b24f99f5d4e" id="r_a240a43fde6a2e26c30275b24f99f5d4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a240a43fde6a2e26c30275b24f99f5d4e">check_pos_def</a> (MatrixXd &amp;hess)</td></tr>
<tr class="memdesc:a240a43fde6a2e26c30275b24f99f5d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if Hessian positive definite (matrix assumed to be dense &amp; small since dim(theta) small)  <br /></td></tr>
<tr class="separator:a240a43fde6a2e26c30275b24f99f5d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a3133494a5479b3f1f8a557e9490a35" id="r_a6a3133494a5479b3f1f8a557e9490a35"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a3133494a5479b3f1f8a557e9490a35">eval_post_theta</a> (Vect &amp;theta, Vect &amp;<a class="el" href="#aa6d3402de41235b5226e1e93be4a9dbe">mu</a>, ArrayXi &amp;fact_to_rank_list)</td></tr>
<tr class="memdesc:a6a3133494a5479b3f1f8a557e9490a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Core function. Evaluate posterior of theta. mu are latent parameters.  <br /></td></tr>
<tr class="separator:a6a3133494a5479b3f1f8a557e9490a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52137ac2ce65806e9b9e99177adecd33" id="r_a52137ac2ce65806e9b9e99177adecd33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52137ac2ce65806e9b9e99177adecd33">eval_log_gaussian_prior_hp</a> (double &amp;log_prior, double *thetai, double *thetai_original)</td></tr>
<tr class="memdesc:a52137ac2ce65806e9b9e99177adecd33"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate log prior of the hyperparameters using original theta value  <br /></td></tr>
<tr class="separator:a52137ac2ce65806e9b9e99177adecd33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f7a4987eeb15a84b1af7c784c3b6ff" id="r_a66f7a4987eeb15a84b1af7c784c3b6ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66f7a4987eeb15a84b1af7c784c3b6ff">eval_log_pc_prior_hp</a> (double &amp;log_sum, Vect &amp;lambda, Vect &amp;theta_interpret)</td></tr>
<tr class="memdesc:a66f7a4987eeb15a84b1af7c784c3b6ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate log prior using PC prior  <br /></td></tr>
<tr class="separator:a66f7a4987eeb15a84b1af7c784c3b6ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a1b9ac95394ba1992ed25b4b34e128" id="r_a79a1b9ac95394ba1992ed25b4b34e128"><td class="memItemLeft" align="right" valign="top"><a id="a79a1b9ac95394ba1992ed25b4b34e128" name="a79a1b9ac95394ba1992ed25b4b34e128"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>update_mean_constr</b> (const MatrixXd &amp;D, Vect &amp;e, Vect &amp;sol, MatrixXd &amp;V, MatrixXd &amp;W, MatrixXd &amp;U, Vect &amp;updated_sol)</td></tr>
<tr class="separator:a79a1b9ac95394ba1992ed25b4b34e128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4973d0c8335220faafa3bdb2fcfeb331" id="r_a4973d0c8335220faafa3bdb2fcfeb331"><td class="memItemLeft" align="right" valign="top"><a id="a4973d0c8335220faafa3bdb2fcfeb331" name="a4973d0c8335220faafa3bdb2fcfeb331"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>eval_log_dens_constr</b> (Vect &amp;x, Vect &amp;<a class="el" href="#aa6d3402de41235b5226e1e93be4a9dbe">mu</a>, SpMat &amp;Q, double &amp;log_det_Q, const MatrixXd &amp;D, MatrixXd &amp;W, double &amp;val_log_dens)</td></tr>
<tr class="separator:a4973d0c8335220faafa3bdb2fcfeb331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a981439fd52c6b46c1666fd45eb5faa92" id="r_a981439fd52c6b46c1666fd45eb5faa92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a981439fd52c6b46c1666fd45eb5faa92">eval_log_prior_lat</a> (Vect &amp;theta, double &amp;val)</td></tr>
<tr class="memdesc:a981439fd52c6b46c1666fd45eb5faa92"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate log prior of random effects  <br /></td></tr>
<tr class="separator:a981439fd52c6b46c1666fd45eb5faa92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97173a441c0f2f6b9dc2a5fe85e1d6ad" id="r_a97173a441c0f2f6b9dc2a5fe85e1d6ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97173a441c0f2f6b9dc2a5fe85e1d6ad">eval_likelihood</a> (Vect &amp;theta, double &amp;log_det, double &amp;val)</td></tr>
<tr class="memdesc:a97173a441c0f2f6b9dc2a5fe85e1d6ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute log likelihood : log_det tau*no and value -theta*yTy  <br /></td></tr>
<tr class="separator:a97173a441c0f2f6b9dc2a5fe85e1d6ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ceec7e512bf71ca7267f01733ec8719" id="r_a2ceec7e512bf71ca7267f01733ec8719"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ceec7e512bf71ca7267f01733ec8719">construct_Q_spatial</a> (Vect &amp;theta, SpMat &amp;Qs)</td></tr>
<tr class="memdesc:a2ceec7e512bf71ca7267f01733ec8719"><td class="mdescLeft">&#160;</td><td class="mdescRight">spatial model : SPDE discretisation &ndash; matrix construction  <br /></td></tr>
<tr class="separator:a2ceec7e512bf71ca7267f01733ec8719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41faf4a6b8b2a30168f35805c2c7b3f" id="r_ac41faf4a6b8b2a30168f35805c2c7b3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac41faf4a6b8b2a30168f35805c2c7b3f">construct_Q_spat_temp</a> (Vect &amp;theta, SpMat &amp;Qst)</td></tr>
<tr class="memdesc:ac41faf4a6b8b2a30168f35805c2c7b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">spatial temporal model : SPDE discretisation. DEMF(1,2,1) model.  <br /></td></tr>
<tr class="separator:ac41faf4a6b8b2a30168f35805c2c7b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb642337f6f4db477be2318bb9796f2c" id="r_acb642337f6f4db477be2318bb9796f2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb642337f6f4db477be2318bb9796f2c">construct_Q</a> (Vect &amp;theta, SpMat &amp;Q)</td></tr>
<tr class="memdesc:acb642337f6f4db477be2318bb9796f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct precision matrix. Calls spatial, spatial-temporal, etc.  <br /></td></tr>
<tr class="separator:acb642337f6f4db477be2318bb9796f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69559f2f98cbdd4b844a9e0c571d64d" id="r_af69559f2f98cbdd4b844a9e0c571d64d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af69559f2f98cbdd4b844a9e0c571d64d">construct_b</a> (Vect &amp;theta, Vect &amp;rhs)</td></tr>
<tr class="memdesc:af69559f2f98cbdd4b844a9e0c571d64d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble right-handside.  <br /></td></tr>
<tr class="separator:af69559f2f98cbdd4b844a9e0c571d64d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7bf017b26af54eb68645b49a2c99fcb" id="r_ae7bf017b26af54eb68645b49a2c99fcb"><td class="memItemLeft" align="right" valign="top"><a id="ae7bf017b26af54eb68645b49a2c99fcb" name="ae7bf017b26af54eb68645b49a2c99fcb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>update_mean_constr</b> (MatrixXd &amp;D, Vect &amp;e, Vect &amp;sol, MatrixXd &amp;V, MatrixXd &amp;W)</td></tr>
<tr class="separator:ae7bf017b26af54eb68645b49a2c99fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af7519622a314b59a75f5b84f15ad9a" id="r_a5af7519622a314b59a75f5b84f15ad9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5af7519622a314b59a75f5b84f15ad9a">eval_denominator</a> (Vect &amp;theta, double &amp;val, SpMat &amp;Q, Vect &amp;rhs, Vect &amp;<a class="el" href="#aa6d3402de41235b5226e1e93be4a9dbe">mu</a>)</td></tr>
<tr class="memdesc:a5af7519622a314b59a75f5b84f15ad9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate denominator: conditional probability of Qx|y.  <br /></td></tr>
<tr class="separator:a5af7519622a314b59a75f5b84f15ad9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d7a18584db9aace5d217437bdfe84fa" id="r_a3d7a18584db9aace5d217437bdfe84fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d7a18584db9aace5d217437bdfe84fa">eval_gradient</a> (Vect &amp;theta, double f_theta, Vect &amp;<a class="el" href="#aa6d3402de41235b5226e1e93be4a9dbe">mu</a>, Vect &amp;grad)</td></tr>
<tr class="memdesc:a3d7a18584db9aace5d217437bdfe84fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute gradient using central finite difference stencil. Parallelised with OpenMP.  <br /></td></tr>
<tr class="separator:a3d7a18584db9aace5d217437bdfe84fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f05821cf3af095b3a9fa66919266bf" id="r_a29f05821cf3af095b3a9fa66919266bf"><td class="memItemLeft" align="right" valign="top"><a id="a29f05821cf3af095b3a9fa66919266bf" name="a29f05821cf3af095b3a9fa66919266bf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>record_times</b> (std::string file_name, int <a class="el" href="#a6f35b1d4e2eb881fd0b8513571874bc0">iter_count</a>, double t_Ftheta_ext, double t_thread_nom, double t_priorHyp, double t_priorLat, double t_priorLatAMat, double t_priorLatChol, double t_likel, double t_thread_denom, double t_condLat, double t_condLatAMat, double t_condLatChol, double t_condLatSolve)</td></tr>
<tr class="separator:a29f05821cf3af095b3a9fa66919266bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d5640ff12bb9e2828559153c61f352" id="r_a72d5640ff12bb9e2828559153c61f352"><td class="memItemLeft" align="right" valign="top"><a id="a72d5640ff12bb9e2828559153c61f352" name="a72d5640ff12bb9e2828559153c61f352"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~PostTheta</b> ()</td></tr>
<tr class="memdesc:a72d5640ff12bb9e2828559153c61f352"><td class="mdescLeft">&#160;</td><td class="mdescRight">class destructor. Frees memory allocated by <a class="el" href="classPostTheta.html" title="Computes the Posterior of the hyperparameters theta.">PostTheta</a> class. <br /></td></tr>
<tr class="separator:a72d5640ff12bb9e2828559153c61f352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56db4c858de1c0dc0721bf19e60c493c" id="r_a56db4c858de1c0dc0721bf19e60c493c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56db4c858de1c0dc0721bf19e60c493c">PostTheta</a> (int <a class="el" href="#a4def6d3a66d18ebb36f3db4e533626f6">ns</a>, int <a class="el" href="#ac84bd657538bc782335e992055a0817e">nt</a>, int <a class="el" href="#a90f7a7de632412bd9017e33a594105f4">nb</a>, int <a class="el" href="#aec066996693ada57084aa1ee52f04948">no</a>, MatrixXd <a class="el" href="#acc70e6f2659235075873ecee40a126cf">B</a>, Vect <a class="el" href="#a762b11a93e586f00ded70b7776e075ad">y</a>, Vect theta_prior, string solver_type, const bool <a class="el" href="#adc24faaa8937de8de88dde11fa9020f7">constr</a>, const MatrixXd <a class="el" href="#a5a765bc4a434d2c4926b7c035984dd66">Dxy</a>, const bool validate, const Vect w)</td></tr>
<tr class="memdesc:a56db4c858de1c0dc0721bf19e60c493c"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for regression model (no random effects).  <br /></td></tr>
<tr class="separator:a56db4c858de1c0dc0721bf19e60c493c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff16e221ec1a93e07d27553fb817c6d" id="r_a4ff16e221ec1a93e07d27553fb817c6d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ff16e221ec1a93e07d27553fb817c6d">PostTheta</a> (int <a class="el" href="#a4def6d3a66d18ebb36f3db4e533626f6">ns</a>, int <a class="el" href="#ac84bd657538bc782335e992055a0817e">nt</a>, int <a class="el" href="#a90f7a7de632412bd9017e33a594105f4">nb</a>, int <a class="el" href="#aec066996693ada57084aa1ee52f04948">no</a>, SpMat <a class="el" href="#a87a3adb6b92056e8dacea22fa894300a">Ax</a>, Vect <a class="el" href="#a762b11a93e586f00ded70b7776e075ad">y</a>, SpMat <a class="el" href="#a71833a89a8c3dc58117eb467feac7674">c0</a>, SpMat <a class="el" href="#ade2defef59b9295d794620fefb7c8b05">g1</a>, SpMat <a class="el" href="#ae1be0d6e322a26924b67b6258cf55b08">g2</a>, Vect theta_prior, string solver_type, const bool <a class="el" href="#adc24faaa8937de8de88dde11fa9020f7">constr</a>, const MatrixXd <a class="el" href="#af80d7b7e847c30706a826a1c6d7c2fc1">Dx</a>, const MatrixXd <a class="el" href="#a5a765bc4a434d2c4926b7c035984dd66">Dxy</a>, const bool validate, const Vect w)</td></tr>
<tr class="memdesc:a4ff16e221ec1a93e07d27553fb817c6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for spatial model (order 2).  <br /></td></tr>
<tr class="separator:a4ff16e221ec1a93e07d27553fb817c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35269dd8407ce1c126a4b87a31b7a310" id="r_a35269dd8407ce1c126a4b87a31b7a310"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35269dd8407ce1c126a4b87a31b7a310">PostTheta</a> (int <a class="el" href="#a4def6d3a66d18ebb36f3db4e533626f6">ns</a>, int <a class="el" href="#ac84bd657538bc782335e992055a0817e">nt</a>, int <a class="el" href="#a90f7a7de632412bd9017e33a594105f4">nb</a>, int <a class="el" href="#aec066996693ada57084aa1ee52f04948">no</a>, SpMat <a class="el" href="#a87a3adb6b92056e8dacea22fa894300a">Ax</a>, Vect <a class="el" href="#a762b11a93e586f00ded70b7776e075ad">y</a>, SpMat <a class="el" href="#a71833a89a8c3dc58117eb467feac7674">c0</a>, SpMat <a class="el" href="#ade2defef59b9295d794620fefb7c8b05">g1</a>, SpMat <a class="el" href="#ae1be0d6e322a26924b67b6258cf55b08">g2</a>, SpMat <a class="el" href="#ac59ad0f384dc3d3f73c6f340aaac2996">g3</a>, SpMat <a class="el" href="#a06391c3ed3d8368da520d465cc909bc0">M0</a>, SpMat <a class="el" href="#af97e49a98f2a9f390abb52cdaf998577">M1</a>, SpMat <a class="el" href="#a93e3e540d2f3d3cd343f9a66867ec03a">M2</a>, Vect theta_prior, string solver_type, const bool <a class="el" href="#adc24faaa8937de8de88dde11fa9020f7">constr</a>, const MatrixXd <a class="el" href="#af80d7b7e847c30706a826a1c6d7c2fc1">Dx</a>, const MatrixXd <a class="el" href="#a5a765bc4a434d2c4926b7c035984dd66">Dxy</a>, const bool validate, const Vect w)</td></tr>
<tr class="memdesc:a35269dd8407ce1c126a4b87a31b7a310"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for spatial temporal model.  <br /></td></tr>
<tr class="separator:a35269dd8407ce1c126a4b87a31b7a310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c031e4b1773db975d3038ac01b0977" id="r_a42c031e4b1773db975d3038ac01b0977"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42c031e4b1773db975d3038ac01b0977">operator()</a> (Vect &amp;theta, Vect &amp;grad)</td></tr>
<tr class="memdesc:a42c031e4b1773db975d3038ac01b0977"><td class="mdescLeft">&#160;</td><td class="mdescRight">structure required by <a class="el" href="classBFGS.html">BFGS</a> solver, requires : theta, gradient theta  <br /></td></tr>
<tr class="separator:a42c031e4b1773db975d3038ac01b0977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a7918139c515f19f4663057ca3e5cc" id="r_a33a7918139c515f19f4663057ca3e5cc"><td class="memItemLeft" align="right" valign="top"><a id="a33a7918139c515f19f4663057ca3e5cc" name="a33a7918139c515f19f4663057ca3e5cc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>computeG</b> (Vect &amp;theta)</td></tr>
<tr class="memdesc:a33a7918139c515f19f4663057ca3e5cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">overwriting G every time, not explicitly listed, better way to do this? needs to be stored after every iteration for smart hessian ... <br  />
 <br /></td></tr>
<tr class="separator:a33a7918139c515f19f4663057ca3e5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc197a1ae82c5265a0a465c4cfa2727" id="r_a4fc197a1ae82c5265a0a465c4cfa2727"><td class="memItemLeft" align="right" valign="top"><a id="a4fc197a1ae82c5265a0a465c4cfa2727" name="a4fc197a1ae82c5265a0a465c4cfa2727"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>get_fct_count</b> ()</td></tr>
<tr class="separator:a4fc197a1ae82c5265a0a465c4cfa2727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfdc66118e93525b7814f53c6b50e652" id="r_adfdc66118e93525b7814f53c6b50e652"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfdc66118e93525b7814f53c6b50e652">convert_theta2interpret</a> (double lgamE, double lgamS, double lgamT, double &amp;sigU, double &amp;ranS, double &amp;ranT)</td></tr>
<tr class="memdesc:adfdc66118e93525b7814f53c6b50e652"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert hyperparameters theta from the model parametrisation to the interpretable parametrisation ie. from log(gamma_E, gamma_s, gamma_t) to log(sigma.u, rangeS, rangeT)  <br /></td></tr>
<tr class="separator:adfdc66118e93525b7814f53c6b50e652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada9c36637820d3eaad19d4b3449c98ad" id="r_ada9c36637820d3eaad19d4b3449c98ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada9c36637820d3eaad19d4b3449c98ad">convert_interpret2theta</a> (double sigU, double ranS, double ranT, double &amp;lgamE, double &amp;lgamS, double &amp;lgamT)</td></tr>
<tr class="memdesc:ada9c36637820d3eaad19d4b3449c98ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert hyperparameters theta from the interpretable parametrisation to the model parametrisation ie. from log(sigma.u, rangeS, rangeT) to log(gamma_E, gamma_s, gamma_t)  <br /></td></tr>
<tr class="separator:ada9c36637820d3eaad19d4b3449c98ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0f3a13e200dc7833ad7297dc67d0b9" id="r_aff0f3a13e200dc7833ad7297dc67d0b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff0f3a13e200dc7833ad7297dc67d0b9">get_mu</a> (Vect &amp;theta, Vect &amp;<a class="el" href="#aa6d3402de41235b5226e1e93be4a9dbe">mu</a>)</td></tr>
<tr class="memdesc:aff0f3a13e200dc7833ad7297dc67d0b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">get conditional mean mu for theta.  <br /></td></tr>
<tr class="separator:aff0f3a13e200dc7833ad7297dc67d0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b59d9c23fb21cf517f281ae48ac970d" id="r_a6b59d9c23fb21cf517f281ae48ac970d"><td class="memItemLeft" align="right" valign="top">Vect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b59d9c23fb21cf517f281ae48ac970d">get_grad</a> ()</td></tr>
<tr class="memdesc:a6b59d9c23fb21cf517f281ae48ac970d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns current gradient of theta.  <br /></td></tr>
<tr class="separator:a6b59d9c23fb21cf517f281ae48ac970d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb8efdc44447d6224893f6debf29540" id="r_a9eb8efdc44447d6224893f6debf29540"><td class="memItemLeft" align="right" valign="top">MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9eb8efdc44447d6224893f6debf29540">get_Covariance</a> (Vect &amp;theta, double eps)</td></tr>
<tr class="memdesc:a9eb8efdc44447d6224893f6debf29540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute Covariance matrix of hyperparameters theta, at theta.  <br /></td></tr>
<tr class="separator:a9eb8efdc44447d6224893f6debf29540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2589db16c7d4784189d003016d99cf89" id="r_a2589db16c7d4784189d003016d99cf89"><td class="memItemLeft" align="right" valign="top"><a id="a2589db16c7d4784189d003016d99cf89" name="a2589db16c7d4784189d003016d99cf89"></a>
MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><b>get_Cov_interpret_param</b> (Vect &amp;interpret_theta, double eps)</td></tr>
<tr class="separator:a2589db16c7d4784189d003016d99cf89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52398b5f03001d24a9bd69d02e7c9773" id="r_a52398b5f03001d24a9bd69d02e7c9773"><td class="memItemLeft" align="right" valign="top"><a id="a52398b5f03001d24a9bd69d02e7c9773" name="a52398b5f03001d24a9bd69d02e7c9773"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>f_eval</b> (Vect &amp;theta)</td></tr>
<tr class="separator:a52398b5f03001d24a9bd69d02e7c9773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d01ba1dcfedc1e9b250586c0f6ab98" id="r_ab6d01ba1dcfedc1e9b250586c0f6ab98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6d01ba1dcfedc1e9b250586c0f6ab98">get_marginals_f</a> (Vect &amp;theta, Vect &amp;vars)</td></tr>
<tr class="memdesc:ab6d01ba1dcfedc1e9b250586c0f6ab98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the marginal variances of the latent parameters at theta. Using selected inversion procedure.  <br /></td></tr>
<tr class="separator:ab6d01ba1dcfedc1e9b250586c0f6ab98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba126f6b1bc95b8815465debaedd650" id="r_a8ba126f6b1bc95b8815465debaedd650"><td class="memItemLeft" align="right" valign="top">MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ba126f6b1bc95b8815465debaedd650">hess_eval</a> (Vect &amp;theta, double eps)</td></tr>
<tr class="memdesc:a8ba126f6b1bc95b8815465debaedd650"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the hessian at theta using second order finite difference. Is used be get_Covariance.  <br /></td></tr>
<tr class="separator:a8ba126f6b1bc95b8815465debaedd650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67ecf629a6a81db6966614517acfbbb" id="r_ae67ecf629a6a81db6966614517acfbbb"><td class="memItemLeft" align="right" valign="top"><a id="ae67ecf629a6a81db6966614517acfbbb" name="ae67ecf629a6a81db6966614517acfbbb"></a>
MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><b>hess_eval_interpret_theta</b> (Vect &amp;interpret_theta, double eps)</td></tr>
<tr class="separator:ae67ecf629a6a81db6966614517acfbbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240a43fde6a2e26c30275b24f99f5d4e" id="r_a240a43fde6a2e26c30275b24f99f5d4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a240a43fde6a2e26c30275b24f99f5d4e">check_pos_def</a> (MatrixXd &amp;hess)</td></tr>
<tr class="memdesc:a240a43fde6a2e26c30275b24f99f5d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if Hessian positive definite (matrix assumed to be dense &amp; small since dim(theta) small)  <br /></td></tr>
<tr class="separator:a240a43fde6a2e26c30275b24f99f5d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a437a6716c8fe32396f0643f3dba43e5b" id="r_a437a6716c8fe32396f0643f3dba43e5b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a437a6716c8fe32396f0643f3dba43e5b">eval_post_theta</a> (Vect &amp;theta, Vect &amp;<a class="el" href="#aa6d3402de41235b5226e1e93be4a9dbe">mu</a>)</td></tr>
<tr class="memdesc:a437a6716c8fe32396f0643f3dba43e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Core function. Evaluate posterior of theta. mu are latent parameters.  <br /></td></tr>
<tr class="separator:a437a6716c8fe32396f0643f3dba43e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52137ac2ce65806e9b9e99177adecd33" id="r_a52137ac2ce65806e9b9e99177adecd33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52137ac2ce65806e9b9e99177adecd33">eval_log_gaussian_prior_hp</a> (double &amp;log_prior, double *thetai, double *thetai_original)</td></tr>
<tr class="memdesc:a52137ac2ce65806e9b9e99177adecd33"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate log prior of the hyperparameters using original theta value  <br /></td></tr>
<tr class="separator:a52137ac2ce65806e9b9e99177adecd33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f7a4987eeb15a84b1af7c784c3b6ff" id="r_a66f7a4987eeb15a84b1af7c784c3b6ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66f7a4987eeb15a84b1af7c784c3b6ff">eval_log_pc_prior_hp</a> (double &amp;log_sum, Vect &amp;lambda, Vect &amp;theta_interpret)</td></tr>
<tr class="memdesc:a66f7a4987eeb15a84b1af7c784c3b6ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate log prior using PC prior  <br /></td></tr>
<tr class="separator:a66f7a4987eeb15a84b1af7c784c3b6ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a1b9ac95394ba1992ed25b4b34e128" id="r_a79a1b9ac95394ba1992ed25b4b34e128"><td class="memItemLeft" align="right" valign="top"><a id="a79a1b9ac95394ba1992ed25b4b34e128" name="a79a1b9ac95394ba1992ed25b4b34e128"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>update_mean_constr</b> (const MatrixXd &amp;D, Vect &amp;e, Vect &amp;sol, MatrixXd &amp;V, MatrixXd &amp;W, MatrixXd &amp;U, Vect &amp;updated_sol)</td></tr>
<tr class="separator:a79a1b9ac95394ba1992ed25b4b34e128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4973d0c8335220faafa3bdb2fcfeb331" id="r_a4973d0c8335220faafa3bdb2fcfeb331"><td class="memItemLeft" align="right" valign="top"><a id="a4973d0c8335220faafa3bdb2fcfeb331" name="a4973d0c8335220faafa3bdb2fcfeb331"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>eval_log_dens_constr</b> (Vect &amp;x, Vect &amp;<a class="el" href="#aa6d3402de41235b5226e1e93be4a9dbe">mu</a>, SpMat &amp;Q, double &amp;log_det_Q, const MatrixXd &amp;D, MatrixXd &amp;W, double &amp;val_log_dens)</td></tr>
<tr class="separator:a4973d0c8335220faafa3bdb2fcfeb331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a981439fd52c6b46c1666fd45eb5faa92" id="r_a981439fd52c6b46c1666fd45eb5faa92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a981439fd52c6b46c1666fd45eb5faa92">eval_log_prior_lat</a> (Vect &amp;theta, double &amp;val)</td></tr>
<tr class="memdesc:a981439fd52c6b46c1666fd45eb5faa92"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate log prior of random effects  <br /></td></tr>
<tr class="separator:a981439fd52c6b46c1666fd45eb5faa92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97173a441c0f2f6b9dc2a5fe85e1d6ad" id="r_a97173a441c0f2f6b9dc2a5fe85e1d6ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97173a441c0f2f6b9dc2a5fe85e1d6ad">eval_likelihood</a> (Vect &amp;theta, double &amp;log_det, double &amp;val)</td></tr>
<tr class="memdesc:a97173a441c0f2f6b9dc2a5fe85e1d6ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute log likelihood : log_det tau*no and value -theta*yTy  <br /></td></tr>
<tr class="separator:a97173a441c0f2f6b9dc2a5fe85e1d6ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ceec7e512bf71ca7267f01733ec8719" id="r_a2ceec7e512bf71ca7267f01733ec8719"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ceec7e512bf71ca7267f01733ec8719">construct_Q_spatial</a> (Vect &amp;theta, SpMat &amp;Qs)</td></tr>
<tr class="memdesc:a2ceec7e512bf71ca7267f01733ec8719"><td class="mdescLeft">&#160;</td><td class="mdescRight">spatial model : SPDE discretisation &ndash; matrix construction  <br /></td></tr>
<tr class="separator:a2ceec7e512bf71ca7267f01733ec8719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41faf4a6b8b2a30168f35805c2c7b3f" id="r_ac41faf4a6b8b2a30168f35805c2c7b3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac41faf4a6b8b2a30168f35805c2c7b3f">construct_Q_spat_temp</a> (Vect &amp;theta, SpMat &amp;Qst)</td></tr>
<tr class="memdesc:ac41faf4a6b8b2a30168f35805c2c7b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">spatial temporal model : SPDE discretisation. DEMF(1,2,1) model.  <br /></td></tr>
<tr class="separator:ac41faf4a6b8b2a30168f35805c2c7b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb642337f6f4db477be2318bb9796f2c" id="r_acb642337f6f4db477be2318bb9796f2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb642337f6f4db477be2318bb9796f2c">construct_Q</a> (Vect &amp;theta, SpMat &amp;Q)</td></tr>
<tr class="memdesc:acb642337f6f4db477be2318bb9796f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct precision matrix. Calls spatial, spatial-temporal, etc.  <br /></td></tr>
<tr class="separator:acb642337f6f4db477be2318bb9796f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69559f2f98cbdd4b844a9e0c571d64d" id="r_af69559f2f98cbdd4b844a9e0c571d64d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af69559f2f98cbdd4b844a9e0c571d64d">construct_b</a> (Vect &amp;theta, Vect &amp;rhs)</td></tr>
<tr class="memdesc:af69559f2f98cbdd4b844a9e0c571d64d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble right-handside.  <br /></td></tr>
<tr class="separator:af69559f2f98cbdd4b844a9e0c571d64d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af7519622a314b59a75f5b84f15ad9a" id="r_a5af7519622a314b59a75f5b84f15ad9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5af7519622a314b59a75f5b84f15ad9a">eval_denominator</a> (Vect &amp;theta, double &amp;val, SpMat &amp;Q, Vect &amp;rhs, Vect &amp;<a class="el" href="#aa6d3402de41235b5226e1e93be4a9dbe">mu</a>)</td></tr>
<tr class="memdesc:a5af7519622a314b59a75f5b84f15ad9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate denominator: conditional probability of Qx|y.  <br /></td></tr>
<tr class="separator:a5af7519622a314b59a75f5b84f15ad9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d7a18584db9aace5d217437bdfe84fa" id="r_a3d7a18584db9aace5d217437bdfe84fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d7a18584db9aace5d217437bdfe84fa">eval_gradient</a> (Vect &amp;theta, double f_theta, Vect &amp;<a class="el" href="#aa6d3402de41235b5226e1e93be4a9dbe">mu</a>, Vect &amp;grad)</td></tr>
<tr class="memdesc:a3d7a18584db9aace5d217437bdfe84fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute gradient using central finite difference stencil. Parallelised with OpenMP.  <br /></td></tr>
<tr class="separator:a3d7a18584db9aace5d217437bdfe84fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f05821cf3af095b3a9fa66919266bf" id="r_a29f05821cf3af095b3a9fa66919266bf"><td class="memItemLeft" align="right" valign="top"><a id="a29f05821cf3af095b3a9fa66919266bf" name="a29f05821cf3af095b3a9fa66919266bf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>record_times</b> (std::string file_name, int <a class="el" href="#a6f35b1d4e2eb881fd0b8513571874bc0">iter_count</a>, double t_Ftheta_ext, double t_thread_nom, double t_priorHyp, double t_priorLat, double t_priorLatAMat, double t_priorLatChol, double t_likel, double t_thread_denom, double t_condLat, double t_condLatAMat, double t_condLatChol, double t_condLatSolve)</td></tr>
<tr class="separator:a29f05821cf3af095b3a9fa66919266bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d5640ff12bb9e2828559153c61f352" id="r_a72d5640ff12bb9e2828559153c61f352"><td class="memItemLeft" align="right" valign="top"><a id="a72d5640ff12bb9e2828559153c61f352" name="a72d5640ff12bb9e2828559153c61f352"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~PostTheta</b> ()</td></tr>
<tr class="memdesc:a72d5640ff12bb9e2828559153c61f352"><td class="mdescLeft">&#160;</td><td class="mdescRight">class destructor. Frees memory allocated by <a class="el" href="classPostTheta.html" title="Computes the Posterior of the hyperparameters theta.">PostTheta</a> class. <br /></td></tr>
<tr class="separator:a72d5640ff12bb9e2828559153c61f352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56db4c858de1c0dc0721bf19e60c493c" id="r_a56db4c858de1c0dc0721bf19e60c493c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56db4c858de1c0dc0721bf19e60c493c">PostTheta</a> (int <a class="el" href="#a4def6d3a66d18ebb36f3db4e533626f6">ns</a>, int <a class="el" href="#ac84bd657538bc782335e992055a0817e">nt</a>, int <a class="el" href="#a90f7a7de632412bd9017e33a594105f4">nb</a>, int <a class="el" href="#aec066996693ada57084aa1ee52f04948">no</a>, MatrixXd <a class="el" href="#acc70e6f2659235075873ecee40a126cf">B</a>, Vect <a class="el" href="#a762b11a93e586f00ded70b7776e075ad">y</a>, Vect theta_prior, string solver_type, const bool <a class="el" href="#adc24faaa8937de8de88dde11fa9020f7">constr</a>, const MatrixXd <a class="el" href="#a5a765bc4a434d2c4926b7c035984dd66">Dxy</a>, const bool validate, const Vect w)</td></tr>
<tr class="memdesc:a56db4c858de1c0dc0721bf19e60c493c"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for regression model (no random effects).  <br /></td></tr>
<tr class="separator:a56db4c858de1c0dc0721bf19e60c493c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c76a2e26834f27d287692faaf88017" id="r_ab3c76a2e26834f27d287692faaf88017"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3c76a2e26834f27d287692faaf88017">PostTheta</a> (int <a class="el" href="#a4def6d3a66d18ebb36f3db4e533626f6">ns</a>, int <a class="el" href="#ac84bd657538bc782335e992055a0817e">nt</a>, int <a class="el" href="#a90f7a7de632412bd9017e33a594105f4">nb</a>, int <a class="el" href="#aec066996693ada57084aa1ee52f04948">no</a>, SpRmMat <a class="el" href="#a87a3adb6b92056e8dacea22fa894300a">Ax</a>, Vect <a class="el" href="#a762b11a93e586f00ded70b7776e075ad">y</a>, SpMat <a class="el" href="#a71833a89a8c3dc58117eb467feac7674">c0</a>, SpMat <a class="el" href="#ade2defef59b9295d794620fefb7c8b05">g1</a>, SpMat <a class="el" href="#ae1be0d6e322a26924b67b6258cf55b08">g2</a>, Vect theta_prior, string solver_type, int dim_spatial_domain, string <a class="el" href="#a48f86e8f68bce72ec4f0aed80ebebce7">manifold</a>, const bool <a class="el" href="#adc24faaa8937de8de88dde11fa9020f7">constr</a>, const MatrixXd <a class="el" href="#af80d7b7e847c30706a826a1c6d7c2fc1">Dx</a>, const MatrixXd <a class="el" href="#a5a765bc4a434d2c4926b7c035984dd66">Dxy</a>, const bool validate, const Vect w)</td></tr>
<tr class="memdesc:ab3c76a2e26834f27d287692faaf88017"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for spatial model (order 2).  <br /></td></tr>
<tr class="separator:ab3c76a2e26834f27d287692faaf88017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5643b54315d75dae26fd435386ddaf8" id="r_af5643b54315d75dae26fd435386ddaf8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5643b54315d75dae26fd435386ddaf8">PostTheta</a> (int <a class="el" href="#a4def6d3a66d18ebb36f3db4e533626f6">ns</a>, int <a class="el" href="#ac84bd657538bc782335e992055a0817e">nt</a>, int <a class="el" href="#a90f7a7de632412bd9017e33a594105f4">nb</a>, int <a class="el" href="#aec066996693ada57084aa1ee52f04948">no</a>, SpRmMat <a class="el" href="#a87a3adb6b92056e8dacea22fa894300a">Ax</a>, Vect <a class="el" href="#a762b11a93e586f00ded70b7776e075ad">y</a>, SpMat <a class="el" href="#a71833a89a8c3dc58117eb467feac7674">c0</a>, SpMat <a class="el" href="#ade2defef59b9295d794620fefb7c8b05">g1</a>, SpMat <a class="el" href="#ae1be0d6e322a26924b67b6258cf55b08">g2</a>, SpMat <a class="el" href="#ac59ad0f384dc3d3f73c6f340aaac2996">g3</a>, SpMat <a class="el" href="#a06391c3ed3d8368da520d465cc909bc0">M0</a>, SpMat <a class="el" href="#af97e49a98f2a9f390abb52cdaf998577">M1</a>, SpMat <a class="el" href="#a93e3e540d2f3d3cd343f9a66867ec03a">M2</a>, Vect theta_prior, string solver_type, int dim_spatial_domain, string <a class="el" href="#a48f86e8f68bce72ec4f0aed80ebebce7">manifold</a>, const bool <a class="el" href="#adc24faaa8937de8de88dde11fa9020f7">constr</a>, const MatrixXd <a class="el" href="#af80d7b7e847c30706a826a1c6d7c2fc1">Dx</a>, const MatrixXd <a class="el" href="#a5a765bc4a434d2c4926b7c035984dd66">Dxy</a>, const bool validate, const Vect w)</td></tr>
<tr class="memdesc:af5643b54315d75dae26fd435386ddaf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for spatial temporal model.  <br /></td></tr>
<tr class="separator:af5643b54315d75dae26fd435386ddaf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b658144e57ed4b75dd037d014fbc767" id="r_a9b658144e57ed4b75dd037d014fbc767"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b658144e57ed4b75dd037d014fbc767">PostTheta</a> (int ns_, int nt_, int nss_, int nb_, int no_, SpRmMat Ax_, Vect y_, SpMat c0_, SpMat g1_, SpMat g2_, SpMat g3_, SpMat M0_, SpMat M1_, SpMat M2_, Vect theta_prior_param_, string solver_type_, int dim_spatial_domain_, string manifold_, const bool constr_, const MatrixXd Dx_, const MatrixXd Dxy_, const bool validate_, const Vect w_)</td></tr>
<tr class="memdesc:a9b658144e57ed4b75dd037d014fbc767"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for spatial temporal model w/ add. spatial field  <br /></td></tr>
<tr class="separator:a9b658144e57ed4b75dd037d014fbc767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c031e4b1773db975d3038ac01b0977" id="r_a42c031e4b1773db975d3038ac01b0977"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42c031e4b1773db975d3038ac01b0977">operator()</a> (Vect &amp;theta, Vect &amp;grad)</td></tr>
<tr class="memdesc:a42c031e4b1773db975d3038ac01b0977"><td class="mdescLeft">&#160;</td><td class="mdescRight">structure required by <a class="el" href="classBFGS.html">BFGS</a> solver, requires : theta, gradient theta  <br /></td></tr>
<tr class="separator:a42c031e4b1773db975d3038ac01b0977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f0a2f1e8653c50fa9d4c3c24469ea06" id="r_a5f0a2f1e8653c50fa9d4c3c24469ea06"><td class="memItemLeft" align="right" valign="top"><a id="a5f0a2f1e8653c50fa9d4c3c24469ea06" name="a5f0a2f1e8653c50fa9d4c3c24469ea06"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>compute_error_bfgs</b> (Vect &amp;theta)</td></tr>
<tr class="separator:a5f0a2f1e8653c50fa9d4c3c24469ea06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a7918139c515f19f4663057ca3e5cc" id="r_a33a7918139c515f19f4663057ca3e5cc"><td class="memItemLeft" align="right" valign="top"><a id="a33a7918139c515f19f4663057ca3e5cc" name="a33a7918139c515f19f4663057ca3e5cc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>computeG</b> (Vect &amp;theta)</td></tr>
<tr class="memdesc:a33a7918139c515f19f4663057ca3e5cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">overwriting G every time, not explicitly listed, better way to do this? needs to be stored after every iteration for smart hessian ... <br  />
 <br /></td></tr>
<tr class="separator:a33a7918139c515f19f4663057ca3e5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc197a1ae82c5265a0a465c4cfa2727" id="r_a4fc197a1ae82c5265a0a465c4cfa2727"><td class="memItemLeft" align="right" valign="top"><a id="a4fc197a1ae82c5265a0a465c4cfa2727" name="a4fc197a1ae82c5265a0a465c4cfa2727"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>get_fct_count</b> ()</td></tr>
<tr class="separator:a4fc197a1ae82c5265a0a465c4cfa2727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed82a7d83d895a856f6841b9ef701783" id="r_aed82a7d83d895a856f6841b9ef701783"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed82a7d83d895a856f6841b9ef701783">convert_theta2interpret_spatTemp</a> (double lgamE, double lgamS, double lgamT, double &amp;sigU, double &amp;ranS, double &amp;ranT)</td></tr>
<tr class="memdesc:aed82a7d83d895a856f6841b9ef701783"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert hyperparameters theta from the model parametrisation to the interpretable parametrisation ie. from log(gamma_E, gamma_s, gamma_t) to log(sigma.u, rangeS, rangeT)  <br /></td></tr>
<tr class="separator:aed82a7d83d895a856f6841b9ef701783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fecf779db9e24870fa0c21ac556399e" id="r_a9fecf779db9e24870fa0c21ac556399e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9fecf779db9e24870fa0c21ac556399e">convert_interpret2theta_spatTemp</a> (double sigU, double ranS, double ranT, double &amp;lgamE, double &amp;lgamS, double &amp;lgamT)</td></tr>
<tr class="memdesc:a9fecf779db9e24870fa0c21ac556399e"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert hyperparameters theta from the interpretable parametrisation to the model parametrisation ie. from log(sigma.u, rangeS, rangeT) to log(gamma_E, gamma_s, gamma_t)  <br /></td></tr>
<tr class="separator:a9fecf779db9e24870fa0c21ac556399e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1106be4ac083bf08aa93fd38e7a24764" id="r_a1106be4ac083bf08aa93fd38e7a24764"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1106be4ac083bf08aa93fd38e7a24764">convert_interpret2theta_spat</a> (double lranS, double lsigU, double &amp;lgamS, double &amp;lgamE)</td></tr>
<tr class="memdesc:a1106be4ac083bf08aa93fd38e7a24764"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert hyperparameters theta from the interpretable parametrisation to the model parametrisation ie. from log(rangeS, sigma.u) to log(gamma_s, gamma_E) for spatial model order 2  <br /></td></tr>
<tr class="separator:a1106be4ac083bf08aa93fd38e7a24764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9138a56d91cdca73cc350d3d5011734" id="r_ae9138a56d91cdca73cc350d3d5011734"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9138a56d91cdca73cc350d3d5011734">convert_theta2interpret_spat</a> (double lgamS, double lgamE, double &amp;lranS, double &amp;lsigU)</td></tr>
<tr class="memdesc:ae9138a56d91cdca73cc350d3d5011734"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert hyperparameters theta from the interpretable parametrisation to the model parametrisation ie. from log(rangeS, sigma.u) to log(gamma_s, gamma_E) for spatial model order 2  <br /></td></tr>
<tr class="separator:ae9138a56d91cdca73cc350d3d5011734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0f3a13e200dc7833ad7297dc67d0b9" id="r_aff0f3a13e200dc7833ad7297dc67d0b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff0f3a13e200dc7833ad7297dc67d0b9">get_mu</a> (Vect &amp;theta, Vect &amp;<a class="el" href="#aa6d3402de41235b5226e1e93be4a9dbe">mu</a>)</td></tr>
<tr class="memdesc:aff0f3a13e200dc7833ad7297dc67d0b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">get conditional mean mu for theta.  <br /></td></tr>
<tr class="separator:aff0f3a13e200dc7833ad7297dc67d0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b59d9c23fb21cf517f281ae48ac970d" id="r_a6b59d9c23fb21cf517f281ae48ac970d"><td class="memItemLeft" align="right" valign="top">Vect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b59d9c23fb21cf517f281ae48ac970d">get_grad</a> ()</td></tr>
<tr class="memdesc:a6b59d9c23fb21cf517f281ae48ac970d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns current gradient of theta.  <br /></td></tr>
<tr class="separator:a6b59d9c23fb21cf517f281ae48ac970d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb8efdc44447d6224893f6debf29540" id="r_a9eb8efdc44447d6224893f6debf29540"><td class="memItemLeft" align="right" valign="top">MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9eb8efdc44447d6224893f6debf29540">get_Covariance</a> (Vect &amp;theta, double eps)</td></tr>
<tr class="memdesc:a9eb8efdc44447d6224893f6debf29540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute Covariance matrix of hyperparameters theta, at theta.  <br /></td></tr>
<tr class="separator:a9eb8efdc44447d6224893f6debf29540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2589db16c7d4784189d003016d99cf89" id="r_a2589db16c7d4784189d003016d99cf89"><td class="memItemLeft" align="right" valign="top"><a id="a2589db16c7d4784189d003016d99cf89" name="a2589db16c7d4784189d003016d99cf89"></a>
MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><b>get_Cov_interpret_param</b> (Vect &amp;interpret_theta, double eps)</td></tr>
<tr class="separator:a2589db16c7d4784189d003016d99cf89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52398b5f03001d24a9bd69d02e7c9773" id="r_a52398b5f03001d24a9bd69d02e7c9773"><td class="memItemLeft" align="right" valign="top"><a id="a52398b5f03001d24a9bd69d02e7c9773" name="a52398b5f03001d24a9bd69d02e7c9773"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>f_eval</b> (Vect &amp;theta)</td></tr>
<tr class="separator:a52398b5f03001d24a9bd69d02e7c9773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d01ba1dcfedc1e9b250586c0f6ab98" id="r_ab6d01ba1dcfedc1e9b250586c0f6ab98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6d01ba1dcfedc1e9b250586c0f6ab98">get_marginals_f</a> (Vect &amp;theta, Vect &amp;vars)</td></tr>
<tr class="memdesc:ab6d01ba1dcfedc1e9b250586c0f6ab98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the marginal variances of the latent parameters at theta. Using selected inversion procedure.  <br /></td></tr>
<tr class="separator:ab6d01ba1dcfedc1e9b250586c0f6ab98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe3237450eed420a2a2bb8217afaa428" id="r_afe3237450eed420a2a2bb8217afaa428"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe3237450eed420a2a2bb8217afaa428">get_fullFact_marginals_f</a> (Vect &amp;theta, SpMat &amp;Qinv)</td></tr>
<tr class="memdesc:afe3237450eed420a2a2bb8217afaa428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the marginal variances of the latent parameters at theta. Using selected inversion procedure.  <br /></td></tr>
<tr class="separator:afe3237450eed420a2a2bb8217afaa428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f3147a4bf4bf830d04b5424818b82c5" id="r_a6f3147a4bf4bf830d04b5424818b82c5"><td class="memItemLeft" align="right" valign="top"><a id="a6f3147a4bf4bf830d04b5424818b82c5" name="a6f3147a4bf4bf830d04b5424818b82c5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>compute_fullInverseQ</b> (Vect &amp;theta, MatrixXd &amp;Qinv)</td></tr>
<tr class="separator:a6f3147a4bf4bf830d04b5424818b82c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e35cd65f1a96171c9bb2eb51197e054" id="r_a3e35cd65f1a96171c9bb2eb51197e054"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e35cd65f1a96171c9bb2eb51197e054">compute_marginals_y</a> (SpMat &amp;Qinv, SpRmMat &amp;Ax_all, Vect &amp;projMargVar)</td></tr>
<tr class="memdesc:a3e35cd65f1a96171c9bb2eb51197e054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the marginal variances at all locations y, (defined through projection matrix), i.e. nrows(y) must equal nrows(Ax) computed as marg_var_y = diag(A*Qinv*A^T) function provides optimized matrix multiplications for this use case.  <br /></td></tr>
<tr class="separator:a3e35cd65f1a96171c9bb2eb51197e054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba126f6b1bc95b8815465debaedd650" id="r_a8ba126f6b1bc95b8815465debaedd650"><td class="memItemLeft" align="right" valign="top">MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ba126f6b1bc95b8815465debaedd650">hess_eval</a> (Vect &amp;theta, double eps)</td></tr>
<tr class="memdesc:a8ba126f6b1bc95b8815465debaedd650"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the hessian at theta using second order finite difference. Is used be get_Covariance.  <br /></td></tr>
<tr class="separator:a8ba126f6b1bc95b8815465debaedd650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67ecf629a6a81db6966614517acfbbb" id="r_ae67ecf629a6a81db6966614517acfbbb"><td class="memItemLeft" align="right" valign="top"><a id="ae67ecf629a6a81db6966614517acfbbb" name="ae67ecf629a6a81db6966614517acfbbb"></a>
MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><b>hess_eval_interpret_theta</b> (Vect &amp;interpret_theta, double eps)</td></tr>
<tr class="separator:ae67ecf629a6a81db6966614517acfbbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240a43fde6a2e26c30275b24f99f5d4e" id="r_a240a43fde6a2e26c30275b24f99f5d4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a240a43fde6a2e26c30275b24f99f5d4e">check_pos_def</a> (MatrixXd &amp;hess)</td></tr>
<tr class="memdesc:a240a43fde6a2e26c30275b24f99f5d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if Hessian positive definite (matrix assumed to be dense &amp; small since dim(theta) small)  <br /></td></tr>
<tr class="separator:a240a43fde6a2e26c30275b24f99f5d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a437a6716c8fe32396f0643f3dba43e5b" id="r_a437a6716c8fe32396f0643f3dba43e5b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a437a6716c8fe32396f0643f3dba43e5b">eval_post_theta</a> (Vect &amp;theta, Vect &amp;<a class="el" href="#aa6d3402de41235b5226e1e93be4a9dbe">mu</a>)</td></tr>
<tr class="memdesc:a437a6716c8fe32396f0643f3dba43e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Core function. Evaluate posterior of theta. mu are latent parameters.  <br /></td></tr>
<tr class="separator:a437a6716c8fe32396f0643f3dba43e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52137ac2ce65806e9b9e99177adecd33" id="r_a52137ac2ce65806e9b9e99177adecd33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52137ac2ce65806e9b9e99177adecd33">eval_log_gaussian_prior_hp</a> (double &amp;log_prior, double *thetai, double *thetai_original)</td></tr>
<tr class="memdesc:a52137ac2ce65806e9b9e99177adecd33"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate log prior of the hyperparameters using original theta value  <br /></td></tr>
<tr class="separator:a52137ac2ce65806e9b9e99177adecd33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f7a4987eeb15a84b1af7c784c3b6ff" id="r_a66f7a4987eeb15a84b1af7c784c3b6ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66f7a4987eeb15a84b1af7c784c3b6ff">eval_log_pc_prior_hp</a> (double &amp;log_sum, Vect &amp;lambda, Vect &amp;theta_interpret)</td></tr>
<tr class="memdesc:a66f7a4987eeb15a84b1af7c784c3b6ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate log prior using PC prior  <br /></td></tr>
<tr class="separator:a66f7a4987eeb15a84b1af7c784c3b6ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a1b9ac95394ba1992ed25b4b34e128" id="r_a79a1b9ac95394ba1992ed25b4b34e128"><td class="memItemLeft" align="right" valign="top"><a id="a79a1b9ac95394ba1992ed25b4b34e128" name="a79a1b9ac95394ba1992ed25b4b34e128"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>update_mean_constr</b> (const MatrixXd &amp;D, Vect &amp;e, Vect &amp;sol, MatrixXd &amp;V, MatrixXd &amp;W, MatrixXd &amp;U, Vect &amp;updated_sol)</td></tr>
<tr class="separator:a79a1b9ac95394ba1992ed25b4b34e128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4973d0c8335220faafa3bdb2fcfeb331" id="r_a4973d0c8335220faafa3bdb2fcfeb331"><td class="memItemLeft" align="right" valign="top"><a id="a4973d0c8335220faafa3bdb2fcfeb331" name="a4973d0c8335220faafa3bdb2fcfeb331"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>eval_log_dens_constr</b> (Vect &amp;x, Vect &amp;<a class="el" href="#aa6d3402de41235b5226e1e93be4a9dbe">mu</a>, SpMat &amp;Q, double &amp;log_det_Q, const MatrixXd &amp;D, MatrixXd &amp;W, double &amp;val_log_dens)</td></tr>
<tr class="separator:a4973d0c8335220faafa3bdb2fcfeb331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a981439fd52c6b46c1666fd45eb5faa92" id="r_a981439fd52c6b46c1666fd45eb5faa92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a981439fd52c6b46c1666fd45eb5faa92">eval_log_prior_lat</a> (Vect &amp;theta, double &amp;val)</td></tr>
<tr class="memdesc:a981439fd52c6b46c1666fd45eb5faa92"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate log prior of random effects  <br /></td></tr>
<tr class="separator:a981439fd52c6b46c1666fd45eb5faa92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97173a441c0f2f6b9dc2a5fe85e1d6ad" id="r_a97173a441c0f2f6b9dc2a5fe85e1d6ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97173a441c0f2f6b9dc2a5fe85e1d6ad">eval_likelihood</a> (Vect &amp;theta, double &amp;log_det, double &amp;val)</td></tr>
<tr class="memdesc:a97173a441c0f2f6b9dc2a5fe85e1d6ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute log likelihood : log_det tau*no and value -theta*yTy  <br /></td></tr>
<tr class="separator:a97173a441c0f2f6b9dc2a5fe85e1d6ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ceec7e512bf71ca7267f01733ec8719" id="r_a2ceec7e512bf71ca7267f01733ec8719"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ceec7e512bf71ca7267f01733ec8719">construct_Q_spatial</a> (Vect &amp;theta, SpMat &amp;Qs)</td></tr>
<tr class="memdesc:a2ceec7e512bf71ca7267f01733ec8719"><td class="mdescLeft">&#160;</td><td class="mdescRight">spatial model : SPDE discretisation &ndash; matrix construction  <br /></td></tr>
<tr class="separator:a2ceec7e512bf71ca7267f01733ec8719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41faf4a6b8b2a30168f35805c2c7b3f" id="r_ac41faf4a6b8b2a30168f35805c2c7b3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac41faf4a6b8b2a30168f35805c2c7b3f">construct_Q_spat_temp</a> (Vect &amp;theta, SpMat &amp;Qst)</td></tr>
<tr class="memdesc:ac41faf4a6b8b2a30168f35805c2c7b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">spatial temporal model : SPDE discretisation. DEMF(1,2,1) model.  <br /></td></tr>
<tr class="separator:ac41faf4a6b8b2a30168f35805c2c7b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf285fc1b81d2b4f694a3fa1d92c5b8" id="r_aacf285fc1b81d2b4f694a3fa1d92c5b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aacf285fc1b81d2b4f694a3fa1d92c5b8">construct_Qprior</a> (Vect &amp;theta, SpMat &amp;Qprior)</td></tr>
<tr class="memdesc:aacf285fc1b81d2b4f694a3fa1d92c5b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct precision matrix without data Calls spatial, spatial-temporal, etc.  <br /></td></tr>
<tr class="separator:aacf285fc1b81d2b4f694a3fa1d92c5b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb642337f6f4db477be2318bb9796f2c" id="r_acb642337f6f4db477be2318bb9796f2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb642337f6f4db477be2318bb9796f2c">construct_Q</a> (Vect &amp;theta, SpMat &amp;Q)</td></tr>
<tr class="memdesc:acb642337f6f4db477be2318bb9796f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct precision matrix. Calls spatial, spatial-temporal, etc.  <br /></td></tr>
<tr class="separator:acb642337f6f4db477be2318bb9796f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69559f2f98cbdd4b844a9e0c571d64d" id="r_af69559f2f98cbdd4b844a9e0c571d64d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af69559f2f98cbdd4b844a9e0c571d64d">construct_b</a> (Vect &amp;theta, Vect &amp;rhs)</td></tr>
<tr class="memdesc:af69559f2f98cbdd4b844a9e0c571d64d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble right-handside.  <br /></td></tr>
<tr class="separator:af69559f2f98cbdd4b844a9e0c571d64d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af7519622a314b59a75f5b84f15ad9a" id="r_a5af7519622a314b59a75f5b84f15ad9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5af7519622a314b59a75f5b84f15ad9a">eval_denominator</a> (Vect &amp;theta, double &amp;val, SpMat &amp;Q, Vect &amp;rhs, Vect &amp;<a class="el" href="#aa6d3402de41235b5226e1e93be4a9dbe">mu</a>)</td></tr>
<tr class="memdesc:a5af7519622a314b59a75f5b84f15ad9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate denominator: conditional probability of Qx|y.  <br /></td></tr>
<tr class="separator:a5af7519622a314b59a75f5b84f15ad9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d7a18584db9aace5d217437bdfe84fa" id="r_a3d7a18584db9aace5d217437bdfe84fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d7a18584db9aace5d217437bdfe84fa">eval_gradient</a> (Vect &amp;theta, double f_theta, Vect &amp;<a class="el" href="#aa6d3402de41235b5226e1e93be4a9dbe">mu</a>, Vect &amp;grad)</td></tr>
<tr class="memdesc:a3d7a18584db9aace5d217437bdfe84fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute gradient using central finite difference stencil. Parallelised with OpenMP.  <br /></td></tr>
<tr class="separator:a3d7a18584db9aace5d217437bdfe84fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f05821cf3af095b3a9fa66919266bf" id="r_a29f05821cf3af095b3a9fa66919266bf"><td class="memItemLeft" align="right" valign="top"><a id="a29f05821cf3af095b3a9fa66919266bf" name="a29f05821cf3af095b3a9fa66919266bf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>record_times</b> (std::string file_name, int <a class="el" href="#a6f35b1d4e2eb881fd0b8513571874bc0">iter_count</a>, double t_Ftheta_ext, double t_thread_nom, double t_priorHyp, double t_priorLat, double t_priorLatAMat, double t_priorLatChol, double t_likel, double t_thread_denom, double t_condLat, double t_condLatAMat, double t_condLatChol, double t_condLatSolve)</td></tr>
<tr class="separator:a29f05821cf3af095b3a9fa66919266bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d5640ff12bb9e2828559153c61f352" id="r_a72d5640ff12bb9e2828559153c61f352"><td class="memItemLeft" align="right" valign="top"><a id="a72d5640ff12bb9e2828559153c61f352" name="a72d5640ff12bb9e2828559153c61f352"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~PostTheta</b> ()</td></tr>
<tr class="memdesc:a72d5640ff12bb9e2828559153c61f352"><td class="mdescLeft">&#160;</td><td class="mdescRight">class destructor. Frees memory allocated by <a class="el" href="classPostTheta.html" title="Computes the Posterior of the hyperparameters theta.">PostTheta</a> class. <br /></td></tr>
<tr class="separator:a72d5640ff12bb9e2828559153c61f352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56db4c858de1c0dc0721bf19e60c493c" id="r_a56db4c858de1c0dc0721bf19e60c493c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56db4c858de1c0dc0721bf19e60c493c">PostTheta</a> (int <a class="el" href="#a4def6d3a66d18ebb36f3db4e533626f6">ns</a>, int <a class="el" href="#ac84bd657538bc782335e992055a0817e">nt</a>, int <a class="el" href="#a90f7a7de632412bd9017e33a594105f4">nb</a>, int <a class="el" href="#aec066996693ada57084aa1ee52f04948">no</a>, MatrixXd <a class="el" href="#acc70e6f2659235075873ecee40a126cf">B</a>, Vect <a class="el" href="#a762b11a93e586f00ded70b7776e075ad">y</a>, Vect theta_prior, string solver_type, const bool <a class="el" href="#adc24faaa8937de8de88dde11fa9020f7">constr</a>, const MatrixXd <a class="el" href="#a5a765bc4a434d2c4926b7c035984dd66">Dxy</a>, const bool validate, const Vect w)</td></tr>
<tr class="memdesc:a56db4c858de1c0dc0721bf19e60c493c"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for regression model (no random effects).  <br /></td></tr>
<tr class="separator:a56db4c858de1c0dc0721bf19e60c493c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff16e221ec1a93e07d27553fb817c6d" id="r_a4ff16e221ec1a93e07d27553fb817c6d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ff16e221ec1a93e07d27553fb817c6d">PostTheta</a> (int <a class="el" href="#a4def6d3a66d18ebb36f3db4e533626f6">ns</a>, int <a class="el" href="#ac84bd657538bc782335e992055a0817e">nt</a>, int <a class="el" href="#a90f7a7de632412bd9017e33a594105f4">nb</a>, int <a class="el" href="#aec066996693ada57084aa1ee52f04948">no</a>, SpMat <a class="el" href="#a87a3adb6b92056e8dacea22fa894300a">Ax</a>, Vect <a class="el" href="#a762b11a93e586f00ded70b7776e075ad">y</a>, SpMat <a class="el" href="#a71833a89a8c3dc58117eb467feac7674">c0</a>, SpMat <a class="el" href="#ade2defef59b9295d794620fefb7c8b05">g1</a>, SpMat <a class="el" href="#ae1be0d6e322a26924b67b6258cf55b08">g2</a>, Vect theta_prior, string solver_type, const bool <a class="el" href="#adc24faaa8937de8de88dde11fa9020f7">constr</a>, const MatrixXd <a class="el" href="#af80d7b7e847c30706a826a1c6d7c2fc1">Dx</a>, const MatrixXd <a class="el" href="#a5a765bc4a434d2c4926b7c035984dd66">Dxy</a>, const bool validate, const Vect w)</td></tr>
<tr class="memdesc:a4ff16e221ec1a93e07d27553fb817c6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for spatial model (order 2).  <br /></td></tr>
<tr class="separator:a4ff16e221ec1a93e07d27553fb817c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35269dd8407ce1c126a4b87a31b7a310" id="r_a35269dd8407ce1c126a4b87a31b7a310"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35269dd8407ce1c126a4b87a31b7a310">PostTheta</a> (int <a class="el" href="#a4def6d3a66d18ebb36f3db4e533626f6">ns</a>, int <a class="el" href="#ac84bd657538bc782335e992055a0817e">nt</a>, int <a class="el" href="#a90f7a7de632412bd9017e33a594105f4">nb</a>, int <a class="el" href="#aec066996693ada57084aa1ee52f04948">no</a>, SpMat <a class="el" href="#a87a3adb6b92056e8dacea22fa894300a">Ax</a>, Vect <a class="el" href="#a762b11a93e586f00ded70b7776e075ad">y</a>, SpMat <a class="el" href="#a71833a89a8c3dc58117eb467feac7674">c0</a>, SpMat <a class="el" href="#ade2defef59b9295d794620fefb7c8b05">g1</a>, SpMat <a class="el" href="#ae1be0d6e322a26924b67b6258cf55b08">g2</a>, SpMat <a class="el" href="#ac59ad0f384dc3d3f73c6f340aaac2996">g3</a>, SpMat <a class="el" href="#a06391c3ed3d8368da520d465cc909bc0">M0</a>, SpMat <a class="el" href="#af97e49a98f2a9f390abb52cdaf998577">M1</a>, SpMat <a class="el" href="#a93e3e540d2f3d3cd343f9a66867ec03a">M2</a>, Vect theta_prior, string solver_type, const bool <a class="el" href="#adc24faaa8937de8de88dde11fa9020f7">constr</a>, const MatrixXd <a class="el" href="#af80d7b7e847c30706a826a1c6d7c2fc1">Dx</a>, const MatrixXd <a class="el" href="#a5a765bc4a434d2c4926b7c035984dd66">Dxy</a>, const bool validate, const Vect w)</td></tr>
<tr class="memdesc:a35269dd8407ce1c126a4b87a31b7a310"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for spatial temporal model.  <br /></td></tr>
<tr class="separator:a35269dd8407ce1c126a4b87a31b7a310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c031e4b1773db975d3038ac01b0977" id="r_a42c031e4b1773db975d3038ac01b0977"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42c031e4b1773db975d3038ac01b0977">operator()</a> (Vect &amp;theta, Vect &amp;grad)</td></tr>
<tr class="memdesc:a42c031e4b1773db975d3038ac01b0977"><td class="mdescLeft">&#160;</td><td class="mdescRight">structure required by <a class="el" href="classBFGS.html">BFGS</a> solver, requires : theta, gradient theta  <br /></td></tr>
<tr class="separator:a42c031e4b1773db975d3038ac01b0977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a7918139c515f19f4663057ca3e5cc" id="r_a33a7918139c515f19f4663057ca3e5cc"><td class="memItemLeft" align="right" valign="top"><a id="a33a7918139c515f19f4663057ca3e5cc" name="a33a7918139c515f19f4663057ca3e5cc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>computeG</b> (Vect &amp;theta)</td></tr>
<tr class="memdesc:a33a7918139c515f19f4663057ca3e5cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">overwriting G every time, not explicitly listed, better way to do this? needs to be stored after every iteration for smart hessian ... <br  />
 <br /></td></tr>
<tr class="separator:a33a7918139c515f19f4663057ca3e5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc197a1ae82c5265a0a465c4cfa2727" id="r_a4fc197a1ae82c5265a0a465c4cfa2727"><td class="memItemLeft" align="right" valign="top"><a id="a4fc197a1ae82c5265a0a465c4cfa2727" name="a4fc197a1ae82c5265a0a465c4cfa2727"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>get_fct_count</b> ()</td></tr>
<tr class="separator:a4fc197a1ae82c5265a0a465c4cfa2727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfdc66118e93525b7814f53c6b50e652" id="r_adfdc66118e93525b7814f53c6b50e652"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfdc66118e93525b7814f53c6b50e652">convert_theta2interpret</a> (double lgamE, double lgamS, double lgamT, double &amp;sigU, double &amp;ranS, double &amp;ranT)</td></tr>
<tr class="memdesc:adfdc66118e93525b7814f53c6b50e652"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert hyperparameters theta from the model parametrisation to the interpretable parametrisation ie. from log(gamma_E, gamma_s, gamma_t) to log(sigma.u, rangeS, rangeT)  <br /></td></tr>
<tr class="separator:adfdc66118e93525b7814f53c6b50e652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada9c36637820d3eaad19d4b3449c98ad" id="r_ada9c36637820d3eaad19d4b3449c98ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada9c36637820d3eaad19d4b3449c98ad">convert_interpret2theta</a> (double sigU, double ranS, double ranT, double &amp;lgamE, double &amp;lgamS, double &amp;lgamT)</td></tr>
<tr class="memdesc:ada9c36637820d3eaad19d4b3449c98ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert hyperparameters theta from the interpretable parametrisation to the model parametrisation ie. from log(sigma.u, rangeS, rangeT) to log(gamma_E, gamma_s, gamma_t)  <br /></td></tr>
<tr class="separator:ada9c36637820d3eaad19d4b3449c98ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ffad9798426544c91b1f3420e9c8c9" id="r_ac6ffad9798426544c91b1f3420e9c8c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6ffad9798426544c91b1f3420e9c8c9">get_mu</a> (Vect &amp;theta, Vect &amp;<a class="el" href="#aa6d3402de41235b5226e1e93be4a9dbe">mu</a>, ArrayXi &amp;fact_to_rank_list)</td></tr>
<tr class="memdesc:ac6ffad9798426544c91b1f3420e9c8c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">get conditional mean mu for theta.  <br /></td></tr>
<tr class="separator:ac6ffad9798426544c91b1f3420e9c8c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b59d9c23fb21cf517f281ae48ac970d" id="r_a6b59d9c23fb21cf517f281ae48ac970d"><td class="memItemLeft" align="right" valign="top">Vect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b59d9c23fb21cf517f281ae48ac970d">get_grad</a> ()</td></tr>
<tr class="memdesc:a6b59d9c23fb21cf517f281ae48ac970d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns current gradient of theta.  <br /></td></tr>
<tr class="separator:a6b59d9c23fb21cf517f281ae48ac970d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb8efdc44447d6224893f6debf29540" id="r_a9eb8efdc44447d6224893f6debf29540"><td class="memItemLeft" align="right" valign="top">MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9eb8efdc44447d6224893f6debf29540">get_Covariance</a> (Vect &amp;theta, double eps)</td></tr>
<tr class="memdesc:a9eb8efdc44447d6224893f6debf29540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute Covariance matrix of hyperparameters theta, at theta.  <br /></td></tr>
<tr class="separator:a9eb8efdc44447d6224893f6debf29540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2589db16c7d4784189d003016d99cf89" id="r_a2589db16c7d4784189d003016d99cf89"><td class="memItemLeft" align="right" valign="top"><a id="a2589db16c7d4784189d003016d99cf89" name="a2589db16c7d4784189d003016d99cf89"></a>
MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><b>get_Cov_interpret_param</b> (Vect &amp;interpret_theta, double eps)</td></tr>
<tr class="separator:a2589db16c7d4784189d003016d99cf89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52398b5f03001d24a9bd69d02e7c9773" id="r_a52398b5f03001d24a9bd69d02e7c9773"><td class="memItemLeft" align="right" valign="top"><a id="a52398b5f03001d24a9bd69d02e7c9773" name="a52398b5f03001d24a9bd69d02e7c9773"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>f_eval</b> (Vect &amp;theta)</td></tr>
<tr class="separator:a52398b5f03001d24a9bd69d02e7c9773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f0a2f1e8653c50fa9d4c3c24469ea06" id="r_a5f0a2f1e8653c50fa9d4c3c24469ea06"><td class="memItemLeft" align="right" valign="top"><a id="a5f0a2f1e8653c50fa9d4c3c24469ea06" name="a5f0a2f1e8653c50fa9d4c3c24469ea06"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>compute_error_bfgs</b> (Vect &amp;theta)</td></tr>
<tr class="separator:a5f0a2f1e8653c50fa9d4c3c24469ea06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d01ba1dcfedc1e9b250586c0f6ab98" id="r_ab6d01ba1dcfedc1e9b250586c0f6ab98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6d01ba1dcfedc1e9b250586c0f6ab98">get_marginals_f</a> (Vect &amp;theta, Vect &amp;vars)</td></tr>
<tr class="memdesc:ab6d01ba1dcfedc1e9b250586c0f6ab98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the marginal variances of the latent parameters at theta. Using selected inversion procedure.  <br /></td></tr>
<tr class="separator:ab6d01ba1dcfedc1e9b250586c0f6ab98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba126f6b1bc95b8815465debaedd650" id="r_a8ba126f6b1bc95b8815465debaedd650"><td class="memItemLeft" align="right" valign="top">MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ba126f6b1bc95b8815465debaedd650">hess_eval</a> (Vect &amp;theta, double eps)</td></tr>
<tr class="memdesc:a8ba126f6b1bc95b8815465debaedd650"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the hessian at theta using second order finite difference. Is used be get_Covariance.  <br /></td></tr>
<tr class="separator:a8ba126f6b1bc95b8815465debaedd650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67ecf629a6a81db6966614517acfbbb" id="r_ae67ecf629a6a81db6966614517acfbbb"><td class="memItemLeft" align="right" valign="top"><a id="ae67ecf629a6a81db6966614517acfbbb" name="ae67ecf629a6a81db6966614517acfbbb"></a>
MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><b>hess_eval_interpret_theta</b> (Vect &amp;interpret_theta, double eps)</td></tr>
<tr class="separator:ae67ecf629a6a81db6966614517acfbbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240a43fde6a2e26c30275b24f99f5d4e" id="r_a240a43fde6a2e26c30275b24f99f5d4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a240a43fde6a2e26c30275b24f99f5d4e">check_pos_def</a> (MatrixXd &amp;hess)</td></tr>
<tr class="memdesc:a240a43fde6a2e26c30275b24f99f5d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if Hessian positive definite (matrix assumed to be dense &amp; small since dim(theta) small)  <br /></td></tr>
<tr class="separator:a240a43fde6a2e26c30275b24f99f5d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a3133494a5479b3f1f8a557e9490a35" id="r_a6a3133494a5479b3f1f8a557e9490a35"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a3133494a5479b3f1f8a557e9490a35">eval_post_theta</a> (Vect &amp;theta, Vect &amp;<a class="el" href="#aa6d3402de41235b5226e1e93be4a9dbe">mu</a>, ArrayXi &amp;fact_to_rank_list)</td></tr>
<tr class="memdesc:a6a3133494a5479b3f1f8a557e9490a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Core function. Evaluate posterior of theta. mu are latent parameters.  <br /></td></tr>
<tr class="separator:a6a3133494a5479b3f1f8a557e9490a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52137ac2ce65806e9b9e99177adecd33" id="r_a52137ac2ce65806e9b9e99177adecd33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52137ac2ce65806e9b9e99177adecd33">eval_log_gaussian_prior_hp</a> (double &amp;log_prior, double *thetai, double *thetai_original)</td></tr>
<tr class="memdesc:a52137ac2ce65806e9b9e99177adecd33"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate log prior of the hyperparameters using original theta value  <br /></td></tr>
<tr class="separator:a52137ac2ce65806e9b9e99177adecd33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f7a4987eeb15a84b1af7c784c3b6ff" id="r_a66f7a4987eeb15a84b1af7c784c3b6ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66f7a4987eeb15a84b1af7c784c3b6ff">eval_log_pc_prior_hp</a> (double &amp;log_sum, Vect &amp;lambda, Vect &amp;theta_interpret)</td></tr>
<tr class="memdesc:a66f7a4987eeb15a84b1af7c784c3b6ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate log prior using PC prior  <br /></td></tr>
<tr class="separator:a66f7a4987eeb15a84b1af7c784c3b6ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a1b9ac95394ba1992ed25b4b34e128" id="r_a79a1b9ac95394ba1992ed25b4b34e128"><td class="memItemLeft" align="right" valign="top"><a id="a79a1b9ac95394ba1992ed25b4b34e128" name="a79a1b9ac95394ba1992ed25b4b34e128"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>update_mean_constr</b> (const MatrixXd &amp;D, Vect &amp;e, Vect &amp;sol, MatrixXd &amp;V, MatrixXd &amp;W, MatrixXd &amp;U, Vect &amp;updated_sol)</td></tr>
<tr class="separator:a79a1b9ac95394ba1992ed25b4b34e128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4973d0c8335220faafa3bdb2fcfeb331" id="r_a4973d0c8335220faafa3bdb2fcfeb331"><td class="memItemLeft" align="right" valign="top"><a id="a4973d0c8335220faafa3bdb2fcfeb331" name="a4973d0c8335220faafa3bdb2fcfeb331"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>eval_log_dens_constr</b> (Vect &amp;x, Vect &amp;<a class="el" href="#aa6d3402de41235b5226e1e93be4a9dbe">mu</a>, SpMat &amp;Q, double &amp;log_det_Q, const MatrixXd &amp;D, MatrixXd &amp;W, double &amp;val_log_dens)</td></tr>
<tr class="separator:a4973d0c8335220faafa3bdb2fcfeb331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a981439fd52c6b46c1666fd45eb5faa92" id="r_a981439fd52c6b46c1666fd45eb5faa92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a981439fd52c6b46c1666fd45eb5faa92">eval_log_prior_lat</a> (Vect &amp;theta, double &amp;val)</td></tr>
<tr class="memdesc:a981439fd52c6b46c1666fd45eb5faa92"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate log prior of random effects  <br /></td></tr>
<tr class="separator:a981439fd52c6b46c1666fd45eb5faa92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97173a441c0f2f6b9dc2a5fe85e1d6ad" id="r_a97173a441c0f2f6b9dc2a5fe85e1d6ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97173a441c0f2f6b9dc2a5fe85e1d6ad">eval_likelihood</a> (Vect &amp;theta, double &amp;log_det, double &amp;val)</td></tr>
<tr class="memdesc:a97173a441c0f2f6b9dc2a5fe85e1d6ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute log likelihood : log_det tau*no and value -theta*yTy  <br /></td></tr>
<tr class="separator:a97173a441c0f2f6b9dc2a5fe85e1d6ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ceec7e512bf71ca7267f01733ec8719" id="r_a2ceec7e512bf71ca7267f01733ec8719"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ceec7e512bf71ca7267f01733ec8719">construct_Q_spatial</a> (Vect &amp;theta, SpMat &amp;Qs)</td></tr>
<tr class="memdesc:a2ceec7e512bf71ca7267f01733ec8719"><td class="mdescLeft">&#160;</td><td class="mdescRight">spatial model : SPDE discretisation &ndash; matrix construction  <br /></td></tr>
<tr class="separator:a2ceec7e512bf71ca7267f01733ec8719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41faf4a6b8b2a30168f35805c2c7b3f" id="r_ac41faf4a6b8b2a30168f35805c2c7b3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac41faf4a6b8b2a30168f35805c2c7b3f">construct_Q_spat_temp</a> (Vect &amp;theta, SpMat &amp;Qst)</td></tr>
<tr class="memdesc:ac41faf4a6b8b2a30168f35805c2c7b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">spatial temporal model : SPDE discretisation. DEMF(1,2,1) model.  <br /></td></tr>
<tr class="separator:ac41faf4a6b8b2a30168f35805c2c7b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb642337f6f4db477be2318bb9796f2c" id="r_acb642337f6f4db477be2318bb9796f2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb642337f6f4db477be2318bb9796f2c">construct_Q</a> (Vect &amp;theta, SpMat &amp;Q)</td></tr>
<tr class="memdesc:acb642337f6f4db477be2318bb9796f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct precision matrix. Calls spatial, spatial-temporal, etc.  <br /></td></tr>
<tr class="separator:acb642337f6f4db477be2318bb9796f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69559f2f98cbdd4b844a9e0c571d64d" id="r_af69559f2f98cbdd4b844a9e0c571d64d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af69559f2f98cbdd4b844a9e0c571d64d">construct_b</a> (Vect &amp;theta, Vect &amp;rhs)</td></tr>
<tr class="memdesc:af69559f2f98cbdd4b844a9e0c571d64d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble right-handside.  <br /></td></tr>
<tr class="separator:af69559f2f98cbdd4b844a9e0c571d64d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7bf017b26af54eb68645b49a2c99fcb" id="r_ae7bf017b26af54eb68645b49a2c99fcb"><td class="memItemLeft" align="right" valign="top"><a id="ae7bf017b26af54eb68645b49a2c99fcb" name="ae7bf017b26af54eb68645b49a2c99fcb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>update_mean_constr</b> (MatrixXd &amp;D, Vect &amp;e, Vect &amp;sol, MatrixXd &amp;V, MatrixXd &amp;W)</td></tr>
<tr class="separator:ae7bf017b26af54eb68645b49a2c99fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af7519622a314b59a75f5b84f15ad9a" id="r_a5af7519622a314b59a75f5b84f15ad9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5af7519622a314b59a75f5b84f15ad9a">eval_denominator</a> (Vect &amp;theta, double &amp;val, SpMat &amp;Q, Vect &amp;rhs, Vect &amp;<a class="el" href="#aa6d3402de41235b5226e1e93be4a9dbe">mu</a>)</td></tr>
<tr class="memdesc:a5af7519622a314b59a75f5b84f15ad9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate denominator: conditional probability of Qx|y.  <br /></td></tr>
<tr class="separator:a5af7519622a314b59a75f5b84f15ad9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d7a18584db9aace5d217437bdfe84fa" id="r_a3d7a18584db9aace5d217437bdfe84fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d7a18584db9aace5d217437bdfe84fa">eval_gradient</a> (Vect &amp;theta, double f_theta, Vect &amp;<a class="el" href="#aa6d3402de41235b5226e1e93be4a9dbe">mu</a>, Vect &amp;grad)</td></tr>
<tr class="memdesc:a3d7a18584db9aace5d217437bdfe84fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute gradient using central finite difference stencil. Parallelised with OpenMP.  <br /></td></tr>
<tr class="separator:a3d7a18584db9aace5d217437bdfe84fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f05821cf3af095b3a9fa66919266bf" id="r_a29f05821cf3af095b3a9fa66919266bf"><td class="memItemLeft" align="right" valign="top"><a id="a29f05821cf3af095b3a9fa66919266bf" name="a29f05821cf3af095b3a9fa66919266bf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>record_times</b> (std::string file_name, int <a class="el" href="#a6f35b1d4e2eb881fd0b8513571874bc0">iter_count</a>, double t_Ftheta_ext, double t_thread_nom, double t_priorHyp, double t_priorLat, double t_priorLatAMat, double t_priorLatChol, double t_likel, double t_thread_denom, double t_condLat, double t_condLatAMat, double t_condLatChol, double t_condLatSolve)</td></tr>
<tr class="separator:a29f05821cf3af095b3a9fa66919266bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d5640ff12bb9e2828559153c61f352" id="r_a72d5640ff12bb9e2828559153c61f352"><td class="memItemLeft" align="right" valign="top"><a id="a72d5640ff12bb9e2828559153c61f352" name="a72d5640ff12bb9e2828559153c61f352"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~PostTheta</b> ()</td></tr>
<tr class="memdesc:a72d5640ff12bb9e2828559153c61f352"><td class="mdescLeft">&#160;</td><td class="mdescRight">class destructor. Frees memory allocated by <a class="el" href="classPostTheta.html" title="Computes the Posterior of the hyperparameters theta.">PostTheta</a> class. <br /></td></tr>
<tr class="separator:a72d5640ff12bb9e2828559153c61f352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56db4c858de1c0dc0721bf19e60c493c" id="r_a56db4c858de1c0dc0721bf19e60c493c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56db4c858de1c0dc0721bf19e60c493c">PostTheta</a> (int <a class="el" href="#a4def6d3a66d18ebb36f3db4e533626f6">ns</a>, int <a class="el" href="#ac84bd657538bc782335e992055a0817e">nt</a>, int <a class="el" href="#a90f7a7de632412bd9017e33a594105f4">nb</a>, int <a class="el" href="#aec066996693ada57084aa1ee52f04948">no</a>, MatrixXd <a class="el" href="#acc70e6f2659235075873ecee40a126cf">B</a>, Vect <a class="el" href="#a762b11a93e586f00ded70b7776e075ad">y</a>, Vect theta_prior, string solver_type, const bool <a class="el" href="#adc24faaa8937de8de88dde11fa9020f7">constr</a>, const MatrixXd <a class="el" href="#a5a765bc4a434d2c4926b7c035984dd66">Dxy</a>, const bool validate, const Vect w)</td></tr>
<tr class="memdesc:a56db4c858de1c0dc0721bf19e60c493c"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for regression model (no random effects).  <br /></td></tr>
<tr class="separator:a56db4c858de1c0dc0721bf19e60c493c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff16e221ec1a93e07d27553fb817c6d" id="r_a4ff16e221ec1a93e07d27553fb817c6d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ff16e221ec1a93e07d27553fb817c6d">PostTheta</a> (int <a class="el" href="#a4def6d3a66d18ebb36f3db4e533626f6">ns</a>, int <a class="el" href="#ac84bd657538bc782335e992055a0817e">nt</a>, int <a class="el" href="#a90f7a7de632412bd9017e33a594105f4">nb</a>, int <a class="el" href="#aec066996693ada57084aa1ee52f04948">no</a>, SpMat <a class="el" href="#a87a3adb6b92056e8dacea22fa894300a">Ax</a>, Vect <a class="el" href="#a762b11a93e586f00ded70b7776e075ad">y</a>, SpMat <a class="el" href="#a71833a89a8c3dc58117eb467feac7674">c0</a>, SpMat <a class="el" href="#ade2defef59b9295d794620fefb7c8b05">g1</a>, SpMat <a class="el" href="#ae1be0d6e322a26924b67b6258cf55b08">g2</a>, Vect theta_prior, string solver_type, const bool <a class="el" href="#adc24faaa8937de8de88dde11fa9020f7">constr</a>, const MatrixXd <a class="el" href="#af80d7b7e847c30706a826a1c6d7c2fc1">Dx</a>, const MatrixXd <a class="el" href="#a5a765bc4a434d2c4926b7c035984dd66">Dxy</a>, const bool validate, const Vect w)</td></tr>
<tr class="memdesc:a4ff16e221ec1a93e07d27553fb817c6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for spatial model (order 2).  <br /></td></tr>
<tr class="separator:a4ff16e221ec1a93e07d27553fb817c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35269dd8407ce1c126a4b87a31b7a310" id="r_a35269dd8407ce1c126a4b87a31b7a310"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35269dd8407ce1c126a4b87a31b7a310">PostTheta</a> (int <a class="el" href="#a4def6d3a66d18ebb36f3db4e533626f6">ns</a>, int <a class="el" href="#ac84bd657538bc782335e992055a0817e">nt</a>, int <a class="el" href="#a90f7a7de632412bd9017e33a594105f4">nb</a>, int <a class="el" href="#aec066996693ada57084aa1ee52f04948">no</a>, SpMat <a class="el" href="#a87a3adb6b92056e8dacea22fa894300a">Ax</a>, Vect <a class="el" href="#a762b11a93e586f00ded70b7776e075ad">y</a>, SpMat <a class="el" href="#a71833a89a8c3dc58117eb467feac7674">c0</a>, SpMat <a class="el" href="#ade2defef59b9295d794620fefb7c8b05">g1</a>, SpMat <a class="el" href="#ae1be0d6e322a26924b67b6258cf55b08">g2</a>, SpMat <a class="el" href="#ac59ad0f384dc3d3f73c6f340aaac2996">g3</a>, SpMat <a class="el" href="#a06391c3ed3d8368da520d465cc909bc0">M0</a>, SpMat <a class="el" href="#af97e49a98f2a9f390abb52cdaf998577">M1</a>, SpMat <a class="el" href="#a93e3e540d2f3d3cd343f9a66867ec03a">M2</a>, Vect theta_prior, string solver_type, const bool <a class="el" href="#adc24faaa8937de8de88dde11fa9020f7">constr</a>, const MatrixXd <a class="el" href="#af80d7b7e847c30706a826a1c6d7c2fc1">Dx</a>, const MatrixXd <a class="el" href="#a5a765bc4a434d2c4926b7c035984dd66">Dxy</a>, const bool validate, const Vect w)</td></tr>
<tr class="memdesc:a35269dd8407ce1c126a4b87a31b7a310"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for spatial temporal model.  <br /></td></tr>
<tr class="separator:a35269dd8407ce1c126a4b87a31b7a310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c031e4b1773db975d3038ac01b0977" id="r_a42c031e4b1773db975d3038ac01b0977"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42c031e4b1773db975d3038ac01b0977">operator()</a> (Vect &amp;theta, Vect &amp;grad)</td></tr>
<tr class="memdesc:a42c031e4b1773db975d3038ac01b0977"><td class="mdescLeft">&#160;</td><td class="mdescRight">structure required by <a class="el" href="classBFGS.html">BFGS</a> solver, requires : theta, gradient theta  <br /></td></tr>
<tr class="separator:a42c031e4b1773db975d3038ac01b0977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a7918139c515f19f4663057ca3e5cc" id="r_a33a7918139c515f19f4663057ca3e5cc"><td class="memItemLeft" align="right" valign="top"><a id="a33a7918139c515f19f4663057ca3e5cc" name="a33a7918139c515f19f4663057ca3e5cc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>computeG</b> (Vect &amp;theta)</td></tr>
<tr class="memdesc:a33a7918139c515f19f4663057ca3e5cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">overwriting G every time, not explicitly listed, better way to do this? needs to be stored after every iteration for smart hessian ... <br  />
 <br /></td></tr>
<tr class="separator:a33a7918139c515f19f4663057ca3e5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc197a1ae82c5265a0a465c4cfa2727" id="r_a4fc197a1ae82c5265a0a465c4cfa2727"><td class="memItemLeft" align="right" valign="top"><a id="a4fc197a1ae82c5265a0a465c4cfa2727" name="a4fc197a1ae82c5265a0a465c4cfa2727"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>get_fct_count</b> ()</td></tr>
<tr class="separator:a4fc197a1ae82c5265a0a465c4cfa2727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfdc66118e93525b7814f53c6b50e652" id="r_adfdc66118e93525b7814f53c6b50e652"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfdc66118e93525b7814f53c6b50e652">convert_theta2interpret</a> (double lgamE, double lgamS, double lgamT, double &amp;sigU, double &amp;ranS, double &amp;ranT)</td></tr>
<tr class="memdesc:adfdc66118e93525b7814f53c6b50e652"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert hyperparameters theta from the model parametrisation to the interpretable parametrisation ie. from log(gamma_E, gamma_s, gamma_t) to log(sigma.u, rangeS, rangeT)  <br /></td></tr>
<tr class="separator:adfdc66118e93525b7814f53c6b50e652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada9c36637820d3eaad19d4b3449c98ad" id="r_ada9c36637820d3eaad19d4b3449c98ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada9c36637820d3eaad19d4b3449c98ad">convert_interpret2theta</a> (double sigU, double ranS, double ranT, double &amp;lgamE, double &amp;lgamS, double &amp;lgamT)</td></tr>
<tr class="memdesc:ada9c36637820d3eaad19d4b3449c98ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert hyperparameters theta from the interpretable parametrisation to the model parametrisation ie. from log(sigma.u, rangeS, rangeT) to log(gamma_E, gamma_s, gamma_t)  <br /></td></tr>
<tr class="separator:ada9c36637820d3eaad19d4b3449c98ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0f3a13e200dc7833ad7297dc67d0b9" id="r_aff0f3a13e200dc7833ad7297dc67d0b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff0f3a13e200dc7833ad7297dc67d0b9">get_mu</a> (Vect &amp;theta, Vect &amp;<a class="el" href="#aa6d3402de41235b5226e1e93be4a9dbe">mu</a>)</td></tr>
<tr class="memdesc:aff0f3a13e200dc7833ad7297dc67d0b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">get conditional mean mu for theta.  <br /></td></tr>
<tr class="separator:aff0f3a13e200dc7833ad7297dc67d0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b59d9c23fb21cf517f281ae48ac970d" id="r_a6b59d9c23fb21cf517f281ae48ac970d"><td class="memItemLeft" align="right" valign="top">Vect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b59d9c23fb21cf517f281ae48ac970d">get_grad</a> ()</td></tr>
<tr class="memdesc:a6b59d9c23fb21cf517f281ae48ac970d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns current gradient of theta.  <br /></td></tr>
<tr class="separator:a6b59d9c23fb21cf517f281ae48ac970d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb8efdc44447d6224893f6debf29540" id="r_a9eb8efdc44447d6224893f6debf29540"><td class="memItemLeft" align="right" valign="top">MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9eb8efdc44447d6224893f6debf29540">get_Covariance</a> (Vect &amp;theta, double eps)</td></tr>
<tr class="memdesc:a9eb8efdc44447d6224893f6debf29540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute Covariance matrix of hyperparameters theta, at theta.  <br /></td></tr>
<tr class="separator:a9eb8efdc44447d6224893f6debf29540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2589db16c7d4784189d003016d99cf89" id="r_a2589db16c7d4784189d003016d99cf89"><td class="memItemLeft" align="right" valign="top"><a id="a2589db16c7d4784189d003016d99cf89" name="a2589db16c7d4784189d003016d99cf89"></a>
MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><b>get_Cov_interpret_param</b> (Vect &amp;interpret_theta, double eps)</td></tr>
<tr class="separator:a2589db16c7d4784189d003016d99cf89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52398b5f03001d24a9bd69d02e7c9773" id="r_a52398b5f03001d24a9bd69d02e7c9773"><td class="memItemLeft" align="right" valign="top"><a id="a52398b5f03001d24a9bd69d02e7c9773" name="a52398b5f03001d24a9bd69d02e7c9773"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>f_eval</b> (Vect &amp;theta)</td></tr>
<tr class="separator:a52398b5f03001d24a9bd69d02e7c9773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d01ba1dcfedc1e9b250586c0f6ab98" id="r_ab6d01ba1dcfedc1e9b250586c0f6ab98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6d01ba1dcfedc1e9b250586c0f6ab98">get_marginals_f</a> (Vect &amp;theta, Vect &amp;vars)</td></tr>
<tr class="memdesc:ab6d01ba1dcfedc1e9b250586c0f6ab98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the marginal variances of the latent parameters at theta. Using selected inversion procedure.  <br /></td></tr>
<tr class="separator:ab6d01ba1dcfedc1e9b250586c0f6ab98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba126f6b1bc95b8815465debaedd650" id="r_a8ba126f6b1bc95b8815465debaedd650"><td class="memItemLeft" align="right" valign="top">MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ba126f6b1bc95b8815465debaedd650">hess_eval</a> (Vect &amp;theta, double eps)</td></tr>
<tr class="memdesc:a8ba126f6b1bc95b8815465debaedd650"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the hessian at theta using second order finite difference. Is used be get_Covariance.  <br /></td></tr>
<tr class="separator:a8ba126f6b1bc95b8815465debaedd650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67ecf629a6a81db6966614517acfbbb" id="r_ae67ecf629a6a81db6966614517acfbbb"><td class="memItemLeft" align="right" valign="top"><a id="ae67ecf629a6a81db6966614517acfbbb" name="ae67ecf629a6a81db6966614517acfbbb"></a>
MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><b>hess_eval_interpret_theta</b> (Vect &amp;interpret_theta, double eps)</td></tr>
<tr class="separator:ae67ecf629a6a81db6966614517acfbbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240a43fde6a2e26c30275b24f99f5d4e" id="r_a240a43fde6a2e26c30275b24f99f5d4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a240a43fde6a2e26c30275b24f99f5d4e">check_pos_def</a> (MatrixXd &amp;hess)</td></tr>
<tr class="memdesc:a240a43fde6a2e26c30275b24f99f5d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if Hessian positive definite (matrix assumed to be dense &amp; small since dim(theta) small)  <br /></td></tr>
<tr class="separator:a240a43fde6a2e26c30275b24f99f5d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a437a6716c8fe32396f0643f3dba43e5b" id="r_a437a6716c8fe32396f0643f3dba43e5b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a437a6716c8fe32396f0643f3dba43e5b">eval_post_theta</a> (Vect &amp;theta, Vect &amp;<a class="el" href="#aa6d3402de41235b5226e1e93be4a9dbe">mu</a>)</td></tr>
<tr class="memdesc:a437a6716c8fe32396f0643f3dba43e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Core function. Evaluate posterior of theta. mu are latent parameters.  <br /></td></tr>
<tr class="separator:a437a6716c8fe32396f0643f3dba43e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52137ac2ce65806e9b9e99177adecd33" id="r_a52137ac2ce65806e9b9e99177adecd33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52137ac2ce65806e9b9e99177adecd33">eval_log_gaussian_prior_hp</a> (double &amp;log_prior, double *thetai, double *thetai_original)</td></tr>
<tr class="memdesc:a52137ac2ce65806e9b9e99177adecd33"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate log prior of the hyperparameters using original theta value  <br /></td></tr>
<tr class="separator:a52137ac2ce65806e9b9e99177adecd33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f7a4987eeb15a84b1af7c784c3b6ff" id="r_a66f7a4987eeb15a84b1af7c784c3b6ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66f7a4987eeb15a84b1af7c784c3b6ff">eval_log_pc_prior_hp</a> (double &amp;log_sum, Vect &amp;lambda, Vect &amp;theta_interpret)</td></tr>
<tr class="memdesc:a66f7a4987eeb15a84b1af7c784c3b6ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate log prior using PC prior  <br /></td></tr>
<tr class="separator:a66f7a4987eeb15a84b1af7c784c3b6ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a1b9ac95394ba1992ed25b4b34e128" id="r_a79a1b9ac95394ba1992ed25b4b34e128"><td class="memItemLeft" align="right" valign="top"><a id="a79a1b9ac95394ba1992ed25b4b34e128" name="a79a1b9ac95394ba1992ed25b4b34e128"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>update_mean_constr</b> (const MatrixXd &amp;D, Vect &amp;e, Vect &amp;sol, MatrixXd &amp;V, MatrixXd &amp;W, MatrixXd &amp;U, Vect &amp;updated_sol)</td></tr>
<tr class="separator:a79a1b9ac95394ba1992ed25b4b34e128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4973d0c8335220faafa3bdb2fcfeb331" id="r_a4973d0c8335220faafa3bdb2fcfeb331"><td class="memItemLeft" align="right" valign="top"><a id="a4973d0c8335220faafa3bdb2fcfeb331" name="a4973d0c8335220faafa3bdb2fcfeb331"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>eval_log_dens_constr</b> (Vect &amp;x, Vect &amp;<a class="el" href="#aa6d3402de41235b5226e1e93be4a9dbe">mu</a>, SpMat &amp;Q, double &amp;log_det_Q, const MatrixXd &amp;D, MatrixXd &amp;W, double &amp;val_log_dens)</td></tr>
<tr class="separator:a4973d0c8335220faafa3bdb2fcfeb331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a981439fd52c6b46c1666fd45eb5faa92" id="r_a981439fd52c6b46c1666fd45eb5faa92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a981439fd52c6b46c1666fd45eb5faa92">eval_log_prior_lat</a> (Vect &amp;theta, double &amp;val)</td></tr>
<tr class="memdesc:a981439fd52c6b46c1666fd45eb5faa92"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate log prior of random effects  <br /></td></tr>
<tr class="separator:a981439fd52c6b46c1666fd45eb5faa92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97173a441c0f2f6b9dc2a5fe85e1d6ad" id="r_a97173a441c0f2f6b9dc2a5fe85e1d6ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97173a441c0f2f6b9dc2a5fe85e1d6ad">eval_likelihood</a> (Vect &amp;theta, double &amp;log_det, double &amp;val)</td></tr>
<tr class="memdesc:a97173a441c0f2f6b9dc2a5fe85e1d6ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute log likelihood : log_det tau*no and value -theta*yTy  <br /></td></tr>
<tr class="separator:a97173a441c0f2f6b9dc2a5fe85e1d6ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ceec7e512bf71ca7267f01733ec8719" id="r_a2ceec7e512bf71ca7267f01733ec8719"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ceec7e512bf71ca7267f01733ec8719">construct_Q_spatial</a> (Vect &amp;theta, SpMat &amp;Qs)</td></tr>
<tr class="memdesc:a2ceec7e512bf71ca7267f01733ec8719"><td class="mdescLeft">&#160;</td><td class="mdescRight">spatial model : SPDE discretisation &ndash; matrix construction  <br /></td></tr>
<tr class="separator:a2ceec7e512bf71ca7267f01733ec8719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41faf4a6b8b2a30168f35805c2c7b3f" id="r_ac41faf4a6b8b2a30168f35805c2c7b3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac41faf4a6b8b2a30168f35805c2c7b3f">construct_Q_spat_temp</a> (Vect &amp;theta, SpMat &amp;Qst)</td></tr>
<tr class="memdesc:ac41faf4a6b8b2a30168f35805c2c7b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">spatial temporal model : SPDE discretisation. DEMF(1,2,1) model.  <br /></td></tr>
<tr class="separator:ac41faf4a6b8b2a30168f35805c2c7b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb642337f6f4db477be2318bb9796f2c" id="r_acb642337f6f4db477be2318bb9796f2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb642337f6f4db477be2318bb9796f2c">construct_Q</a> (Vect &amp;theta, SpMat &amp;Q)</td></tr>
<tr class="memdesc:acb642337f6f4db477be2318bb9796f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct precision matrix. Calls spatial, spatial-temporal, etc.  <br /></td></tr>
<tr class="separator:acb642337f6f4db477be2318bb9796f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69559f2f98cbdd4b844a9e0c571d64d" id="r_af69559f2f98cbdd4b844a9e0c571d64d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af69559f2f98cbdd4b844a9e0c571d64d">construct_b</a> (Vect &amp;theta, Vect &amp;rhs)</td></tr>
<tr class="memdesc:af69559f2f98cbdd4b844a9e0c571d64d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble right-handside.  <br /></td></tr>
<tr class="separator:af69559f2f98cbdd4b844a9e0c571d64d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af7519622a314b59a75f5b84f15ad9a" id="r_a5af7519622a314b59a75f5b84f15ad9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5af7519622a314b59a75f5b84f15ad9a">eval_denominator</a> (Vect &amp;theta, double &amp;val, SpMat &amp;Q, Vect &amp;rhs, Vect &amp;<a class="el" href="#aa6d3402de41235b5226e1e93be4a9dbe">mu</a>)</td></tr>
<tr class="memdesc:a5af7519622a314b59a75f5b84f15ad9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate denominator: conditional probability of Qx|y.  <br /></td></tr>
<tr class="separator:a5af7519622a314b59a75f5b84f15ad9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d7a18584db9aace5d217437bdfe84fa" id="r_a3d7a18584db9aace5d217437bdfe84fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d7a18584db9aace5d217437bdfe84fa">eval_gradient</a> (Vect &amp;theta, double f_theta, Vect &amp;<a class="el" href="#aa6d3402de41235b5226e1e93be4a9dbe">mu</a>, Vect &amp;grad)</td></tr>
<tr class="memdesc:a3d7a18584db9aace5d217437bdfe84fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute gradient using central finite difference stencil. Parallelised with OpenMP.  <br /></td></tr>
<tr class="separator:a3d7a18584db9aace5d217437bdfe84fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f05821cf3af095b3a9fa66919266bf" id="r_a29f05821cf3af095b3a9fa66919266bf"><td class="memItemLeft" align="right" valign="top"><a id="a29f05821cf3af095b3a9fa66919266bf" name="a29f05821cf3af095b3a9fa66919266bf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>record_times</b> (std::string file_name, int <a class="el" href="#a6f35b1d4e2eb881fd0b8513571874bc0">iter_count</a>, double t_Ftheta_ext, double t_thread_nom, double t_priorHyp, double t_priorLat, double t_priorLatAMat, double t_priorLatChol, double t_likel, double t_thread_denom, double t_condLat, double t_condLatAMat, double t_condLatChol, double t_condLatSolve)</td></tr>
<tr class="separator:a29f05821cf3af095b3a9fa66919266bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d5640ff12bb9e2828559153c61f352" id="r_a72d5640ff12bb9e2828559153c61f352"><td class="memItemLeft" align="right" valign="top"><a id="a72d5640ff12bb9e2828559153c61f352" name="a72d5640ff12bb9e2828559153c61f352"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~PostTheta</b> ()</td></tr>
<tr class="memdesc:a72d5640ff12bb9e2828559153c61f352"><td class="mdescLeft">&#160;</td><td class="mdescRight">class destructor. Frees memory allocated by <a class="el" href="classPostTheta.html" title="Computes the Posterior of the hyperparameters theta.">PostTheta</a> class. <br /></td></tr>
<tr class="separator:a72d5640ff12bb9e2828559153c61f352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa96db3d2446282e94d53716f195a223b" id="r_aa96db3d2446282e94d53716f195a223b"><td class="memItemLeft" align="right" valign="top"><a id="aa96db3d2446282e94d53716f195a223b" name="aa96db3d2446282e94d53716f195a223b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PostTheta</b> (int n_)</td></tr>
<tr class="separator:aa96db3d2446282e94d53716f195a223b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23c5141e44b8b33c1faa3ad3f967cde6" id="r_a23c5141e44b8b33c1faa3ad3f967cde6"><td class="memItemLeft" align="right" valign="top"><a id="a23c5141e44b8b33c1faa3ad3f967cde6" name="a23c5141e44b8b33c1faa3ad3f967cde6"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>combined_eval</b> (Vect theta)</td></tr>
<tr class="separator:a23c5141e44b8b33c1faa3ad3f967cde6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a551967536a31396160e314649cf556ef" id="r_a551967536a31396160e314649cf556ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a551967536a31396160e314649cf556ef">PostTheta</a> (int <a class="el" href="#a4def6d3a66d18ebb36f3db4e533626f6">ns</a>, int <a class="el" href="#ac84bd657538bc782335e992055a0817e">nt</a>, int <a class="el" href="#a90f7a7de632412bd9017e33a594105f4">nb</a>, int <a class="el" href="#aec066996693ada57084aa1ee52f04948">no</a>, MatrixXd <a class="el" href="#acc70e6f2659235075873ecee40a126cf">B</a>, Vect <a class="el" href="#a762b11a93e586f00ded70b7776e075ad">y</a>, Vect theta_prior, string solver_type)</td></tr>
<tr class="memdesc:a551967536a31396160e314649cf556ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for regression model (no random effects).  <br /></td></tr>
<tr class="separator:a551967536a31396160e314649cf556ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80340f484eb074f13ea56fff84370ba2" id="r_a80340f484eb074f13ea56fff84370ba2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80340f484eb074f13ea56fff84370ba2">PostTheta</a> (int <a class="el" href="#a4def6d3a66d18ebb36f3db4e533626f6">ns</a>, int <a class="el" href="#ac84bd657538bc782335e992055a0817e">nt</a>, int <a class="el" href="#a90f7a7de632412bd9017e33a594105f4">nb</a>, int <a class="el" href="#aec066996693ada57084aa1ee52f04948">no</a>, SpMat <a class="el" href="#a87a3adb6b92056e8dacea22fa894300a">Ax</a>, Vect <a class="el" href="#a762b11a93e586f00ded70b7776e075ad">y</a>, SpMat <a class="el" href="#a71833a89a8c3dc58117eb467feac7674">c0</a>, SpMat <a class="el" href="#ade2defef59b9295d794620fefb7c8b05">g1</a>, SpMat <a class="el" href="#ae1be0d6e322a26924b67b6258cf55b08">g2</a>, Vect theta_prior, string solver_type)</td></tr>
<tr class="memdesc:a80340f484eb074f13ea56fff84370ba2"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for spatial model (order 2).  <br /></td></tr>
<tr class="separator:a80340f484eb074f13ea56fff84370ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a92e72eb66d3adcbecae4e133a4482" id="r_a79a92e72eb66d3adcbecae4e133a4482"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79a92e72eb66d3adcbecae4e133a4482">PostTheta</a> (int <a class="el" href="#a4def6d3a66d18ebb36f3db4e533626f6">ns</a>, int <a class="el" href="#ac84bd657538bc782335e992055a0817e">nt</a>, int <a class="el" href="#a90f7a7de632412bd9017e33a594105f4">nb</a>, int <a class="el" href="#aec066996693ada57084aa1ee52f04948">no</a>, SpMat <a class="el" href="#a87a3adb6b92056e8dacea22fa894300a">Ax</a>, Vect <a class="el" href="#a762b11a93e586f00ded70b7776e075ad">y</a>, SpMat <a class="el" href="#a71833a89a8c3dc58117eb467feac7674">c0</a>, SpMat <a class="el" href="#ade2defef59b9295d794620fefb7c8b05">g1</a>, SpMat <a class="el" href="#ae1be0d6e322a26924b67b6258cf55b08">g2</a>, SpMat <a class="el" href="#ac59ad0f384dc3d3f73c6f340aaac2996">g3</a>, SpMat <a class="el" href="#a06391c3ed3d8368da520d465cc909bc0">M0</a>, SpMat <a class="el" href="#af97e49a98f2a9f390abb52cdaf998577">M1</a>, SpMat <a class="el" href="#a93e3e540d2f3d3cd343f9a66867ec03a">M2</a>, Vect theta_prior, string solver_type)</td></tr>
<tr class="memdesc:a79a92e72eb66d3adcbecae4e133a4482"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for spatial temporal model.  <br /></td></tr>
<tr class="separator:a79a92e72eb66d3adcbecae4e133a4482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c031e4b1773db975d3038ac01b0977" id="r_a42c031e4b1773db975d3038ac01b0977"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42c031e4b1773db975d3038ac01b0977">operator()</a> (Vect &amp;theta, Vect &amp;grad)</td></tr>
<tr class="memdesc:a42c031e4b1773db975d3038ac01b0977"><td class="mdescLeft">&#160;</td><td class="mdescRight">structure required by <a class="el" href="classBFGS.html">BFGS</a> solver, requires : theta, gradient theta  <br /></td></tr>
<tr class="separator:a42c031e4b1773db975d3038ac01b0977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fc197a1ae82c5265a0a465c4cfa2727" id="r_a4fc197a1ae82c5265a0a465c4cfa2727"><td class="memItemLeft" align="right" valign="top"><a id="a4fc197a1ae82c5265a0a465c4cfa2727" name="a4fc197a1ae82c5265a0a465c4cfa2727"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>get_fct_count</b> ()</td></tr>
<tr class="separator:a4fc197a1ae82c5265a0a465c4cfa2727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfdc66118e93525b7814f53c6b50e652" id="r_adfdc66118e93525b7814f53c6b50e652"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfdc66118e93525b7814f53c6b50e652">convert_theta2interpret</a> (double lgamE, double lgamS, double lgamT, double &amp;sigU, double &amp;ranS, double &amp;ranT)</td></tr>
<tr class="memdesc:adfdc66118e93525b7814f53c6b50e652"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert hyperparameters theta from the model parametrisation to the interpretable parametrisation ie. from log(gamma_E, gamma_s, gamma_t) to log(sigma.u, rangeS, rangeT)  <br /></td></tr>
<tr class="separator:adfdc66118e93525b7814f53c6b50e652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada9c36637820d3eaad19d4b3449c98ad" id="r_ada9c36637820d3eaad19d4b3449c98ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada9c36637820d3eaad19d4b3449c98ad">convert_interpret2theta</a> (double sigU, double ranS, double ranT, double &amp;lgamE, double &amp;lgamS, double &amp;lgamT)</td></tr>
<tr class="memdesc:ada9c36637820d3eaad19d4b3449c98ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert hyperparameters theta from the interpretable parametrisation to the model parametrisation ie. from log(sigma.u, rangeS, rangeT) to log(gamma_E, gamma_s, gamma_t)  <br /></td></tr>
<tr class="separator:ada9c36637820d3eaad19d4b3449c98ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0f3a13e200dc7833ad7297dc67d0b9" id="r_aff0f3a13e200dc7833ad7297dc67d0b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff0f3a13e200dc7833ad7297dc67d0b9">get_mu</a> (Vect &amp;theta, Vect &amp;<a class="el" href="#aa6d3402de41235b5226e1e93be4a9dbe">mu</a>)</td></tr>
<tr class="memdesc:aff0f3a13e200dc7833ad7297dc67d0b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">get conditional mean mu for theta.  <br /></td></tr>
<tr class="separator:aff0f3a13e200dc7833ad7297dc67d0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b59d9c23fb21cf517f281ae48ac970d" id="r_a6b59d9c23fb21cf517f281ae48ac970d"><td class="memItemLeft" align="right" valign="top">Vect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b59d9c23fb21cf517f281ae48ac970d">get_grad</a> ()</td></tr>
<tr class="memdesc:a6b59d9c23fb21cf517f281ae48ac970d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns current gradient of theta.  <br /></td></tr>
<tr class="separator:a6b59d9c23fb21cf517f281ae48ac970d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb8efdc44447d6224893f6debf29540" id="r_a9eb8efdc44447d6224893f6debf29540"><td class="memItemLeft" align="right" valign="top">MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9eb8efdc44447d6224893f6debf29540">get_Covariance</a> (Vect &amp;theta, double eps)</td></tr>
<tr class="memdesc:a9eb8efdc44447d6224893f6debf29540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute Covariance matrix of hyperparameters theta, at theta.  <br /></td></tr>
<tr class="separator:a9eb8efdc44447d6224893f6debf29540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2589db16c7d4784189d003016d99cf89" id="r_a2589db16c7d4784189d003016d99cf89"><td class="memItemLeft" align="right" valign="top"><a id="a2589db16c7d4784189d003016d99cf89" name="a2589db16c7d4784189d003016d99cf89"></a>
MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><b>get_Cov_interpret_param</b> (Vect &amp;interpret_theta, double eps)</td></tr>
<tr class="separator:a2589db16c7d4784189d003016d99cf89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52398b5f03001d24a9bd69d02e7c9773" id="r_a52398b5f03001d24a9bd69d02e7c9773"><td class="memItemLeft" align="right" valign="top"><a id="a52398b5f03001d24a9bd69d02e7c9773" name="a52398b5f03001d24a9bd69d02e7c9773"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>f_eval</b> (Vect &amp;theta)</td></tr>
<tr class="separator:a52398b5f03001d24a9bd69d02e7c9773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d01ba1dcfedc1e9b250586c0f6ab98" id="r_ab6d01ba1dcfedc1e9b250586c0f6ab98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6d01ba1dcfedc1e9b250586c0f6ab98">get_marginals_f</a> (Vect &amp;theta, Vect &amp;vars)</td></tr>
<tr class="memdesc:ab6d01ba1dcfedc1e9b250586c0f6ab98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the marginal variances of the latent parameters at theta. Using selected inversion procedure.  <br /></td></tr>
<tr class="separator:ab6d01ba1dcfedc1e9b250586c0f6ab98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba126f6b1bc95b8815465debaedd650" id="r_a8ba126f6b1bc95b8815465debaedd650"><td class="memItemLeft" align="right" valign="top">MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ba126f6b1bc95b8815465debaedd650">hess_eval</a> (Vect &amp;theta, double eps)</td></tr>
<tr class="memdesc:a8ba126f6b1bc95b8815465debaedd650"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the hessian at theta using second order finite difference. Is used be get_Covariance.  <br /></td></tr>
<tr class="separator:a8ba126f6b1bc95b8815465debaedd650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67ecf629a6a81db6966614517acfbbb" id="r_ae67ecf629a6a81db6966614517acfbbb"><td class="memItemLeft" align="right" valign="top"><a id="ae67ecf629a6a81db6966614517acfbbb" name="ae67ecf629a6a81db6966614517acfbbb"></a>
MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><b>hess_eval_interpret_theta</b> (Vect &amp;interpret_theta, double eps)</td></tr>
<tr class="separator:ae67ecf629a6a81db6966614517acfbbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240a43fde6a2e26c30275b24f99f5d4e" id="r_a240a43fde6a2e26c30275b24f99f5d4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a240a43fde6a2e26c30275b24f99f5d4e">check_pos_def</a> (MatrixXd &amp;hess)</td></tr>
<tr class="memdesc:a240a43fde6a2e26c30275b24f99f5d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if Hessian positive definite (matrix assumed to be dense &amp; small since dim(theta) small)  <br /></td></tr>
<tr class="separator:a240a43fde6a2e26c30275b24f99f5d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a437a6716c8fe32396f0643f3dba43e5b" id="r_a437a6716c8fe32396f0643f3dba43e5b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a437a6716c8fe32396f0643f3dba43e5b">eval_post_theta</a> (Vect &amp;theta, Vect &amp;<a class="el" href="#aa6d3402de41235b5226e1e93be4a9dbe">mu</a>)</td></tr>
<tr class="memdesc:a437a6716c8fe32396f0643f3dba43e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Core function. Evaluate posterior of theta. mu are latent parameters.  <br /></td></tr>
<tr class="separator:a437a6716c8fe32396f0643f3dba43e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac28f2fbb4caa4b566efa484e35a2c09b" id="r_ac28f2fbb4caa4b566efa484e35a2c09b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac28f2fbb4caa4b566efa484e35a2c09b">eval_log_gaussian_prior</a> (double &amp;log_prior, double *thetai, double *thetai_original)</td></tr>
<tr class="memdesc:ac28f2fbb4caa4b566efa484e35a2c09b"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate log prior using original theta value  <br /></td></tr>
<tr class="separator:ac28f2fbb4caa4b566efa484e35a2c09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a720770da5ee996c77937a3fe3753743d" id="r_a720770da5ee996c77937a3fe3753743d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a720770da5ee996c77937a3fe3753743d">eval_log_pc_prior</a> (double &amp;log_sum, Vect &amp;lambda, Vect &amp;theta_interpret)</td></tr>
<tr class="memdesc:a720770da5ee996c77937a3fe3753743d"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate log prior using PC prior  <br /></td></tr>
<tr class="separator:a720770da5ee996c77937a3fe3753743d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23229109b6bfb9eefbe605b872fc8870" id="r_a23229109b6bfb9eefbe605b872fc8870"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23229109b6bfb9eefbe605b872fc8870">eval_log_det_Qu</a> (Vect &amp;theta, double &amp;log_det)</td></tr>
<tr class="memdesc:a23229109b6bfb9eefbe605b872fc8870"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate log prior of random effects  <br /></td></tr>
<tr class="separator:a23229109b6bfb9eefbe605b872fc8870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97173a441c0f2f6b9dc2a5fe85e1d6ad" id="r_a97173a441c0f2f6b9dc2a5fe85e1d6ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97173a441c0f2f6b9dc2a5fe85e1d6ad">eval_likelihood</a> (Vect &amp;theta, double &amp;log_det, double &amp;val)</td></tr>
<tr class="memdesc:a97173a441c0f2f6b9dc2a5fe85e1d6ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute log likelihood : log_det tau*no and value -theta*yTy  <br /></td></tr>
<tr class="separator:a97173a441c0f2f6b9dc2a5fe85e1d6ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ceec7e512bf71ca7267f01733ec8719" id="r_a2ceec7e512bf71ca7267f01733ec8719"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ceec7e512bf71ca7267f01733ec8719">construct_Q_spatial</a> (Vect &amp;theta, SpMat &amp;Qs)</td></tr>
<tr class="memdesc:a2ceec7e512bf71ca7267f01733ec8719"><td class="mdescLeft">&#160;</td><td class="mdescRight">spatial model : SPDE discretisation &ndash; matrix construction  <br /></td></tr>
<tr class="separator:a2ceec7e512bf71ca7267f01733ec8719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41faf4a6b8b2a30168f35805c2c7b3f" id="r_ac41faf4a6b8b2a30168f35805c2c7b3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac41faf4a6b8b2a30168f35805c2c7b3f">construct_Q_spat_temp</a> (Vect &amp;theta, SpMat &amp;Qst)</td></tr>
<tr class="memdesc:ac41faf4a6b8b2a30168f35805c2c7b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">spatial temporal model : SPDE discretisation. DEMF(1,2,1) model.  <br /></td></tr>
<tr class="separator:ac41faf4a6b8b2a30168f35805c2c7b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb642337f6f4db477be2318bb9796f2c" id="r_acb642337f6f4db477be2318bb9796f2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb642337f6f4db477be2318bb9796f2c">construct_Q</a> (Vect &amp;theta, SpMat &amp;Q)</td></tr>
<tr class="memdesc:acb642337f6f4db477be2318bb9796f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct precision matrix. Calls spatial, spatial-temporal, etc.  <br /></td></tr>
<tr class="separator:acb642337f6f4db477be2318bb9796f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69559f2f98cbdd4b844a9e0c571d64d" id="r_af69559f2f98cbdd4b844a9e0c571d64d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af69559f2f98cbdd4b844a9e0c571d64d">construct_b</a> (Vect &amp;theta, Vect &amp;rhs)</td></tr>
<tr class="memdesc:af69559f2f98cbdd4b844a9e0c571d64d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assemble right-handside.  <br /></td></tr>
<tr class="separator:af69559f2f98cbdd4b844a9e0c571d64d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af839914f0f3e7d21387530be4d1d9420" id="r_af839914f0f3e7d21387530be4d1d9420"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af839914f0f3e7d21387530be4d1d9420">eval_denominator</a> (Vect &amp;theta, double &amp;log_det, double &amp;val, SpMat &amp;Q, Vect &amp;rhs, Vect &amp;<a class="el" href="#aa6d3402de41235b5226e1e93be4a9dbe">mu</a>)</td></tr>
<tr class="memdesc:af839914f0f3e7d21387530be4d1d9420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate denominator: conditional probability of Qx|y.  <br /></td></tr>
<tr class="separator:af839914f0f3e7d21387530be4d1d9420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d7a18584db9aace5d217437bdfe84fa" id="r_a3d7a18584db9aace5d217437bdfe84fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d7a18584db9aace5d217437bdfe84fa">eval_gradient</a> (Vect &amp;theta, double f_theta, Vect &amp;<a class="el" href="#aa6d3402de41235b5226e1e93be4a9dbe">mu</a>, Vect &amp;grad)</td></tr>
<tr class="memdesc:a3d7a18584db9aace5d217437bdfe84fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute gradient using central finite difference stencil. Parallelised with OpenMP.  <br /></td></tr>
<tr class="separator:a3d7a18584db9aace5d217437bdfe84fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d5640ff12bb9e2828559153c61f352" id="r_a72d5640ff12bb9e2828559153c61f352"><td class="memItemLeft" align="right" valign="top"><a id="a72d5640ff12bb9e2828559153c61f352" name="a72d5640ff12bb9e2828559153c61f352"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~PostTheta</b> ()</td></tr>
<tr class="memdesc:a72d5640ff12bb9e2828559153c61f352"><td class="mdescLeft">&#160;</td><td class="mdescRight">class destructor. Frees memory allocated by <a class="el" href="classPostTheta.html" title="Computes the Posterior of the hyperparameters theta.">PostTheta</a> class. <br /></td></tr>
<tr class="separator:a72d5640ff12bb9e2828559153c61f352"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a8050ac12b4eb6d0fe9b69a10f91d4aa2" id="r_a8050ac12b4eb6d0fe9b69a10f91d4aa2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8050ac12b4eb6d0fe9b69a10f91d4aa2">MPI_size</a></td></tr>
<tr class="separator:a8050ac12b4eb6d0fe9b69a10f91d4aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab87a9d6318c690344f749edb51638119" id="r_ab87a9d6318c690344f749edb51638119"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab87a9d6318c690344f749edb51638119">MPI_rank</a></td></tr>
<tr class="separator:ab87a9d6318c690344f749edb51638119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef6bc3ffd3a8170f5540673a842e772" id="r_a4ef6bc3ffd3a8170f5540673a842e772"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ef6bc3ffd3a8170f5540673a842e772">threads_level1</a></td></tr>
<tr class="separator:a4ef6bc3ffd3a8170f5540673a842e772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef3242e2a992ea45142cd2d2e3b7bbf8" id="r_aef3242e2a992ea45142cd2d2e3b7bbf8"><td class="memItemLeft" align="right" valign="top"><a id="aef3242e2a992ea45142cd2d2e3b7bbf8" name="aef3242e2a992ea45142cd2d2e3b7bbf8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>threads_level2</b></td></tr>
<tr class="separator:aef3242e2a992ea45142cd2d2e3b7bbf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4def6d3a66d18ebb36f3db4e533626f6" id="r_a4def6d3a66d18ebb36f3db4e533626f6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4def6d3a66d18ebb36f3db4e533626f6">ns</a></td></tr>
<tr class="separator:a4def6d3a66d18ebb36f3db4e533626f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84bd657538bc782335e992055a0817e" id="r_ac84bd657538bc782335e992055a0817e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac84bd657538bc782335e992055a0817e">nt</a></td></tr>
<tr class="separator:ac84bd657538bc782335e992055a0817e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f7a7de632412bd9017e33a594105f4" id="r_a90f7a7de632412bd9017e33a594105f4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90f7a7de632412bd9017e33a594105f4">nb</a></td></tr>
<tr class="separator:a90f7a7de632412bd9017e33a594105f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec066996693ada57084aa1ee52f04948" id="r_aec066996693ada57084aa1ee52f04948"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec066996693ada57084aa1ee52f04948">no</a></td></tr>
<tr class="separator:aec066996693ada57084aa1ee52f04948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81d3526dcbbd78c65ac4a4cb86200d55" id="r_a81d3526dcbbd78c65ac4a4cb86200d55"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81d3526dcbbd78c65ac4a4cb86200d55">nu</a></td></tr>
<tr class="separator:a81d3526dcbbd78c65ac4a4cb86200d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fd5d5ebe2405083469c817c667c0ada" id="r_a1fd5d5ebe2405083469c817c667c0ada"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1fd5d5ebe2405083469c817c667c0ada">n</a></td></tr>
<tr class="separator:a1fd5d5ebe2405083469c817c667c0ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd9b90c897f00da9792dbfda210ac2b" id="r_a7cd9b90c897f00da9792dbfda210ac2b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7cd9b90c897f00da9792dbfda210ac2b">dim_th</a></td></tr>
<tr class="separator:a7cd9b90c897f00da9792dbfda210ac2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040086750ffc42de18082b4c8a82ac76" id="r_a040086750ffc42de18082b4c8a82ac76"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a040086750ffc42de18082b4c8a82ac76">dim_grad_loop</a></td></tr>
<tr class="separator:a040086750ffc42de18082b4c8a82ac76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca01706b37b53f6a888275557ee93712" id="r_aca01706b37b53f6a888275557ee93712"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca01706b37b53f6a888275557ee93712">num_solvers</a></td></tr>
<tr class="separator:aca01706b37b53f6a888275557ee93712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e9615048d607a18c09aec8037dc265" id="r_a47e9615048d607a18c09aec8037dc265"><td class="memItemLeft" align="right" valign="top"><a id="a47e9615048d607a18c09aec8037dc265" name="a47e9615048d607a18c09aec8037dc265"></a>
<a class="el" href="classSolver.html">Solver</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>solverQ</b></td></tr>
<tr class="separator:a47e9615048d607a18c09aec8037dc265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3580a7313d51d4f2a13c49f2e496967c" id="r_a3580a7313d51d4f2a13c49f2e496967c"><td class="memItemLeft" align="right" valign="top"><a id="a3580a7313d51d4f2a13c49f2e496967c" name="a3580a7313d51d4f2a13c49f2e496967c"></a>
<a class="el" href="classSolver.html">Solver</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>solverQst</b></td></tr>
<tr class="separator:a3580a7313d51d4f2a13c49f2e496967c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35ca8db7078e93e6ef4ccc1103472cec" id="r_a35ca8db7078e93e6ef4ccc1103472cec"><td class="memItemLeft" align="right" valign="top"><a id="a35ca8db7078e93e6ef4ccc1103472cec" name="a35ca8db7078e93e6ef4ccc1103472cec"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><b>solver_type</b></td></tr>
<tr class="separator:a35ca8db7078e93e6ef4ccc1103472cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ddd0a6d8bcecd2e3d2eb94ac7cb765" id="r_ae2ddd0a6d8bcecd2e3d2eb94ac7cb765"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2ddd0a6d8bcecd2e3d2eb94ac7cb765">prior</a></td></tr>
<tr class="separator:ae2ddd0a6d8bcecd2e3d2eb94ac7cb765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf41f1b9e822c7ea3ea10bed6b6478ee" id="r_acf41f1b9e822c7ea3ea10bed6b6478ee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf41f1b9e822c7ea3ea10bed6b6478ee">fct_count</a></td></tr>
<tr class="separator:acf41f1b9e822c7ea3ea10bed6b6478ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f35b1d4e2eb881fd0b8513571874bc0" id="r_a6f35b1d4e2eb881fd0b8513571874bc0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f35b1d4e2eb881fd0b8513571874bc0">iter_count</a></td></tr>
<tr class="separator:a6f35b1d4e2eb881fd0b8513571874bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a762b11a93e586f00ded70b7776e075ad" id="r_a762b11a93e586f00ded70b7776e075ad"><td class="memItemLeft" align="right" valign="top">Vect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a762b11a93e586f00ded70b7776e075ad">y</a></td></tr>
<tr class="separator:a762b11a93e586f00ded70b7776e075ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c8a5c414b883fbc1b9566d38fa27f2d" id="r_a4c8a5c414b883fbc1b9566d38fa27f2d"><td class="memItemLeft" align="right" valign="top">Vect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c8a5c414b883fbc1b9566d38fa27f2d">theta_prior_param</a></td></tr>
<tr class="separator:a4c8a5c414b883fbc1b9566d38fa27f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a3adb6b92056e8dacea22fa894300a" id="r_a87a3adb6b92056e8dacea22fa894300a"><td class="memItemLeft" align="right" valign="top">SpMat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87a3adb6b92056e8dacea22fa894300a">Ax</a></td></tr>
<tr class="separator:a87a3adb6b92056e8dacea22fa894300a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc70e6f2659235075873ecee40a126cf" id="r_acc70e6f2659235075873ecee40a126cf"><td class="memItemLeft" align="right" valign="top">MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc70e6f2659235075873ecee40a126cf">B</a></td></tr>
<tr class="separator:acc70e6f2659235075873ecee40a126cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71833a89a8c3dc58117eb467feac7674" id="r_a71833a89a8c3dc58117eb467feac7674"><td class="memItemLeft" align="right" valign="top">SpMat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71833a89a8c3dc58117eb467feac7674">c0</a></td></tr>
<tr class="separator:a71833a89a8c3dc58117eb467feac7674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2defef59b9295d794620fefb7c8b05" id="r_ade2defef59b9295d794620fefb7c8b05"><td class="memItemLeft" align="right" valign="top">SpMat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade2defef59b9295d794620fefb7c8b05">g1</a></td></tr>
<tr class="separator:ade2defef59b9295d794620fefb7c8b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1be0d6e322a26924b67b6258cf55b08" id="r_ae1be0d6e322a26924b67b6258cf55b08"><td class="memItemLeft" align="right" valign="top">SpMat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1be0d6e322a26924b67b6258cf55b08">g2</a></td></tr>
<tr class="separator:ae1be0d6e322a26924b67b6258cf55b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59ad0f384dc3d3f73c6f340aaac2996" id="r_ac59ad0f384dc3d3f73c6f340aaac2996"><td class="memItemLeft" align="right" valign="top">SpMat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac59ad0f384dc3d3f73c6f340aaac2996">g3</a></td></tr>
<tr class="separator:ac59ad0f384dc3d3f73c6f340aaac2996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06391c3ed3d8368da520d465cc909bc0" id="r_a06391c3ed3d8368da520d465cc909bc0"><td class="memItemLeft" align="right" valign="top">SpMat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06391c3ed3d8368da520d465cc909bc0">M0</a></td></tr>
<tr class="separator:a06391c3ed3d8368da520d465cc909bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97e49a98f2a9f390abb52cdaf998577" id="r_af97e49a98f2a9f390abb52cdaf998577"><td class="memItemLeft" align="right" valign="top">SpMat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af97e49a98f2a9f390abb52cdaf998577">M1</a></td></tr>
<tr class="separator:af97e49a98f2a9f390abb52cdaf998577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e3e540d2f3d3cd343f9a66867ec03a" id="r_a93e3e540d2f3d3cd343f9a66867ec03a"><td class="memItemLeft" align="right" valign="top">SpMat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93e3e540d2f3d3cd343f9a66867ec03a">M2</a></td></tr>
<tr class="separator:a93e3e540d2f3d3cd343f9a66867ec03a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda145a9865b6216dfbd0178f2170a01" id="r_adda145a9865b6216dfbd0178f2170a01"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adda145a9865b6216dfbd0178f2170a01">yTy</a></td></tr>
<tr class="separator:adda145a9865b6216dfbd0178f2170a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac19fdbc5cba3bad224c75afee8682e0e" id="r_ac19fdbc5cba3bad224c75afee8682e0e"><td class="memItemLeft" align="right" valign="top">Vect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac19fdbc5cba3bad224c75afee8682e0e">BTy</a></td></tr>
<tr class="separator:ac19fdbc5cba3bad224c75afee8682e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72ecb0734ae1e5128bf5f92221ef3b19" id="r_a72ecb0734ae1e5128bf5f92221ef3b19"><td class="memItemLeft" align="right" valign="top">Vect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72ecb0734ae1e5128bf5f92221ef3b19">AxTy</a></td></tr>
<tr class="separator:a72ecb0734ae1e5128bf5f92221ef3b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a423fd45045112bcccaa7d7cc33028f20" id="r_a423fd45045112bcccaa7d7cc33028f20"><td class="memItemLeft" align="right" valign="top">SpMat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a423fd45045112bcccaa7d7cc33028f20">AxTAx</a></td></tr>
<tr class="separator:a423fd45045112bcccaa7d7cc33028f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d3402de41235b5226e1e93be4a9dbe" id="r_aa6d3402de41235b5226e1e93be4a9dbe"><td class="memItemLeft" align="right" valign="top">Vect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6d3402de41235b5226e1e93be4a9dbe">mu</a></td></tr>
<tr class="separator:aa6d3402de41235b5226e1e93be4a9dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa24f5936cd2425d668e97832018ab172" id="r_aa24f5936cd2425d668e97832018ab172"><td class="memItemLeft" align="right" valign="top">Vect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa24f5936cd2425d668e97832018ab172">t_grad</a></td></tr>
<tr class="separator:aa24f5936cd2425d668e97832018ab172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c397bdfb45cb31699067c615b541f23" id="r_a3c397bdfb45cb31699067c615b541f23"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c397bdfb45cb31699067c615b541f23">min_f_theta</a></td></tr>
<tr class="separator:a3c397bdfb45cb31699067c615b541f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a862ac0e774684eb73b44cedec925eea2" id="r_a862ac0e774684eb73b44cedec925eea2"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a862ac0e774684eb73b44cedec925eea2">w_sum</a></td></tr>
<tr class="separator:a862ac0e774684eb73b44cedec925eea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ded76f64306f25a537bbba24951a94" id="r_aa4ded76f64306f25a537bbba24951a94"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4ded76f64306f25a537bbba24951a94">no_f_eval</a></td></tr>
<tr class="separator:aa4ded76f64306f25a537bbba24951a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9fbf9c2513c00af4252fd56ac955d58" id="r_af9fbf9c2513c00af4252fd56ac955d58"><td class="memItemLeft" align="right" valign="top">MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9fbf9c2513c00af4252fd56ac955d58">G</a></td></tr>
<tr class="separator:af9fbf9c2513c00af4252fd56ac955d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc24faaa8937de8de88dde11fa9020f7" id="r_adc24faaa8937de8de88dde11fa9020f7"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc24faaa8937de8de88dde11fa9020f7">constr</a></td></tr>
<tr class="separator:adc24faaa8937de8de88dde11fa9020f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af80d7b7e847c30706a826a1c6d7c2fc1" id="r_af80d7b7e847c30706a826a1c6d7c2fc1"><td class="memItemLeft" align="right" valign="top">const MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af80d7b7e847c30706a826a1c6d7c2fc1">Dx</a></td></tr>
<tr class="separator:af80d7b7e847c30706a826a1c6d7c2fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a765bc4a434d2c4926b7c035984dd66" id="r_a5a765bc4a434d2c4926b7c035984dd66"><td class="memItemLeft" align="right" valign="top">const MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a765bc4a434d2c4926b7c035984dd66">Dxy</a></td></tr>
<tr class="separator:a5a765bc4a434d2c4926b7c035984dd66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc2ff34fdaa122e679c062e2f189e38" id="r_a8cc2ff34fdaa122e679c062e2f189e38"><td class="memItemLeft" align="right" valign="top"><a id="a8cc2ff34fdaa122e679c062e2f189e38" name="a8cc2ff34fdaa122e679c062e2f189e38"></a>
const bool&#160;</td><td class="memItemRight" valign="bottom"><b>validate</b></td></tr>
<tr class="separator:a8cc2ff34fdaa122e679c062e2f189e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09004098909b3af7601aaf815e2aed01" id="r_a09004098909b3af7601aaf815e2aed01"><td class="memItemLeft" align="right" valign="top"><a id="a09004098909b3af7601aaf815e2aed01" name="a09004098909b3af7601aaf815e2aed01"></a>
const Vect&#160;</td><td class="memItemRight" valign="bottom"><b>w</b></td></tr>
<tr class="separator:a09004098909b3af7601aaf815e2aed01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20907d1d1b9d4c6de7218867356b0daa" id="r_a20907d1d1b9d4c6de7218867356b0daa"><td class="memItemLeft" align="right" valign="top"><a id="a20907d1d1b9d4c6de7218867356b0daa" name="a20907d1d1b9d4c6de7218867356b0daa"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>printed_eps_flag</b> = false</td></tr>
<tr class="separator:a20907d1d1b9d4c6de7218867356b0daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b0bd3f8817717fa7c7a4d6f03208a39" id="r_a9b0bd3f8817717fa7c7a4d6f03208a39"><td class="memItemLeft" align="right" valign="top"><a id="a9b0bd3f8817717fa7c7a4d6f03208a39" name="a9b0bd3f8817717fa7c7a4d6f03208a39"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>log_file_name</b></td></tr>
<tr class="separator:a9b0bd3f8817717fa7c7a4d6f03208a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac731e60b069804c872c21c0069011490" id="r_ac731e60b069804c872c21c0069011490"><td class="memItemLeft" align="right" valign="top"><a id="ac731e60b069804c872c21c0069011490" name="ac731e60b069804c872c21c0069011490"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>t_Ftheta_ext</b></td></tr>
<tr class="separator:ac731e60b069804c872c21c0069011490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec022b1cd7859f10eeff63f44b2d1f8" id="r_aaec022b1cd7859f10eeff63f44b2d1f8"><td class="memItemLeft" align="right" valign="top"><a id="aaec022b1cd7859f10eeff63f44b2d1f8" name="aaec022b1cd7859f10eeff63f44b2d1f8"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>t_priorHyp</b></td></tr>
<tr class="separator:aaec022b1cd7859f10eeff63f44b2d1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe6f881ed640b998dbb8de17b777259" id="r_aebe6f881ed640b998dbb8de17b777259"><td class="memItemLeft" align="right" valign="top"><a id="aebe6f881ed640b998dbb8de17b777259" name="aebe6f881ed640b998dbb8de17b777259"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>t_priorLat</b></td></tr>
<tr class="separator:aebe6f881ed640b998dbb8de17b777259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc03b4e3cbb1f3361b6cb4aa6cb88948" id="r_afc03b4e3cbb1f3361b6cb4aa6cb88948"><td class="memItemLeft" align="right" valign="top"><a id="afc03b4e3cbb1f3361b6cb4aa6cb88948" name="afc03b4e3cbb1f3361b6cb4aa6cb88948"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>t_priorLatAMat</b></td></tr>
<tr class="separator:afc03b4e3cbb1f3361b6cb4aa6cb88948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6003fc075211769465e753561297ccf" id="r_ad6003fc075211769465e753561297ccf"><td class="memItemLeft" align="right" valign="top"><a id="ad6003fc075211769465e753561297ccf" name="ad6003fc075211769465e753561297ccf"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>t_likel</b></td></tr>
<tr class="separator:ad6003fc075211769465e753561297ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2309333b88f6fbbe403eea2a5585e145" id="r_a2309333b88f6fbbe403eea2a5585e145"><td class="memItemLeft" align="right" valign="top"><a id="a2309333b88f6fbbe403eea2a5585e145" name="a2309333b88f6fbbe403eea2a5585e145"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>t_condLat</b></td></tr>
<tr class="separator:a2309333b88f6fbbe403eea2a5585e145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf063c66561e54fce33af6565f41e7b" id="r_a1bf063c66561e54fce33af6565f41e7b"><td class="memItemLeft" align="right" valign="top"><a id="a1bf063c66561e54fce33af6565f41e7b" name="a1bf063c66561e54fce33af6565f41e7b"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>t_condLatAMat</b></td></tr>
<tr class="separator:a1bf063c66561e54fce33af6565f41e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac276db47a986bfcbdb44d319b8da5937" id="r_ac276db47a986bfcbdb44d319b8da5937"><td class="memItemLeft" align="right" valign="top"><a id="ac276db47a986bfcbdb44d319b8da5937" name="ac276db47a986bfcbdb44d319b8da5937"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>t_thread_nom</b></td></tr>
<tr class="separator:ac276db47a986bfcbdb44d319b8da5937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d4733a92b08d053f796972b028c3343" id="r_a2d4733a92b08d053f796972b028c3343"><td class="memItemLeft" align="right" valign="top"><a id="a2d4733a92b08d053f796972b028c3343" name="a2d4733a92b08d053f796972b028c3343"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>t_thread_denom</b></td></tr>
<tr class="separator:a2d4733a92b08d053f796972b028c3343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7442f65b06d966fcc2e6196cd053d7d" id="r_af7442f65b06d966fcc2e6196cd053d7d"><td class="memItemLeft" align="right" valign="top"><a id="af7442f65b06d966fcc2e6196cd053d7d" name="af7442f65b06d966fcc2e6196cd053d7d"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>t_priorLatChol</b></td></tr>
<tr class="separator:af7442f65b06d966fcc2e6196cd053d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20daa0586a4361c37e116845aeadd72e" id="r_a20daa0586a4361c37e116845aeadd72e"><td class="memItemLeft" align="right" valign="top"><a id="a20daa0586a4361c37e116845aeadd72e" name="a20daa0586a4361c37e116845aeadd72e"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>t_condLatChol</b></td></tr>
<tr class="separator:a20daa0586a4361c37e116845aeadd72e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab8413989986266e93c483737d7c362" id="r_adab8413989986266e93c483737d7c362"><td class="memItemLeft" align="right" valign="top"><a id="adab8413989986266e93c483737d7c362" name="adab8413989986266e93c483737d7c362"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>t_condLatSolve</b></td></tr>
<tr class="separator:adab8413989986266e93c483737d7c362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29adcf70188285ecd51f2659760cc2b" id="r_ac29adcf70188285ecd51f2659760cc2b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac29adcf70188285ecd51f2659760cc2b">thetaDiff_initialized</a></td></tr>
<tr class="separator:ac29adcf70188285ecd51f2659760cc2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa070fdade668ee7775e5630a62137376" id="r_aa070fdade668ee7775e5630a62137376"><td class="memItemLeft" align="right" valign="top"><a id="aa070fdade668ee7775e5630a62137376" name="aa070fdade668ee7775e5630a62137376"></a>
VectorXd&#160;</td><td class="memItemRight" valign="bottom"><b>theta_prev</b></td></tr>
<tr class="separator:aa070fdade668ee7775e5630a62137376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac395fe79f50dab838de80f8aabefe616" id="r_ac395fe79f50dab838de80f8aabefe616"><td class="memItemLeft" align="right" valign="top"><a id="ac395fe79f50dab838de80f8aabefe616" name="ac395fe79f50dab838de80f8aabefe616"></a>
MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><b>ThetaDiff</b></td></tr>
<tr class="separator:ac395fe79f50dab838de80f8aabefe616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81228e6fc37955941268fbbb7d019b86" id="r_a81228e6fc37955941268fbbb7d019b86"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81228e6fc37955941268fbbb7d019b86">nss</a></td></tr>
<tr class="separator:a81228e6fc37955941268fbbb7d019b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f68cd8f220fb3096f90e4d55767009" id="r_a04f68cd8f220fb3096f90e4d55767009"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04f68cd8f220fb3096f90e4d55767009">nst</a></td></tr>
<tr class="separator:a04f68cd8f220fb3096f90e4d55767009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf48d81f4e4055e2e95ba9c3bc720ec" id="r_abbf48d81f4e4055e2e95ba9c3bc720ec"><td class="memItemLeft" align="right" valign="top"><a id="abbf48d81f4e4055e2e95ba9c3bc720ec" name="abbf48d81f4e4055e2e95ba9c3bc720ec"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>nnz_Qst</b></td></tr>
<tr class="separator:abbf48d81f4e4055e2e95ba9c3bc720ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3521e894ec2df8a019ffa2ee7942ada1" id="r_a3521e894ec2df8a019ffa2ee7942ada1"><td class="memItemLeft" align="right" valign="top"><a id="a3521e894ec2df8a019ffa2ee7942ada1" name="a3521e894ec2df8a019ffa2ee7942ada1"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>nnz_Qs</b></td></tr>
<tr class="separator:a3521e894ec2df8a019ffa2ee7942ada1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af46c31ceda32cbc5b1f665a0a29c2a44" id="r_af46c31ceda32cbc5b1f665a0a29c2a44"><td class="memItemLeft" align="right" valign="top"><a id="af46c31ceda32cbc5b1f665a0a29c2a44" name="af46c31ceda32cbc5b1f665a0a29c2a44"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>dim_spatial_domain</b></td></tr>
<tr class="separator:af46c31ceda32cbc5b1f665a0a29c2a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48f86e8f68bce72ec4f0aed80ebebce7" id="r_a48f86e8f68bce72ec4f0aed80ebebce7"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a48f86e8f68bce72ec4f0aed80ebebce7">manifold</a></td></tr>
<tr class="separator:a48f86e8f68bce72ec4f0aed80ebebce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2432622b2cd5a13d187f1bee47fbaff9" id="r_a2432622b2cd5a13d187f1bee47fbaff9"><td class="memItemLeft" align="right" valign="top"><a id="a2432622b2cd5a13d187f1bee47fbaff9" name="a2432622b2cd5a13d187f1bee47fbaff9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>threadID_solverQst</b></td></tr>
<tr class="separator:a2432622b2cd5a13d187f1bee47fbaff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ce562201ba5f3849ecfc1176b7d080" id="r_ac1ce562201ba5f3849ecfc1176b7d080"><td class="memItemLeft" align="right" valign="top"><a id="ac1ce562201ba5f3849ecfc1176b7d080" name="ac1ce562201ba5f3849ecfc1176b7d080"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>threadID_solverQ</b></td></tr>
<tr class="separator:ac1ce562201ba5f3849ecfc1176b7d080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a7060408a27de614cc1cc8c8bdbd7c" id="r_ae3a7060408a27de614cc1cc8c8bdbd7c"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3a7060408a27de614cc1cc8c8bdbd7c">likelihood</a></td></tr>
<tr class="separator:ae3a7060408a27de614cc1cc8c8bdbd7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa351a7fe57d35a20f1f119292baf5df3" id="r_aa351a7fe57d35a20f1f119292baf5df3"><td class="memItemLeft" align="right" valign="top"><a id="aa351a7fe57d35a20f1f119292baf5df3" name="aa351a7fe57d35a20f1f119292baf5df3"></a>
Vect&#160;</td><td class="memItemRight" valign="bottom"><b>extraCoeffVecLik</b></td></tr>
<tr class="separator:aa351a7fe57d35a20f1f119292baf5df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaaf4d6062f072128ae33cfd14878742" id="r_adaaf4d6062f072128ae33cfd14878742"><td class="memItemLeft" align="right" valign="top"><a id="adaaf4d6062f072128ae33cfd14878742" name="adaaf4d6062f072128ae33cfd14878742"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>iter_acc</b></td></tr>
<tr class="separator:adaaf4d6062f072128ae33cfd14878742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5e697abb24ac8764f75ef721290b4ce" id="r_ab5e697abb24ac8764f75ef721290b4ce"><td class="memItemLeft" align="right" valign="top"><a id="ab5e697abb24ac8764f75ef721290b4ce" name="ab5e697abb24ac8764f75ef721290b4ce"></a>
Vector3i&#160;</td><td class="memItemRight" valign="bottom"><b>dimList</b></td></tr>
<tr class="separator:ab5e697abb24ac8764f75ef721290b4ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b64e68b38abf12e38c59981ca8f28a7" id="r_a9b64e68b38abf12e38c59981ca8f28a7"><td class="memItemLeft" align="right" valign="top">SpMat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b64e68b38abf12e38c59981ca8f28a7">Qb</a></td></tr>
<tr class="separator:a9b64e68b38abf12e38c59981ca8f28a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd469a358f2f3645627ce8a525fe565" id="r_a6dd469a358f2f3645627ce8a525fe565"><td class="memItemLeft" align="right" valign="top">SpMat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6dd469a358f2f3645627ce8a525fe565">Qu</a></td></tr>
<tr class="separator:a6dd469a358f2f3645627ce8a525fe565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1a1440e60d4657e0cdf14798aa5c060" id="r_ae1a1440e60d4657e0cdf14798aa5c060"><td class="memItemLeft" align="right" valign="top"><a id="ae1a1440e60d4657e0cdf14798aa5c060" name="ae1a1440e60d4657e0cdf14798aa5c060"></a>
SpMat&#160;</td><td class="memItemRight" valign="bottom"><b>Qst</b></td></tr>
<tr class="separator:ae1a1440e60d4657e0cdf14798aa5c060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21286568b8cc5bbeca01ea7689bce3b0" id="r_a21286568b8cc5bbeca01ea7689bce3b0"><td class="memItemLeft" align="right" valign="top"><a id="a21286568b8cc5bbeca01ea7689bce3b0" name="a21286568b8cc5bbeca01ea7689bce3b0"></a>
SpMat&#160;</td><td class="memItemRight" valign="bottom"><b>Qs</b></td></tr>
<tr class="separator:a21286568b8cc5bbeca01ea7689bce3b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6309a79e5c90152408aa04e0bb6cc722" id="r_a6309a79e5c90152408aa04e0bb6cc722"><td class="memItemLeft" align="right" valign="top">SpMat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6309a79e5c90152408aa04e0bb6cc722">Qx</a></td></tr>
<tr class="separator:a6309a79e5c90152408aa04e0bb6cc722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e71ac74d633994ca296275883673fc8" id="r_a0e71ac74d633994ca296275883673fc8"><td class="memItemLeft" align="right" valign="top">SpMat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e71ac74d633994ca296275883673fc8">Qxy</a></td></tr>
<tr class="separator:a0e71ac74d633994ca296275883673fc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d91c285b35712ce6681e8e728eb46c" id="r_af6d91c285b35712ce6681e8e728eb46c"><td class="memItemLeft" align="right" valign="top"><a id="af6d91c285b35712ce6681e8e728eb46c" name="af6d91c285b35712ce6681e8e728eb46c"></a>
Vect&#160;</td><td class="memItemRight" valign="bottom"><b>mu_initial</b></td></tr>
<tr class="separator:af6d91c285b35712ce6681e8e728eb46c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf7a2113f8f3a83332876a0869a9a1c9" id="r_abf7a2113f8f3a83332876a0869a9a1c9"><td class="memItemLeft" align="right" valign="top">Vect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf7a2113f8f3a83332876a0869a9a1c9">mu_midpoint</a></td></tr>
<tr class="separator:abf7a2113f8f3a83332876a0869a9a1c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca3178a77f1e6e41a315faeed05674d5" id="r_aca3178a77f1e6e41a315faeed05674d5"><td class="memItemLeft" align="right" valign="top">MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca3178a77f1e6e41a315faeed05674d5">mu_matrix</a></td></tr>
<tr class="separator:aca3178a77f1e6e41a315faeed05674d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d2000ba8e66831bd6c5e901f1b3a5b" id="r_a41d2000ba8e66831bd6c5e901f1b3a5b"><td class="memItemLeft" align="right" valign="top"><a id="a41d2000ba8e66831bd6c5e901f1b3a5b" name="a41d2000ba8e66831bd6c5e901f1b3a5b"></a>
ArrayXi&#160;</td><td class="memItemRight" valign="bottom"><b>task_to_rank_list_grad</b></td></tr>
<tr class="separator:a41d2000ba8e66831bd6c5e901f1b3a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a38185b3341e3ecd6db94598d73e06d" id="r_a3a38185b3341e3ecd6db94598d73e06d"><td class="memItemLeft" align="right" valign="top"><a id="a3a38185b3341e3ecd6db94598d73e06d" name="a3a38185b3341e3ecd6db94598d73e06d"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>t_bfgs_iter</b></td></tr>
<tr class="separator:a3a38185b3341e3ecd6db94598d73e06d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a371018f008f587f38fa300abe20e5" id="r_a64a371018f008f587f38fa300abe20e5"><td class="memItemLeft" align="right" valign="top">SpRmMat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64a371018f008f587f38fa300abe20e5">Ax</a></td></tr>
<tr class="separator:a64a371018f008f587f38fa300abe20e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a320fcd82bc09de35350ec1c128f5d0a6" id="r_a320fcd82bc09de35350ec1c128f5d0a6"><td class="memItemLeft" align="right" valign="top"><a id="a320fcd82bc09de35350ec1c128f5d0a6" name="a320fcd82bc09de35350ec1c128f5d0a6"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>k</b></td></tr>
<tr class="separator:a320fcd82bc09de35350ec1c128f5d0a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a337669b2f28bed5cff7a37d23b3dc5" id="r_a8a337669b2f28bed5cff7a37d23b3dc5"><td class="memItemLeft" align="right" valign="top"><a id="a8a337669b2f28bed5cff7a37d23b3dc5" name="a8a337669b2f28bed5cff7a37d23b3dc5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>mpi_size</b></td></tr>
<tr class="separator:a8a337669b2f28bed5cff7a37d23b3dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a392c0aa793b0f010cd6b513a663a66cf" id="r_a392c0aa793b0f010cd6b513a663a66cf"><td class="memItemLeft" align="right" valign="top"><a id="a392c0aa793b0f010cd6b513a663a66cf" name="a392c0aa793b0f010cd6b513a663a66cf"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>num_workers</b></td></tr>
<tr class="separator:a392c0aa793b0f010cd6b513a663a66cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6cd1a63ceecf38412a9b441223d5f1" id="r_a1d6cd1a63ceecf38412a9b441223d5f1"><td class="memItemLeft" align="right" valign="top"><a id="a1d6cd1a63ceecf38412a9b441223d5f1" name="a1d6cd1a63ceecf38412a9b441223d5f1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>num_requests_send</b></td></tr>
<tr class="separator:a1d6cd1a63ceecf38412a9b441223d5f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26080e2f12d5019644449b853a132da5" id="r_a26080e2f12d5019644449b853a132da5"><td class="memItemLeft" align="right" valign="top"><a id="a26080e2f12d5019644449b853a132da5" name="a26080e2f12d5019644449b853a132da5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>num_requests_recv</b></td></tr>
<tr class="separator:a26080e2f12d5019644449b853a132da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a88f66287795f4c43fa6756cca8d1e4" id="r_a2a88f66287795f4c43fa6756cca8d1e4"><td class="memItemLeft" align="right" valign="top"><a id="a2a88f66287795f4c43fa6756cca8d1e4" name="a2a88f66287795f4c43fa6756cca8d1e4"></a>
Vect&#160;</td><td class="memItemRight" valign="bottom"><b>theta</b></td></tr>
<tr class="separator:a2a88f66287795f4c43fa6756cca8d1e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34429114f4a233f7a0af64fa39ca447a" id="r_a34429114f4a233f7a0af64fa39ca447a"><td class="memItemLeft" align="right" valign="top"><a id="a34429114f4a233f7a0af64fa39ca447a" name="a34429114f4a233f7a0af64fa39ca447a"></a>
Vect&#160;</td><td class="memItemRight" valign="bottom"><b>theta_loc</b></td></tr>
<tr class="separator:a34429114f4a233f7a0af64fa39ca447a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea04d0eeae372cef98aab7d7cc6ec830" id="r_aea04d0eeae372cef98aab7d7cc6ec830"><td class="memItemLeft" align="right" valign="top"><a id="aea04d0eeae372cef98aab7d7cc6ec830" name="aea04d0eeae372cef98aab7d7cc6ec830"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><b>theta_loc_array</b></td></tr>
<tr class="separator:aea04d0eeae372cef98aab7d7cc6ec830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af24308ed74a4c1056ce9ae93dcb0d81d" id="r_af24308ed74a4c1056ce9ae93dcb0d81d"><td class="memItemLeft" align="right" valign="top"><a id="af24308ed74a4c1056ce9ae93dcb0d81d" name="af24308ed74a4c1056ce9ae93dcb0d81d"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>f_theta</b></td></tr>
<tr class="separator:af24308ed74a4c1056ce9ae93dcb0d81d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0222d41263692f53a9fc8ae0961a8425" id="r_a0222d41263692f53a9fc8ae0961a8425"><td class="memItemLeft" align="right" valign="top"><a id="a0222d41263692f53a9fc8ae0961a8425" name="a0222d41263692f53a9fc8ae0961a8425"></a>
<a class="el" href="classSolver.html">Solver</a> **&#160;</td><td class="memItemRight" valign="bottom"><b>solverQ</b></td></tr>
<tr class="separator:a0222d41263692f53a9fc8ae0961a8425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceba26e2123952a035499bc7ff779749" id="r_aceba26e2123952a035499bc7ff779749"><td class="memItemLeft" align="right" valign="top"><a id="aceba26e2123952a035499bc7ff779749" name="aceba26e2123952a035499bc7ff779749"></a>
<a class="el" href="classSolver.html">Solver</a> **&#160;</td><td class="memItemRight" valign="bottom"><b>solverQst</b></td></tr>
<tr class="separator:aceba26e2123952a035499bc7ff779749"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Computes the Posterior of the hyperparameters theta. </p>
<p>Computes the posterior of theta for a given theta and its gradient using a central finite difference approximation. Can additionally compute an approximation to the Hessian. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a56db4c858de1c0dc0721bf19e60c493c" name="a56db4c858de1c0dc0721bf19e60c493c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56db4c858de1c0dc0721bf19e60c493c">&#9670;&#160;</a></span>PostTheta() <span class="overload">[1/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PostTheta::PostTheta </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixXd&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>theta_prior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>solver_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>constr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixXd&#160;</td>
          <td class="paramname"><em>Dxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>validate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vect&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructor for regression model (no random effects). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ns_</td><td>number of spatial grid points per time step. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nt_</td><td>number of temporal time steps. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb_</td><td>number of fixed effects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">no_</td><td>number of observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B_</td><td>covariate matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y_</td><td>vector with observations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>B = B_ or is its own copy? </dd></dl>

</div>
</div>
<a id="a4ff16e221ec1a93e07d27553fb817c6d" name="a4ff16e221ec1a93e07d27553fb817c6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ff16e221ec1a93e07d27553fb817c6d">&#9670;&#160;</a></span>PostTheta() <span class="overload">[2/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PostTheta::PostTheta </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>Ax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>theta_prior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>solver_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>constr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixXd&#160;</td>
          <td class="paramname"><em>Dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixXd&#160;</td>
          <td class="paramname"><em>Dxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>validate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vect&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructor for spatial model (order 2). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ns_</td><td>number of spatial grid points per time step. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nt_</td><td>number of temporal time steps. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb_</td><td>number of fixed effects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">no_</td><td>number of observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Ax_</td><td>covariate matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y_</td><td>vector with observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c0_</td><td>diagonalised mass matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g1_</td><td>stiffness matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g2_</td><td>defined as : g1 * c0^-1 * g1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35269dd8407ce1c126a4b87a31b7a310" name="a35269dd8407ce1c126a4b87a31b7a310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35269dd8407ce1c126a4b87a31b7a310">&#9670;&#160;</a></span>PostTheta() <span class="overload">[3/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PostTheta::PostTheta </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>Ax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>M0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>theta_prior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>solver_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>constr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixXd&#160;</td>
          <td class="paramname"><em>Dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixXd&#160;</td>
          <td class="paramname"><em>Dxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>validate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vect&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructor for spatial temporal model. </p>
<p>constructor for spatial model (order 2). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ns_</td><td>number of spatial grid points per time step. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nt_</td><td>number of temporal time steps. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb_</td><td>number of fixed effects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">no_</td><td>number of observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Ax_</td><td>covariate matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y_</td><td>vector with observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c0_</td><td>diagonalised mass matrix space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g1_</td><td>stiffness matrix space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g2_</td><td>defined as : g1 * c0^-1 * g1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g3_</td><td>defined as : g1 * (c0^-1 * g1)^2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M0_</td><td>diagonalised mass matrix time. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M1_</td><td>diagonal matrix with diag(0.5, 0, ..., 0, 0.5) -&gt; account for boundary </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M2_</td><td>stiffness matrix time. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56db4c858de1c0dc0721bf19e60c493c" name="a56db4c858de1c0dc0721bf19e60c493c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56db4c858de1c0dc0721bf19e60c493c">&#9670;&#160;</a></span>PostTheta() <span class="overload">[4/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PostTheta::PostTheta </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixXd&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>theta_prior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>solver_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>constr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixXd&#160;</td>
          <td class="paramname"><em>Dxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>validate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vect&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructor for regression model (no random effects). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ns_</td><td>number of spatial grid points per time step. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nt_</td><td>number of temporal time steps. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb_</td><td>number of fixed effects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">no_</td><td>number of observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B_</td><td>covariate matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y_</td><td>vector with observations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>B = B_ or is its own copy? </dd></dl>

</div>
</div>
<a id="a4ff16e221ec1a93e07d27553fb817c6d" name="a4ff16e221ec1a93e07d27553fb817c6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ff16e221ec1a93e07d27553fb817c6d">&#9670;&#160;</a></span>PostTheta() <span class="overload">[5/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PostTheta::PostTheta </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>Ax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>theta_prior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>solver_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>constr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixXd&#160;</td>
          <td class="paramname"><em>Dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixXd&#160;</td>
          <td class="paramname"><em>Dxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>validate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vect&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructor for spatial model (order 2). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ns_</td><td>number of spatial grid points per time step. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nt_</td><td>number of temporal time steps. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb_</td><td>number of fixed effects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">no_</td><td>number of observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Ax_</td><td>covariate matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y_</td><td>vector with observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c0_</td><td>diagonalised mass matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g1_</td><td>stiffness matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g2_</td><td>defined as : g1 * c0^-1 * g1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35269dd8407ce1c126a4b87a31b7a310" name="a35269dd8407ce1c126a4b87a31b7a310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35269dd8407ce1c126a4b87a31b7a310">&#9670;&#160;</a></span>PostTheta() <span class="overload">[6/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PostTheta::PostTheta </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>Ax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>M0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>theta_prior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>solver_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>constr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixXd&#160;</td>
          <td class="paramname"><em>Dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixXd&#160;</td>
          <td class="paramname"><em>Dxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>validate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vect&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructor for spatial temporal model. </p>
<p>constructor for spatial model (order 2). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ns_</td><td>number of spatial grid points per time step. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nt_</td><td>number of temporal time steps. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb_</td><td>number of fixed effects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">no_</td><td>number of observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Ax_</td><td>covariate matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y_</td><td>vector with observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c0_</td><td>diagonalised mass matrix space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g1_</td><td>stiffness matrix space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g2_</td><td>defined as : g1 * c0^-1 * g1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g3_</td><td>defined as : g1 * (c0^-1 * g1)^2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M0_</td><td>diagonalised mass matrix time. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M1_</td><td>diagonal matrix with diag(0.5, 0, ..., 0, 0.5) -&gt; account for boundary </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M2_</td><td>stiffness matrix time. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56db4c858de1c0dc0721bf19e60c493c" name="a56db4c858de1c0dc0721bf19e60c493c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56db4c858de1c0dc0721bf19e60c493c">&#9670;&#160;</a></span>PostTheta() <span class="overload">[7/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PostTheta::PostTheta </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixXd&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>theta_prior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>solver_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>constr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixXd&#160;</td>
          <td class="paramname"><em>Dxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>validate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vect&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructor for regression model (no random effects). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ns_</td><td>number of spatial grid points per time step. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nt_</td><td>number of temporal time steps. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb_</td><td>number of fixed effects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">no_</td><td>number of observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B_</td><td>covariate matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y_</td><td>vector with observations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>B = B_ or is its own copy? </dd></dl>

</div>
</div>
<a id="a4ff16e221ec1a93e07d27553fb817c6d" name="a4ff16e221ec1a93e07d27553fb817c6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ff16e221ec1a93e07d27553fb817c6d">&#9670;&#160;</a></span>PostTheta() <span class="overload">[8/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PostTheta::PostTheta </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>Ax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>theta_prior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>solver_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>constr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixXd&#160;</td>
          <td class="paramname"><em>Dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixXd&#160;</td>
          <td class="paramname"><em>Dxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>validate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vect&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructor for spatial model (order 2). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ns_</td><td>number of spatial grid points per time step. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nt_</td><td>number of temporal time steps. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb_</td><td>number of fixed effects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">no_</td><td>number of observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Ax_</td><td>covariate matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y_</td><td>vector with observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c0_</td><td>diagonalised mass matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g1_</td><td>stiffness matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g2_</td><td>defined as : g1 * c0^-1 * g1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35269dd8407ce1c126a4b87a31b7a310" name="a35269dd8407ce1c126a4b87a31b7a310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35269dd8407ce1c126a4b87a31b7a310">&#9670;&#160;</a></span>PostTheta() <span class="overload">[9/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PostTheta::PostTheta </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>Ax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>M0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>theta_prior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>solver_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>constr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixXd&#160;</td>
          <td class="paramname"><em>Dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixXd&#160;</td>
          <td class="paramname"><em>Dxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>validate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vect&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructor for spatial temporal model. </p>
<p>constructor for spatial model (order 2). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ns_</td><td>number of spatial grid points per time step. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nt_</td><td>number of temporal time steps. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb_</td><td>number of fixed effects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">no_</td><td>number of observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Ax_</td><td>covariate matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y_</td><td>vector with observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c0_</td><td>diagonalised mass matrix space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g1_</td><td>stiffness matrix space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g2_</td><td>defined as : g1 * c0^-1 * g1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g3_</td><td>defined as : g1 * (c0^-1 * g1)^2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M0_</td><td>diagonalised mass matrix time. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M1_</td><td>diagonal matrix with diag(0.5, 0, ..., 0, 0.5) -&gt; account for boundary </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M2_</td><td>stiffness matrix time. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad45441d61f13cadb72c8fd19ba7047c9" name="ad45441d61f13cadb72c8fd19ba7047c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad45441d61f13cadb72c8fd19ba7047c9">&#9670;&#160;</a></span>PostTheta() <span class="overload">[10/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PostTheta::PostTheta </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixXd&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>theta_prior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>mu_initial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>likelihood</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>extraCoeffVecLik</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>solver_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>constr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixXd&#160;</td>
          <td class="paramname"><em>Dxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>validate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vect&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructor for regression model (no random effects). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ns_</td><td>number of spatial grid points per time step. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nt_</td><td>number of temporal time steps. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb_</td><td>number of fixed effects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">no_</td><td>number of observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B_</td><td>covariate matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y_</td><td>vector with observations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>B = B_ or is its own copy? </dd></dl>

</div>
</div>
<a id="a152ca7756a325c1a1b7d334332578a25" name="a152ca7756a325c1a1b7d334332578a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a152ca7756a325c1a1b7d334332578a25">&#9670;&#160;</a></span>PostTheta() <span class="overload">[11/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PostTheta::PostTheta </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>Ax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>theta_prior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>mu_initial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>likelihood</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>extraCoeffVecLik</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>solver_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim_spatial_domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>manifold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>constr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixXd&#160;</td>
          <td class="paramname"><em>Dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixXd&#160;</td>
          <td class="paramname"><em>Dxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>validate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vect&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructor for spatial model (order 2). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ns_</td><td>number of spatial grid points per time step. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nt_</td><td>number of temporal time steps. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb_</td><td>number of fixed effects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">no_</td><td>number of observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Ax_</td><td>covariate matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y_</td><td>vector with observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c0_</td><td>diagonalised mass matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g1_</td><td>stiffness matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g2_</td><td>defined as : g1 * c0^-1 * g1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac476b37613676dee3959a63978501bc7" name="ac476b37613676dee3959a63978501bc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac476b37613676dee3959a63978501bc7">&#9670;&#160;</a></span>PostTheta() <span class="overload">[12/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PostTheta::PostTheta </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>Ax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>M0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>theta_prior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>mu_initial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>likelihood</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>extraCoeffVecLik</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>solver_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim_spatial_domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>manifold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>constr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixXd&#160;</td>
          <td class="paramname"><em>Dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixXd&#160;</td>
          <td class="paramname"><em>Dxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>validate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vect&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructor for spatial temporal model. </p>
<p>constructor for spatial model (order 2). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ns_</td><td>number of spatial grid points per time step. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nt_</td><td>number of temporal time steps. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb_</td><td>number of fixed effects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">no_</td><td>number of observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Ax_</td><td>covariate matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y_</td><td>vector with observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c0_</td><td>diagonalised mass matrix space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g1_</td><td>stiffness matrix space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g2_</td><td>defined as : g1 * c0^-1 * g1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g3_</td><td>defined as : g1 * (c0^-1 * g1)^2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M0_</td><td>diagonalised mass matrix time. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M1_</td><td>diagonal matrix with diag(0.5, 0, ..., 0, 0.5) -&gt; account for boundary </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M2_</td><td>stiffness matrix time. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">theta_prior</td><td>prior hyperparameters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">solver_type</td><td>linear solver: currently PARDISO, BTA </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim_spatial_domain</td><td>dimension spatial field 1D/2D ... </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">manifold</td><td>plane: "", "sphere", can add more later </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constr</td><td>constraints, mainly sum-to-zero </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa09b11852e0230bb4c9b174cc03f5c44" name="aa09b11852e0230bb4c9b174cc03f5c44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa09b11852e0230bb4c9b174cc03f5c44">&#9670;&#160;</a></span>PostTheta() <span class="overload">[13/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PostTheta::PostTheta </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>Ax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>M0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>theta_prior_param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>mu_initial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>likelihood</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>extraCoeffVecLik</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>solver_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim_spatial_domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>manifold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>constr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixXd&#160;</td>
          <td class="paramname"><em>Dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixXd&#160;</td>
          <td class="paramname"><em>Dxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>validate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vect&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructor for spatial temporal model w/ add. spatial field </p>
<p>constructor for both spatial models (order 2). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ns_</td><td>number of spatial grid points per time step. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nt_</td><td>number of temporal time steps. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nss_</td><td>number of spatial grid points in add. spatial field </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb_</td><td>number of fixed effects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">no_</td><td>number of observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Ax_</td><td>covariate matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y_</td><td>vector with observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c0_</td><td>diagonalised mass matrix space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g1_</td><td>stiffness matrix space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g2_</td><td>defined as : g1 * c0^-1 * g1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g3_</td><td>defined as : g1 * (c0^-1 * g1)^2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M0_</td><td>diagonalised mass matrix time. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M1_</td><td>diagonal matrix with diag(0.5, 0, ..., 0, 0.5) -&gt; account for boundary </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M2_</td><td>stiffness matrix time. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56db4c858de1c0dc0721bf19e60c493c" name="a56db4c858de1c0dc0721bf19e60c493c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56db4c858de1c0dc0721bf19e60c493c">&#9670;&#160;</a></span>PostTheta() <span class="overload">[14/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PostTheta::PostTheta </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixXd&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>theta_prior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>solver_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>constr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixXd&#160;</td>
          <td class="paramname"><em>Dxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>validate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vect&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructor for regression model (no random effects). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ns_</td><td>number of spatial grid points per time step. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nt_</td><td>number of temporal time steps. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb_</td><td>number of fixed effects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">no_</td><td>number of observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B_</td><td>covariate matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y_</td><td>vector with observations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>B = B_ or is its own copy? </dd></dl>

</div>
</div>
<a id="a4ff16e221ec1a93e07d27553fb817c6d" name="a4ff16e221ec1a93e07d27553fb817c6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ff16e221ec1a93e07d27553fb817c6d">&#9670;&#160;</a></span>PostTheta() <span class="overload">[15/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PostTheta::PostTheta </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>Ax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>theta_prior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>solver_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>constr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixXd&#160;</td>
          <td class="paramname"><em>Dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixXd&#160;</td>
          <td class="paramname"><em>Dxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>validate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vect&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructor for spatial model (order 2). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ns_</td><td>number of spatial grid points per time step. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nt_</td><td>number of temporal time steps. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb_</td><td>number of fixed effects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">no_</td><td>number of observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Ax_</td><td>covariate matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y_</td><td>vector with observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c0_</td><td>diagonalised mass matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g1_</td><td>stiffness matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g2_</td><td>defined as : g1 * c0^-1 * g1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35269dd8407ce1c126a4b87a31b7a310" name="a35269dd8407ce1c126a4b87a31b7a310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35269dd8407ce1c126a4b87a31b7a310">&#9670;&#160;</a></span>PostTheta() <span class="overload">[16/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PostTheta::PostTheta </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>Ax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>M0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>theta_prior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>solver_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>constr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixXd&#160;</td>
          <td class="paramname"><em>Dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixXd&#160;</td>
          <td class="paramname"><em>Dxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>validate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vect&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructor for spatial temporal model. </p>
<p>constructor for spatial model (order 2). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ns_</td><td>number of spatial grid points per time step. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nt_</td><td>number of temporal time steps. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb_</td><td>number of fixed effects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">no_</td><td>number of observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Ax_</td><td>covariate matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y_</td><td>vector with observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c0_</td><td>diagonalised mass matrix space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g1_</td><td>stiffness matrix space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g2_</td><td>defined as : g1 * c0^-1 * g1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g3_</td><td>defined as : g1 * (c0^-1 * g1)^2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M0_</td><td>diagonalised mass matrix time. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M1_</td><td>diagonal matrix with diag(0.5, 0, ..., 0, 0.5) -&gt; account for boundary </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M2_</td><td>stiffness matrix time. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56db4c858de1c0dc0721bf19e60c493c" name="a56db4c858de1c0dc0721bf19e60c493c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56db4c858de1c0dc0721bf19e60c493c">&#9670;&#160;</a></span>PostTheta() <span class="overload">[17/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PostTheta::PostTheta </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixXd&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>theta_prior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>solver_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>constr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixXd&#160;</td>
          <td class="paramname"><em>Dxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>validate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vect&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructor for regression model (no random effects). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ns_</td><td>number of spatial grid points per time step. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nt_</td><td>number of temporal time steps. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb_</td><td>number of fixed effects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">no_</td><td>number of observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B_</td><td>covariate matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y_</td><td>vector with observations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>B = B_ or is its own copy? </dd></dl>

</div>
</div>
<a id="a4ff16e221ec1a93e07d27553fb817c6d" name="a4ff16e221ec1a93e07d27553fb817c6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ff16e221ec1a93e07d27553fb817c6d">&#9670;&#160;</a></span>PostTheta() <span class="overload">[18/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PostTheta::PostTheta </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>Ax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>theta_prior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>solver_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>constr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixXd&#160;</td>
          <td class="paramname"><em>Dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixXd&#160;</td>
          <td class="paramname"><em>Dxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>validate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vect&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructor for spatial model (order 2). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ns_</td><td>number of spatial grid points per time step. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nt_</td><td>number of temporal time steps. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb_</td><td>number of fixed effects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">no_</td><td>number of observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Ax_</td><td>covariate matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y_</td><td>vector with observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c0_</td><td>diagonalised mass matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g1_</td><td>stiffness matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g2_</td><td>defined as : g1 * c0^-1 * g1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35269dd8407ce1c126a4b87a31b7a310" name="a35269dd8407ce1c126a4b87a31b7a310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35269dd8407ce1c126a4b87a31b7a310">&#9670;&#160;</a></span>PostTheta() <span class="overload">[19/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PostTheta::PostTheta </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>Ax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>M0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>theta_prior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>solver_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>constr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixXd&#160;</td>
          <td class="paramname"><em>Dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixXd&#160;</td>
          <td class="paramname"><em>Dxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>validate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vect&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructor for spatial temporal model. </p>
<p>constructor for spatial model (order 2). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ns_</td><td>number of spatial grid points per time step. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nt_</td><td>number of temporal time steps. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb_</td><td>number of fixed effects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">no_</td><td>number of observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Ax_</td><td>covariate matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y_</td><td>vector with observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c0_</td><td>diagonalised mass matrix space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g1_</td><td>stiffness matrix space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g2_</td><td>defined as : g1 * c0^-1 * g1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g3_</td><td>defined as : g1 * (c0^-1 * g1)^2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M0_</td><td>diagonalised mass matrix time. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M1_</td><td>diagonal matrix with diag(0.5, 0, ..., 0, 0.5) -&gt; account for boundary </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M2_</td><td>stiffness matrix time. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56db4c858de1c0dc0721bf19e60c493c" name="a56db4c858de1c0dc0721bf19e60c493c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56db4c858de1c0dc0721bf19e60c493c">&#9670;&#160;</a></span>PostTheta() <span class="overload">[20/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PostTheta::PostTheta </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixXd&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>theta_prior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>solver_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>constr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixXd&#160;</td>
          <td class="paramname"><em>Dxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>validate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vect&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructor for regression model (no random effects). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ns_</td><td>number of spatial grid points per time step. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nt_</td><td>number of temporal time steps. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb_</td><td>number of fixed effects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">no_</td><td>number of observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B_</td><td>covariate matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y_</td><td>vector with observations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>B = B_ or is its own copy? </dd></dl>

</div>
</div>
<a id="ab3c76a2e26834f27d287692faaf88017" name="ab3c76a2e26834f27d287692faaf88017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3c76a2e26834f27d287692faaf88017">&#9670;&#160;</a></span>PostTheta() <span class="overload">[21/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PostTheta::PostTheta </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpRmMat&#160;</td>
          <td class="paramname"><em>Ax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>theta_prior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>solver_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim_spatial_domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>manifold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>constr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixXd&#160;</td>
          <td class="paramname"><em>Dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixXd&#160;</td>
          <td class="paramname"><em>Dxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>validate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vect&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructor for spatial model (order 2). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ns_</td><td>number of spatial grid points per time step. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nt_</td><td>number of temporal time steps. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb_</td><td>number of fixed effects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">no_</td><td>number of observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Ax_</td><td>covariate matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y_</td><td>vector with observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c0_</td><td>diagonalised mass matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g1_</td><td>stiffness matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g2_</td><td>defined as : g1 * c0^-1 * g1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5643b54315d75dae26fd435386ddaf8" name="af5643b54315d75dae26fd435386ddaf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5643b54315d75dae26fd435386ddaf8">&#9670;&#160;</a></span>PostTheta() <span class="overload">[22/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PostTheta::PostTheta </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpRmMat&#160;</td>
          <td class="paramname"><em>Ax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>M0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>theta_prior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>solver_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim_spatial_domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>manifold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>constr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixXd&#160;</td>
          <td class="paramname"><em>Dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixXd&#160;</td>
          <td class="paramname"><em>Dxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>validate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vect&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructor for spatial temporal model. </p>
<p>constructor for spatial model (order 2). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ns_</td><td>number of spatial grid points per time step. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nt_</td><td>number of temporal time steps. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb_</td><td>number of fixed effects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">no_</td><td>number of observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Ax_</td><td>covariate matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y_</td><td>vector with observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c0_</td><td>diagonalised mass matrix space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g1_</td><td>stiffness matrix space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g2_</td><td>defined as : g1 * c0^-1 * g1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g3_</td><td>defined as : g1 * (c0^-1 * g1)^2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M0_</td><td>diagonalised mass matrix time. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M1_</td><td>diagonal matrix with diag(0.5, 0, ..., 0, 0.5) -&gt; account for boundary </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M2_</td><td>stiffness matrix time. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">theta_prior</td><td>prior hyperparameters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">solver_type</td><td>linear solver: currently PARDISO, BTA </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim_spatial_domain</td><td>dimension spatial field 1D/2D ... </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">manifold</td><td>plane: "", "sphere", can add more later </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constr</td><td>constraints, mainly sum-to-zero </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b658144e57ed4b75dd037d014fbc767" name="a9b658144e57ed4b75dd037d014fbc767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b658144e57ed4b75dd037d014fbc767">&#9670;&#160;</a></span>PostTheta() <span class="overload">[23/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PostTheta::PostTheta </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ns_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nt_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nss_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>no_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpRmMat&#160;</td>
          <td class="paramname"><em>Ax_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>y_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>c0_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g1_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g2_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g3_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>M0_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>M1_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>M2_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>theta_prior_param_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>solver_type_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim_spatial_domain_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>manifold_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>constr_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixXd&#160;</td>
          <td class="paramname"><em>Dx_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixXd&#160;</td>
          <td class="paramname"><em>Dxy_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>validate_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vect&#160;</td>
          <td class="paramname"><em>w_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructor for spatial temporal model w/ add. spatial field </p>
<p>constructor for both spatial models (order 2). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ns_</td><td>number of spatial grid points per time step. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nt_</td><td>number of temporal time steps. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nss_</td><td>number of spatial grid points in add. spatial field </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb_</td><td>number of fixed effects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">no_</td><td>number of observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Ax_</td><td>covariate matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y_</td><td>vector with observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c0_</td><td>diagonalised mass matrix space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g1_</td><td>stiffness matrix space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g2_</td><td>defined as : g1 * c0^-1 * g1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g3_</td><td>defined as : g1 * (c0^-1 * g1)^2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M0_</td><td>diagonalised mass matrix time. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M1_</td><td>diagonal matrix with diag(0.5, 0, ..., 0, 0.5) -&gt; account for boundary </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M2_</td><td>stiffness matrix time. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56db4c858de1c0dc0721bf19e60c493c" name="a56db4c858de1c0dc0721bf19e60c493c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56db4c858de1c0dc0721bf19e60c493c">&#9670;&#160;</a></span>PostTheta() <span class="overload">[24/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PostTheta::PostTheta </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixXd&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>theta_prior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>solver_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>constr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixXd&#160;</td>
          <td class="paramname"><em>Dxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>validate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vect&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructor for regression model (no random effects). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ns_</td><td>number of spatial grid points per time step. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nt_</td><td>number of temporal time steps. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb_</td><td>number of fixed effects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">no_</td><td>number of observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B_</td><td>covariate matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y_</td><td>vector with observations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>B = B_ or is its own copy? </dd></dl>

</div>
</div>
<a id="a4ff16e221ec1a93e07d27553fb817c6d" name="a4ff16e221ec1a93e07d27553fb817c6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ff16e221ec1a93e07d27553fb817c6d">&#9670;&#160;</a></span>PostTheta() <span class="overload">[25/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PostTheta::PostTheta </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>Ax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>theta_prior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>solver_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>constr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixXd&#160;</td>
          <td class="paramname"><em>Dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixXd&#160;</td>
          <td class="paramname"><em>Dxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>validate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vect&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructor for spatial model (order 2). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ns_</td><td>number of spatial grid points per time step. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nt_</td><td>number of temporal time steps. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb_</td><td>number of fixed effects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">no_</td><td>number of observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Ax_</td><td>covariate matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y_</td><td>vector with observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c0_</td><td>diagonalised mass matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g1_</td><td>stiffness matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g2_</td><td>defined as : g1 * c0^-1 * g1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35269dd8407ce1c126a4b87a31b7a310" name="a35269dd8407ce1c126a4b87a31b7a310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35269dd8407ce1c126a4b87a31b7a310">&#9670;&#160;</a></span>PostTheta() <span class="overload">[26/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PostTheta::PostTheta </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>Ax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>M0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>theta_prior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>solver_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>constr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixXd&#160;</td>
          <td class="paramname"><em>Dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixXd&#160;</td>
          <td class="paramname"><em>Dxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>validate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vect&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructor for spatial temporal model. </p>
<p>constructor for spatial model (order 2). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ns_</td><td>number of spatial grid points per time step. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nt_</td><td>number of temporal time steps. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb_</td><td>number of fixed effects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">no_</td><td>number of observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Ax_</td><td>covariate matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y_</td><td>vector with observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c0_</td><td>diagonalised mass matrix space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g1_</td><td>stiffness matrix space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g2_</td><td>defined as : g1 * c0^-1 * g1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g3_</td><td>defined as : g1 * (c0^-1 * g1)^2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M0_</td><td>diagonalised mass matrix time. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M1_</td><td>diagonal matrix with diag(0.5, 0, ..., 0, 0.5) -&gt; account for boundary </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M2_</td><td>stiffness matrix time. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56db4c858de1c0dc0721bf19e60c493c" name="a56db4c858de1c0dc0721bf19e60c493c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56db4c858de1c0dc0721bf19e60c493c">&#9670;&#160;</a></span>PostTheta() <span class="overload">[27/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PostTheta::PostTheta </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixXd&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>theta_prior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>solver_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>constr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixXd&#160;</td>
          <td class="paramname"><em>Dxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>validate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vect&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructor for regression model (no random effects). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ns_</td><td>number of spatial grid points per time step. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nt_</td><td>number of temporal time steps. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb_</td><td>number of fixed effects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">no_</td><td>number of observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B_</td><td>covariate matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y_</td><td>vector with observations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>B = B_ or is its own copy? </dd></dl>

</div>
</div>
<a id="a4ff16e221ec1a93e07d27553fb817c6d" name="a4ff16e221ec1a93e07d27553fb817c6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ff16e221ec1a93e07d27553fb817c6d">&#9670;&#160;</a></span>PostTheta() <span class="overload">[28/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PostTheta::PostTheta </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>Ax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>theta_prior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>solver_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>constr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixXd&#160;</td>
          <td class="paramname"><em>Dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixXd&#160;</td>
          <td class="paramname"><em>Dxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>validate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vect&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructor for spatial model (order 2). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ns_</td><td>number of spatial grid points per time step. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nt_</td><td>number of temporal time steps. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb_</td><td>number of fixed effects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">no_</td><td>number of observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Ax_</td><td>covariate matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y_</td><td>vector with observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c0_</td><td>diagonalised mass matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g1_</td><td>stiffness matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g2_</td><td>defined as : g1 * c0^-1 * g1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35269dd8407ce1c126a4b87a31b7a310" name="a35269dd8407ce1c126a4b87a31b7a310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35269dd8407ce1c126a4b87a31b7a310">&#9670;&#160;</a></span>PostTheta() <span class="overload">[29/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PostTheta::PostTheta </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>Ax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>M0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>theta_prior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>solver_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>constr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixXd&#160;</td>
          <td class="paramname"><em>Dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixXd&#160;</td>
          <td class="paramname"><em>Dxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>validate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vect&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructor for spatial temporal model. </p>
<p>constructor for spatial model (order 2). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ns_</td><td>number of spatial grid points per time step. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nt_</td><td>number of temporal time steps. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb_</td><td>number of fixed effects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">no_</td><td>number of observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Ax_</td><td>covariate matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y_</td><td>vector with observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c0_</td><td>diagonalised mass matrix space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g1_</td><td>stiffness matrix space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g2_</td><td>defined as : g1 * c0^-1 * g1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g3_</td><td>defined as : g1 * (c0^-1 * g1)^2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M0_</td><td>diagonalised mass matrix time. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M1_</td><td>diagonal matrix with diag(0.5, 0, ..., 0, 0.5) -&gt; account for boundary </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M2_</td><td>stiffness matrix time. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a551967536a31396160e314649cf556ef" name="a551967536a31396160e314649cf556ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a551967536a31396160e314649cf556ef">&#9670;&#160;</a></span>PostTheta() <span class="overload">[30/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PostTheta::PostTheta </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixXd&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>theta_prior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>solver_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructor for regression model (no random effects). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ns_</td><td>number of spatial grid points per time step. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nt_</td><td>number of temporal time steps. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb_</td><td>number of fixed effects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">no_</td><td>number of observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B_</td><td>covariate matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y_</td><td>vector with observations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>B = B_ or is its own copy? </dd></dl>

</div>
</div>
<a id="a80340f484eb074f13ea56fff84370ba2" name="a80340f484eb074f13ea56fff84370ba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80340f484eb074f13ea56fff84370ba2">&#9670;&#160;</a></span>PostTheta() <span class="overload">[31/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PostTheta::PostTheta </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>Ax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>theta_prior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>solver_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructor for spatial model (order 2). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ns_</td><td>number of spatial grid points per time step. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nt_</td><td>number of temporal time steps. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb_</td><td>number of fixed effects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">no_</td><td>number of observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Ax_</td><td>covariate matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y_</td><td>vector with observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c0_</td><td>diagonalised mass matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g1_</td><td>stiffness matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g2_</td><td>defined as : g1 * c0^-1 * g1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a79a92e72eb66d3adcbecae4e133a4482" name="a79a92e72eb66d3adcbecae4e133a4482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79a92e72eb66d3adcbecae4e133a4482">&#9670;&#160;</a></span>PostTheta() <span class="overload">[32/32]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PostTheta::PostTheta </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>Ax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>g3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>M0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>M1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>theta_prior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>solver_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructor for spatial temporal model. </p>
<p>constructor for spatial model (order 2). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ns_</td><td>number of spatial grid points per time step. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nt_</td><td>number of temporal time steps. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nb_</td><td>number of fixed effects. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">no_</td><td>number of observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Ax_</td><td>covariate matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y_</td><td>vector with observations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c0_</td><td>diagonalised mass matrix space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g1_</td><td>stiffness matrix space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g2_</td><td>defined as : g1 * c0^-1 * g1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g3_</td><td>defined as : g1 * (c0^-1 * g1)^2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M0_</td><td>diagonalised mass matrix time. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M1_</td><td>diagonal matrix with diag(0.5, 0, ..., 0, 0.5) -&gt; account for boundary </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M2_</td><td>stiffness matrix time. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a240a43fde6a2e26c30275b24f99f5d4e" name="a240a43fde6a2e26c30275b24f99f5d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a240a43fde6a2e26c30275b24f99f5d4e">&#9670;&#160;</a></span>check_pos_def() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::check_pos_def </td>
          <td>(</td>
          <td class="paramtype">MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>hess</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check if Hessian positive definite (matrix assumed to be dense &amp; small since dim(theta) small) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">updates</td><td>hessian to only the diagonal entries if not positive definite. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a240a43fde6a2e26c30275b24f99f5d4e" name="a240a43fde6a2e26c30275b24f99f5d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a240a43fde6a2e26c30275b24f99f5d4e">&#9670;&#160;</a></span>check_pos_def() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::check_pos_def </td>
          <td>(</td>
          <td class="paramtype">MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>hess</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check if Hessian positive definite (matrix assumed to be dense &amp; small since dim(theta) small) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">updates</td><td>hessian to only the diagonal entries if not positive definite. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a240a43fde6a2e26c30275b24f99f5d4e" name="a240a43fde6a2e26c30275b24f99f5d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a240a43fde6a2e26c30275b24f99f5d4e">&#9670;&#160;</a></span>check_pos_def() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::check_pos_def </td>
          <td>(</td>
          <td class="paramtype">MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>hess</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check if Hessian positive definite (matrix assumed to be dense &amp; small since dim(theta) small) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">updates</td><td>hessian to only the diagonal entries if not positive definite. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a240a43fde6a2e26c30275b24f99f5d4e" name="a240a43fde6a2e26c30275b24f99f5d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a240a43fde6a2e26c30275b24f99f5d4e">&#9670;&#160;</a></span>check_pos_def() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::check_pos_def </td>
          <td>(</td>
          <td class="paramtype">MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>hess</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check if Hessian positive definite (matrix assumed to be dense &amp; small since dim(theta) small) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">updates</td><td>hessian to only the diagonal entries if not positive definite. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a240a43fde6a2e26c30275b24f99f5d4e" name="a240a43fde6a2e26c30275b24f99f5d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a240a43fde6a2e26c30275b24f99f5d4e">&#9670;&#160;</a></span>check_pos_def() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::check_pos_def </td>
          <td>(</td>
          <td class="paramtype">MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>hess</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check if Hessian positive definite (matrix assumed to be dense &amp; small since dim(theta) small) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">updates</td><td>hessian to only the diagonal entries if not positive definite. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a240a43fde6a2e26c30275b24f99f5d4e" name="a240a43fde6a2e26c30275b24f99f5d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a240a43fde6a2e26c30275b24f99f5d4e">&#9670;&#160;</a></span>check_pos_def() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::check_pos_def </td>
          <td>(</td>
          <td class="paramtype">MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>hess</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check if Hessian positive definite (matrix assumed to be dense &amp; small since dim(theta) small) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">updates</td><td>hessian to only the diagonal entries if not positive definite. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a240a43fde6a2e26c30275b24f99f5d4e" name="a240a43fde6a2e26c30275b24f99f5d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a240a43fde6a2e26c30275b24f99f5d4e">&#9670;&#160;</a></span>check_pos_def() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::check_pos_def </td>
          <td>(</td>
          <td class="paramtype">MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>hess</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check if Hessian positive definite (matrix assumed to be dense &amp; small since dim(theta) small) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">updates</td><td>hessian to only the diagonal entries if not positive definite. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a240a43fde6a2e26c30275b24f99f5d4e" name="a240a43fde6a2e26c30275b24f99f5d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a240a43fde6a2e26c30275b24f99f5d4e">&#9670;&#160;</a></span>check_pos_def() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::check_pos_def </td>
          <td>(</td>
          <td class="paramtype">MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>hess</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check if Hessian positive definite (matrix assumed to be dense &amp; small since dim(theta) small) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">updates</td><td>hessian to only the diagonal entries if not positive definite. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a240a43fde6a2e26c30275b24f99f5d4e" name="a240a43fde6a2e26c30275b24f99f5d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a240a43fde6a2e26c30275b24f99f5d4e">&#9670;&#160;</a></span>check_pos_def() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::check_pos_def </td>
          <td>(</td>
          <td class="paramtype">MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>hess</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check if Hessian positive definite (matrix assumed to be dense &amp; small since dim(theta) small) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">updates</td><td>hessian to only the diagonal entries if not positive definite. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a240a43fde6a2e26c30275b24f99f5d4e" name="a240a43fde6a2e26c30275b24f99f5d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a240a43fde6a2e26c30275b24f99f5d4e">&#9670;&#160;</a></span>check_pos_def() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::check_pos_def </td>
          <td>(</td>
          <td class="paramtype">MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>hess</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check if Hessian positive definite (matrix assumed to be dense &amp; small since dim(theta) small) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">updates</td><td>hessian to only the diagonal entries if not positive definite. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e35cd65f1a96171c9bb2eb51197e054" name="a3e35cd65f1a96171c9bb2eb51197e054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e35cd65f1a96171c9bb2eb51197e054">&#9670;&#160;</a></span>compute_marginals_y()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::compute_marginals_y </td>
          <td>(</td>
          <td class="paramtype">SpMat &amp;&#160;</td>
          <td class="paramname"><em>Qinv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpRmMat &amp;&#160;</td>
          <td class="paramname"><em>Ax_all</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>projMargVar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the marginal variances at all locations y, (defined through projection matrix), i.e. nrows(y) must equal nrows(Ax) computed as marg_var_y = diag(A*Qinv*A^T) function provides optimized matrix multiplications for this use case. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Qinv</td><td>must contain relevant inverse elements </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Vector</td><td>marg_var_y </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af4ccd433b0980957378ce768d1edd1fa" name="af4ccd433b0980957378ce768d1edd1fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4ccd433b0980957378ce768d1edd1fa">&#9670;&#160;</a></span>cond_LogPoisLik()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double PostTheta::cond_LogPoisLik </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>eta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>evaluate log Poisson likelihood </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eta</td><td>Vector. linear predictor eta = A*x </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f_val</td><td>double. evaluated log density </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acab609440015d89151088d88d22743a9" name="acab609440015d89151088d88d22743a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acab609440015d89151088d88d22743a9">&#9670;&#160;</a></span>cond_LogPriorLat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double PostTheta::cond_LogPriorLat </td>
          <td>(</td>
          <td class="paramtype">SpMat &amp;&#160;</td>
          <td class="paramname"><em>Qprior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>evaluate Gaussian log prior (without log determinant!!), mean assumed to be zero </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Qprior</td><td>precision matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>current x vector </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f_val</td><td>evaluated log density </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae16e0d7a8f7be90183994aa20bead02" name="aae16e0d7a8f7be90183994aa20bead02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae16e0d7a8f7be90183994aa20bead02">&#9670;&#160;</a></span>cond_negLogBinom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double PostTheta::cond_negLogBinom </td>
          <td>(</td>
          <td class="paramtype">SpMat &amp;&#160;</td>
          <td class="paramname"><em>Qprior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>evaluate negative condiational log Poisson + Gaussian prior </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">extraCoeffVecLik</td><td>Vector. ntrials. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Qprior</td><td>SpMat. precision matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Vector. current vector x. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f_val</td><td>double. evaluated negative log density </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae8164624f557686c53b8710370f8e284" name="ae8164624f557686c53b8710370f8e284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8164624f557686c53b8710370f8e284">&#9670;&#160;</a></span>cond_negLogBinomLik()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double PostTheta::cond_negLogBinomLik </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>eta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>evaluate negative log Binomial likelihood </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">extraCoeffVecLik</td><td>Vector. ntrials. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eta</td><td>Vector. linear predictor eta = A*x. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f_val</td><td>double. evaluated negative log density. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7e1701ddb453651f4cfb4cb55090212" name="ad7e1701ddb453651f4cfb4cb55090212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7e1701ddb453651f4cfb4cb55090212">&#9670;&#160;</a></span>cond_negLogDist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double PostTheta::cond_negLogDist </td>
          <td>(</td>
          <td class="paramtype">SpMat &amp;&#160;</td>
          <td class="paramname"><em>Qprior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; double(Vect &amp;, Vect &amp;)&gt;&#160;</td>
          <td class="paramname"><em>lik_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>evaluate negative condiational log likelihood + Gaussian prior </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">extraCoeffVecLik</td><td>Vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Qprior</td><td>SpMat. precision matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Vector. current vector x. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lik_func</td><td>function. defines the likelihood </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f_val</td><td>double. evaluated negative log density </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f55646f57619e97c20489ec846c984f" name="a4f55646f57619e97c20489ec846c984f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f55646f57619e97c20489ec846c984f">&#9670;&#160;</a></span>cond_negLogPois()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double PostTheta::cond_negLogPois </td>
          <td>(</td>
          <td class="paramtype">SpMat &amp;&#160;</td>
          <td class="paramname"><em>Qprior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>evaluate negative condiational log Poisson + Gaussian prior </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Qprior</td><td>SpMat. precision matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Vector. current vector x. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f_val</td><td>double. evaluated negative log density </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aebfe9fe1b43f43755e663c10b539b4df" name="aebfe9fe1b43f43755e663c10b539b4df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebfe9fe1b43f43755e663c10b539b4df">&#9670;&#160;</a></span>cond_negLogPoisLik()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double PostTheta::cond_negLogPoisLik </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>eta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>evaluate negative log Poisson likelihood </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eta</td><td>Vector. linear predictor eta = A*x </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f_val</td><td>double. evaluated negative log density </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af69559f2f98cbdd4b844a9e0c571d64d" name="af69559f2f98cbdd4b844a9e0c571d64d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af69559f2f98cbdd4b844a9e0c571d64d">&#9670;&#160;</a></span>construct_b() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::construct_b </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble right-handside. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rhs</td><td>right-handside /todo Could compute Ax^T*y once, and only multiply with appropriate exp_theta. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af69559f2f98cbdd4b844a9e0c571d64d" name="af69559f2f98cbdd4b844a9e0c571d64d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af69559f2f98cbdd4b844a9e0c571d64d">&#9670;&#160;</a></span>construct_b() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::construct_b </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble right-handside. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rhs</td><td>right-handside /todo Could compute Ax^T*y once, and only multiply with appropriate exp_theta. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af69559f2f98cbdd4b844a9e0c571d64d" name="af69559f2f98cbdd4b844a9e0c571d64d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af69559f2f98cbdd4b844a9e0c571d64d">&#9670;&#160;</a></span>construct_b() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::construct_b </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble right-handside. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rhs</td><td>right-handside /todo Could compute Ax^T*y once, and only multiply with appropriate exp_theta. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af69559f2f98cbdd4b844a9e0c571d64d" name="af69559f2f98cbdd4b844a9e0c571d64d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af69559f2f98cbdd4b844a9e0c571d64d">&#9670;&#160;</a></span>construct_b() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::construct_b </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble right-handside. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rhs</td><td>right-handside /todo Could compute Ax^T*y once, and only multiply with appropriate exp_theta. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af69559f2f98cbdd4b844a9e0c571d64d" name="af69559f2f98cbdd4b844a9e0c571d64d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af69559f2f98cbdd4b844a9e0c571d64d">&#9670;&#160;</a></span>construct_b() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::construct_b </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble right-handside. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rhs</td><td>right-handside /todo Could compute Ax^T*y once, and only multiply with appropriate exp_theta. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af69559f2f98cbdd4b844a9e0c571d64d" name="af69559f2f98cbdd4b844a9e0c571d64d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af69559f2f98cbdd4b844a9e0c571d64d">&#9670;&#160;</a></span>construct_b() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::construct_b </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble right-handside. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rhs</td><td>right-handside /todo Could compute Ax^T*y once, and only multiply with appropriate exp_theta. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af69559f2f98cbdd4b844a9e0c571d64d" name="af69559f2f98cbdd4b844a9e0c571d64d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af69559f2f98cbdd4b844a9e0c571d64d">&#9670;&#160;</a></span>construct_b() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::construct_b </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble right-handside. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rhs</td><td>right-handside /todo Could compute Ax^T*y once, and only multiply with appropriate exp_theta. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af69559f2f98cbdd4b844a9e0c571d64d" name="af69559f2f98cbdd4b844a9e0c571d64d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af69559f2f98cbdd4b844a9e0c571d64d">&#9670;&#160;</a></span>construct_b() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::construct_b </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble right-handside. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rhs</td><td>right-handside /todo Could compute Ax^T*y once, and only multiply with appropriate exp_theta. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af69559f2f98cbdd4b844a9e0c571d64d" name="af69559f2f98cbdd4b844a9e0c571d64d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af69559f2f98cbdd4b844a9e0c571d64d">&#9670;&#160;</a></span>construct_b() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::construct_b </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble right-handside. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rhs</td><td>right-handside /todo Could compute Ax^T*y once, and only multiply with appropriate exp_theta. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af69559f2f98cbdd4b844a9e0c571d64d" name="af69559f2f98cbdd4b844a9e0c571d64d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af69559f2f98cbdd4b844a9e0c571d64d">&#9670;&#160;</a></span>construct_b() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::construct_b </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assemble right-handside. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rhs</td><td>right-handside /todo Could compute Ax^T*y once, and only multiply with appropriate exp_theta. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb642337f6f4db477be2318bb9796f2c" name="acb642337f6f4db477be2318bb9796f2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb642337f6f4db477be2318bb9796f2c">&#9670;&#160;</a></span>construct_Q() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::construct_Q </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat &amp;&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>construct precision matrix. Calls spatial, spatial-temporal, etc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Q</td><td>fills precision matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb642337f6f4db477be2318bb9796f2c" name="acb642337f6f4db477be2318bb9796f2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb642337f6f4db477be2318bb9796f2c">&#9670;&#160;</a></span>construct_Q() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::construct_Q </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat &amp;&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>construct precision matrix. Calls spatial, spatial-temporal, etc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Q</td><td>fills precision matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb642337f6f4db477be2318bb9796f2c" name="acb642337f6f4db477be2318bb9796f2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb642337f6f4db477be2318bb9796f2c">&#9670;&#160;</a></span>construct_Q() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::construct_Q </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat &amp;&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>construct precision matrix. Calls spatial, spatial-temporal, etc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Q</td><td>fills precision matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb642337f6f4db477be2318bb9796f2c" name="acb642337f6f4db477be2318bb9796f2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb642337f6f4db477be2318bb9796f2c">&#9670;&#160;</a></span>construct_Q() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::construct_Q </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat &amp;&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>construct precision matrix. Calls spatial, spatial-temporal, etc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Q</td><td>fills precision matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb642337f6f4db477be2318bb9796f2c" name="acb642337f6f4db477be2318bb9796f2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb642337f6f4db477be2318bb9796f2c">&#9670;&#160;</a></span>construct_Q() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::construct_Q </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat &amp;&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>construct precision matrix. Calls spatial, spatial-temporal, etc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Q</td><td>fills precision matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb642337f6f4db477be2318bb9796f2c" name="acb642337f6f4db477be2318bb9796f2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb642337f6f4db477be2318bb9796f2c">&#9670;&#160;</a></span>construct_Q() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::construct_Q </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat &amp;&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>construct precision matrix. Calls spatial, spatial-temporal, etc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Q</td><td>fills precision matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb642337f6f4db477be2318bb9796f2c" name="acb642337f6f4db477be2318bb9796f2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb642337f6f4db477be2318bb9796f2c">&#9670;&#160;</a></span>construct_Q() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::construct_Q </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat &amp;&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>construct precision matrix. Calls spatial, spatial-temporal, etc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Q</td><td>fills precision matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb642337f6f4db477be2318bb9796f2c" name="acb642337f6f4db477be2318bb9796f2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb642337f6f4db477be2318bb9796f2c">&#9670;&#160;</a></span>construct_Q() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::construct_Q </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat &amp;&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>construct precision matrix. Calls spatial, spatial-temporal, etc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Q</td><td>fills precision matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb642337f6f4db477be2318bb9796f2c" name="acb642337f6f4db477be2318bb9796f2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb642337f6f4db477be2318bb9796f2c">&#9670;&#160;</a></span>construct_Q() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::construct_Q </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat &amp;&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>construct precision matrix. Calls spatial, spatial-temporal, etc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Q</td><td>fills precision matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75d95efb35ba09080558cb9817deed67" name="a75d95efb35ba09080558cb9817deed67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75d95efb35ba09080558cb9817deed67">&#9670;&#160;</a></span>construct_Q() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::construct_Q </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat &amp;&#160;</td>
          <td class="paramname"><em>Q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>construct precision matrix. Calls spatial, spatial-temporal, etc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mu</td><td>mode latent parameters </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Q</td><td>fills precision matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac41faf4a6b8b2a30168f35805c2c7b3f" name="ac41faf4a6b8b2a30168f35805c2c7b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac41faf4a6b8b2a30168f35805c2c7b3f">&#9670;&#160;</a></span>construct_Q_spat_temp() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::construct_Q_spat_temp </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat &amp;&#160;</td>
          <td class="paramname"><em>Qst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>spatial temporal model : SPDE discretisation. DEMF(1,2,1) model. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Qst</td><td>fills spatial-temporal precision matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac41faf4a6b8b2a30168f35805c2c7b3f" name="ac41faf4a6b8b2a30168f35805c2c7b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac41faf4a6b8b2a30168f35805c2c7b3f">&#9670;&#160;</a></span>construct_Q_spat_temp() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::construct_Q_spat_temp </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat &amp;&#160;</td>
          <td class="paramname"><em>Qst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>spatial temporal model : SPDE discretisation. DEMF(1,2,1) model. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Qst</td><td>fills spatial-temporal precision matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac41faf4a6b8b2a30168f35805c2c7b3f" name="ac41faf4a6b8b2a30168f35805c2c7b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac41faf4a6b8b2a30168f35805c2c7b3f">&#9670;&#160;</a></span>construct_Q_spat_temp() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::construct_Q_spat_temp </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat &amp;&#160;</td>
          <td class="paramname"><em>Qst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>spatial temporal model : SPDE discretisation. DEMF(1,2,1) model. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Qst</td><td>fills spatial-temporal precision matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac41faf4a6b8b2a30168f35805c2c7b3f" name="ac41faf4a6b8b2a30168f35805c2c7b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac41faf4a6b8b2a30168f35805c2c7b3f">&#9670;&#160;</a></span>construct_Q_spat_temp() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::construct_Q_spat_temp </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat &amp;&#160;</td>
          <td class="paramname"><em>Qst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>spatial temporal model : SPDE discretisation. DEMF(1,2,1) model. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Qst</td><td>fills spatial-temporal precision matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac41faf4a6b8b2a30168f35805c2c7b3f" name="ac41faf4a6b8b2a30168f35805c2c7b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac41faf4a6b8b2a30168f35805c2c7b3f">&#9670;&#160;</a></span>construct_Q_spat_temp() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::construct_Q_spat_temp </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat &amp;&#160;</td>
          <td class="paramname"><em>Qst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>spatial temporal model : SPDE discretisation. DEMF(1,2,1) model. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Qst</td><td>fills spatial-temporal precision matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac41faf4a6b8b2a30168f35805c2c7b3f" name="ac41faf4a6b8b2a30168f35805c2c7b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac41faf4a6b8b2a30168f35805c2c7b3f">&#9670;&#160;</a></span>construct_Q_spat_temp() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::construct_Q_spat_temp </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat &amp;&#160;</td>
          <td class="paramname"><em>Qst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>spatial temporal model : SPDE discretisation. DEMF(1,2,1) model. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Qst</td><td>fills spatial-temporal precision matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac41faf4a6b8b2a30168f35805c2c7b3f" name="ac41faf4a6b8b2a30168f35805c2c7b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac41faf4a6b8b2a30168f35805c2c7b3f">&#9670;&#160;</a></span>construct_Q_spat_temp() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::construct_Q_spat_temp </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat &amp;&#160;</td>
          <td class="paramname"><em>Qst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>spatial temporal model : SPDE discretisation. DEMF(1,2,1) model. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Qst</td><td>fills spatial-temporal precision matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac41faf4a6b8b2a30168f35805c2c7b3f" name="ac41faf4a6b8b2a30168f35805c2c7b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac41faf4a6b8b2a30168f35805c2c7b3f">&#9670;&#160;</a></span>construct_Q_spat_temp() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::construct_Q_spat_temp </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat &amp;&#160;</td>
          <td class="paramname"><em>Qst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>spatial temporal model : SPDE discretisation. DEMF(1,2,1) model. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Qst</td><td>fills spatial-temporal precision matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac41faf4a6b8b2a30168f35805c2c7b3f" name="ac41faf4a6b8b2a30168f35805c2c7b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac41faf4a6b8b2a30168f35805c2c7b3f">&#9670;&#160;</a></span>construct_Q_spat_temp() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::construct_Q_spat_temp </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat &amp;&#160;</td>
          <td class="paramname"><em>Qst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>spatial temporal model : SPDE discretisation. DEMF(1,2,1) model. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Qst</td><td>fills spatial-temporal precision matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac41faf4a6b8b2a30168f35805c2c7b3f" name="ac41faf4a6b8b2a30168f35805c2c7b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac41faf4a6b8b2a30168f35805c2c7b3f">&#9670;&#160;</a></span>construct_Q_spat_temp() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::construct_Q_spat_temp </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat &amp;&#160;</td>
          <td class="paramname"><em>Qst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>spatial temporal model : SPDE discretisation. DEMF(1,2,1) model. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Qst</td><td>fills spatial-temporal precision matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ceec7e512bf71ca7267f01733ec8719" name="a2ceec7e512bf71ca7267f01733ec8719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ceec7e512bf71ca7267f01733ec8719">&#9670;&#160;</a></span>construct_Q_spatial() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::construct_Q_spatial </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat &amp;&#160;</td>
          <td class="paramname"><em>Qs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>spatial model : SPDE discretisation &ndash; matrix construction </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Qs</td><td>fills spatial precision matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ceec7e512bf71ca7267f01733ec8719" name="a2ceec7e512bf71ca7267f01733ec8719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ceec7e512bf71ca7267f01733ec8719">&#9670;&#160;</a></span>construct_Q_spatial() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::construct_Q_spatial </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat &amp;&#160;</td>
          <td class="paramname"><em>Qs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>spatial model : SPDE discretisation &ndash; matrix construction </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Qs</td><td>fills spatial precision matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ceec7e512bf71ca7267f01733ec8719" name="a2ceec7e512bf71ca7267f01733ec8719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ceec7e512bf71ca7267f01733ec8719">&#9670;&#160;</a></span>construct_Q_spatial() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::construct_Q_spatial </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat &amp;&#160;</td>
          <td class="paramname"><em>Qs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>spatial model : SPDE discretisation &ndash; matrix construction </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Qs</td><td>fills spatial precision matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ceec7e512bf71ca7267f01733ec8719" name="a2ceec7e512bf71ca7267f01733ec8719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ceec7e512bf71ca7267f01733ec8719">&#9670;&#160;</a></span>construct_Q_spatial() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::construct_Q_spatial </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat &amp;&#160;</td>
          <td class="paramname"><em>Qs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>spatial model : SPDE discretisation &ndash; matrix construction </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Qs</td><td>fills spatial precision matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ceec7e512bf71ca7267f01733ec8719" name="a2ceec7e512bf71ca7267f01733ec8719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ceec7e512bf71ca7267f01733ec8719">&#9670;&#160;</a></span>construct_Q_spatial() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::construct_Q_spatial </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat &amp;&#160;</td>
          <td class="paramname"><em>Qs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>spatial model : SPDE discretisation &ndash; matrix construction </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Qs</td><td>fills spatial precision matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ceec7e512bf71ca7267f01733ec8719" name="a2ceec7e512bf71ca7267f01733ec8719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ceec7e512bf71ca7267f01733ec8719">&#9670;&#160;</a></span>construct_Q_spatial() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::construct_Q_spatial </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat &amp;&#160;</td>
          <td class="paramname"><em>Qs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>spatial model : SPDE discretisation &ndash; matrix construction </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Qs</td><td>fills spatial precision matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ceec7e512bf71ca7267f01733ec8719" name="a2ceec7e512bf71ca7267f01733ec8719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ceec7e512bf71ca7267f01733ec8719">&#9670;&#160;</a></span>construct_Q_spatial() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::construct_Q_spatial </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat &amp;&#160;</td>
          <td class="paramname"><em>Qs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>spatial model : SPDE discretisation &ndash; matrix construction </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Qs</td><td>fills spatial precision matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ceec7e512bf71ca7267f01733ec8719" name="a2ceec7e512bf71ca7267f01733ec8719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ceec7e512bf71ca7267f01733ec8719">&#9670;&#160;</a></span>construct_Q_spatial() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::construct_Q_spatial </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat &amp;&#160;</td>
          <td class="paramname"><em>Qs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>spatial model : SPDE discretisation &ndash; matrix construction </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Qs</td><td>fills spatial precision matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ceec7e512bf71ca7267f01733ec8719" name="a2ceec7e512bf71ca7267f01733ec8719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ceec7e512bf71ca7267f01733ec8719">&#9670;&#160;</a></span>construct_Q_spatial() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::construct_Q_spatial </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat &amp;&#160;</td>
          <td class="paramname"><em>Qs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>spatial model : SPDE discretisation &ndash; matrix construction </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Qs</td><td>fills spatial precision matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ceec7e512bf71ca7267f01733ec8719" name="a2ceec7e512bf71ca7267f01733ec8719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ceec7e512bf71ca7267f01733ec8719">&#9670;&#160;</a></span>construct_Q_spatial() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::construct_Q_spatial </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat &amp;&#160;</td>
          <td class="paramname"><em>Qs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>spatial model : SPDE discretisation &ndash; matrix construction </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Qs</td><td>fills spatial precision matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aacf285fc1b81d2b4f694a3fa1d92c5b8" name="aacf285fc1b81d2b4f694a3fa1d92c5b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacf285fc1b81d2b4f694a3fa1d92c5b8">&#9670;&#160;</a></span>construct_Qprior()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::construct_Qprior </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat &amp;&#160;</td>
          <td class="paramname"><em>Qprior</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>construct precision matrix without data Calls spatial, spatial-temporal, etc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Q</td><td>fills precision matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada9c36637820d3eaad19d4b3449c98ad" name="ada9c36637820d3eaad19d4b3449c98ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada9c36637820d3eaad19d4b3449c98ad">&#9670;&#160;</a></span>convert_interpret2theta() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::convert_interpret2theta </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ranS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ranT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>lgamE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>lgamS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>lgamT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert hyperparameters theta from the interpretable parametrisation to the model parametrisation ie. from log(sigma.u, rangeS, rangeT) to log(gamma_E, gamma_s, gamma_t) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">log(sigma.u)</td><td>precision of random effects </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log(ranS)</td><td>spatial range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log(ranT)</td><td>temporal range </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(gamma_E)</td><td></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(gamma_s)</td><td></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(gamma_t)</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada9c36637820d3eaad19d4b3449c98ad" name="ada9c36637820d3eaad19d4b3449c98ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada9c36637820d3eaad19d4b3449c98ad">&#9670;&#160;</a></span>convert_interpret2theta() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::convert_interpret2theta </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ranS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ranT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>lgamE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>lgamS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>lgamT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert hyperparameters theta from the interpretable parametrisation to the model parametrisation ie. from log(sigma.u, rangeS, rangeT) to log(gamma_E, gamma_s, gamma_t) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">log(sigma.u)</td><td>precision of random effects </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log(ranS)</td><td>spatial range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log(ranT)</td><td>temporal range </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(gamma_E)</td><td></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(gamma_s)</td><td></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(gamma_t)</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada9c36637820d3eaad19d4b3449c98ad" name="ada9c36637820d3eaad19d4b3449c98ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada9c36637820d3eaad19d4b3449c98ad">&#9670;&#160;</a></span>convert_interpret2theta() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::convert_interpret2theta </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ranS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ranT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>lgamE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>lgamS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>lgamT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert hyperparameters theta from the interpretable parametrisation to the model parametrisation ie. from log(sigma.u, rangeS, rangeT) to log(gamma_E, gamma_s, gamma_t) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">log(sigma.u)</td><td>precision of random effects </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log(ranS)</td><td>spatial range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log(ranT)</td><td>temporal range </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(gamma_E)</td><td></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(gamma_s)</td><td></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(gamma_t)</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada9c36637820d3eaad19d4b3449c98ad" name="ada9c36637820d3eaad19d4b3449c98ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada9c36637820d3eaad19d4b3449c98ad">&#9670;&#160;</a></span>convert_interpret2theta() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::convert_interpret2theta </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ranS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ranT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>lgamE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>lgamS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>lgamT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert hyperparameters theta from the interpretable parametrisation to the model parametrisation ie. from log(sigma.u, rangeS, rangeT) to log(gamma_E, gamma_s, gamma_t) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">log(sigma.u)</td><td>precision of random effects </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log(ranS)</td><td>spatial range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log(ranT)</td><td>temporal range </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(gamma_E)</td><td></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(gamma_s)</td><td></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(gamma_t)</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada9c36637820d3eaad19d4b3449c98ad" name="ada9c36637820d3eaad19d4b3449c98ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada9c36637820d3eaad19d4b3449c98ad">&#9670;&#160;</a></span>convert_interpret2theta() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::convert_interpret2theta </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ranS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ranT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>lgamE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>lgamS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>lgamT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert hyperparameters theta from the interpretable parametrisation to the model parametrisation ie. from log(sigma.u, rangeS, rangeT) to log(gamma_E, gamma_s, gamma_t) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">log(sigma.u)</td><td>precision of random effects </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log(ranS)</td><td>spatial range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log(ranT)</td><td>temporal range </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(gamma_E)</td><td></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(gamma_s)</td><td></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(gamma_t)</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada9c36637820d3eaad19d4b3449c98ad" name="ada9c36637820d3eaad19d4b3449c98ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada9c36637820d3eaad19d4b3449c98ad">&#9670;&#160;</a></span>convert_interpret2theta() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::convert_interpret2theta </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ranS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ranT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>lgamE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>lgamS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>lgamT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert hyperparameters theta from the interpretable parametrisation to the model parametrisation ie. from log(sigma.u, rangeS, rangeT) to log(gamma_E, gamma_s, gamma_t) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">log(sigma.u)</td><td>precision of random effects </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log(ranS)</td><td>spatial range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log(ranT)</td><td>temporal range </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(gamma_E)</td><td></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(gamma_s)</td><td></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(gamma_t)</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada9c36637820d3eaad19d4b3449c98ad" name="ada9c36637820d3eaad19d4b3449c98ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada9c36637820d3eaad19d4b3449c98ad">&#9670;&#160;</a></span>convert_interpret2theta() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::convert_interpret2theta </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ranS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ranT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>lgamE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>lgamS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>lgamT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert hyperparameters theta from the interpretable parametrisation to the model parametrisation ie. from log(sigma.u, rangeS, rangeT) to log(gamma_E, gamma_s, gamma_t) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">log(sigma.u)</td><td>precision of random effects </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log(ranS)</td><td>spatial range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log(ranT)</td><td>temporal range </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(gamma_E)</td><td></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(gamma_s)</td><td></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(gamma_t)</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada9c36637820d3eaad19d4b3449c98ad" name="ada9c36637820d3eaad19d4b3449c98ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada9c36637820d3eaad19d4b3449c98ad">&#9670;&#160;</a></span>convert_interpret2theta() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::convert_interpret2theta </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ranS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ranT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>lgamE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>lgamS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>lgamT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert hyperparameters theta from the interpretable parametrisation to the model parametrisation ie. from log(sigma.u, rangeS, rangeT) to log(gamma_E, gamma_s, gamma_t) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">log(sigma.u)</td><td>precision of random effects </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log(ranS)</td><td>spatial range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log(ranT)</td><td>temporal range </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(gamma_E)</td><td></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(gamma_s)</td><td></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(gamma_t)</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1106be4ac083bf08aa93fd38e7a24764" name="a1106be4ac083bf08aa93fd38e7a24764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1106be4ac083bf08aa93fd38e7a24764">&#9670;&#160;</a></span>convert_interpret2theta_spat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::convert_interpret2theta_spat </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lranS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lsigU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>lgamS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>lgamE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert hyperparameters theta from the interpretable parametrisation to the model parametrisation ie. from log(rangeS, sigma.u) to log(gamma_s, gamma_E) for spatial model order 2 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">log(ranS)</td><td>spatial range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log(sigma.u)</td><td>precision of random effects </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(gamma_s)</td><td></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(gamma_E)</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1106be4ac083bf08aa93fd38e7a24764" name="a1106be4ac083bf08aa93fd38e7a24764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1106be4ac083bf08aa93fd38e7a24764">&#9670;&#160;</a></span>convert_interpret2theta_spat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::convert_interpret2theta_spat </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lranS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lsigU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>lgamS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>lgamE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert hyperparameters theta from the interpretable parametrisation to the model parametrisation ie. from log(rangeS, sigma.u) to log(gamma_s, gamma_E) for spatial model order 2 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">log(ranS)</td><td>spatial range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log(sigma.u)</td><td>precision of random effects </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(gamma_s)</td><td></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(gamma_E)</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9fecf779db9e24870fa0c21ac556399e" name="a9fecf779db9e24870fa0c21ac556399e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fecf779db9e24870fa0c21ac556399e">&#9670;&#160;</a></span>convert_interpret2theta_spatTemp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::convert_interpret2theta_spatTemp </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ranS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ranT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>lgamE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>lgamS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>lgamT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert hyperparameters theta from the interpretable parametrisation to the model parametrisation ie. from log(sigma.u, rangeS, rangeT) to log(gamma_E, gamma_s, gamma_t) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">log(sigma.u)</td><td>precision of random effects </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log(ranS)</td><td>spatial range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log(ranT)</td><td>temporal range </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(gamma_E)</td><td></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(gamma_s)</td><td></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(gamma_t)</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9fecf779db9e24870fa0c21ac556399e" name="a9fecf779db9e24870fa0c21ac556399e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fecf779db9e24870fa0c21ac556399e">&#9670;&#160;</a></span>convert_interpret2theta_spatTemp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::convert_interpret2theta_spatTemp </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ranS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ranT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>lgamE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>lgamS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>lgamT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert hyperparameters theta from the interpretable parametrisation to the model parametrisation ie. from log(sigma.u, rangeS, rangeT) to log(gamma_E, gamma_s, gamma_t) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">log(sigma.u)</td><td>precision of random effects </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log(ranS)</td><td>spatial range </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log(ranT)</td><td>temporal range </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(gamma_E)</td><td></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(gamma_s)</td><td></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(gamma_t)</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adfdc66118e93525b7814f53c6b50e652" name="adfdc66118e93525b7814f53c6b50e652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfdc66118e93525b7814f53c6b50e652">&#9670;&#160;</a></span>convert_theta2interpret() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::convert_theta2interpret </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lgamE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lgamS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lgamT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>sigU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>ranS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>ranT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert hyperparameters theta from the model parametrisation to the interpretable parametrisation ie. from log(gamma_E, gamma_s, gamma_t) to log(sigma.u, rangeS, rangeT) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">log(gamma_E)</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log(gamma_s)</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log(gamma_t)</td><td></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(sigma.u)</td><td>precision of random effects </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(ranS)</td><td>spatial range </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(ranT)</td><td>temporal range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adfdc66118e93525b7814f53c6b50e652" name="adfdc66118e93525b7814f53c6b50e652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfdc66118e93525b7814f53c6b50e652">&#9670;&#160;</a></span>convert_theta2interpret() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::convert_theta2interpret </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lgamE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lgamS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lgamT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>sigU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>ranS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>ranT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert hyperparameters theta from the model parametrisation to the interpretable parametrisation ie. from log(gamma_E, gamma_s, gamma_t) to log(sigma.u, rangeS, rangeT) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">log(gamma_E)</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log(gamma_s)</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log(gamma_t)</td><td></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(sigma.u)</td><td>precision of random effects </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(ranS)</td><td>spatial range </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(ranT)</td><td>temporal range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adfdc66118e93525b7814f53c6b50e652" name="adfdc66118e93525b7814f53c6b50e652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfdc66118e93525b7814f53c6b50e652">&#9670;&#160;</a></span>convert_theta2interpret() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::convert_theta2interpret </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lgamE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lgamS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lgamT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>sigU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>ranS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>ranT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert hyperparameters theta from the model parametrisation to the interpretable parametrisation ie. from log(gamma_E, gamma_s, gamma_t) to log(sigma.u, rangeS, rangeT) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">log(gamma_E)</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log(gamma_s)</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log(gamma_t)</td><td></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(sigma.u)</td><td>precision of random effects </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(ranS)</td><td>spatial range </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(ranT)</td><td>temporal range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adfdc66118e93525b7814f53c6b50e652" name="adfdc66118e93525b7814f53c6b50e652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfdc66118e93525b7814f53c6b50e652">&#9670;&#160;</a></span>convert_theta2interpret() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::convert_theta2interpret </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lgamE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lgamS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lgamT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>sigU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>ranS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>ranT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert hyperparameters theta from the model parametrisation to the interpretable parametrisation ie. from log(gamma_E, gamma_s, gamma_t) to log(sigma.u, rangeS, rangeT) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">log(gamma_E)</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log(gamma_s)</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log(gamma_t)</td><td></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(sigma.u)</td><td>precision of random effects </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(ranS)</td><td>spatial range </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(ranT)</td><td>temporal range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adfdc66118e93525b7814f53c6b50e652" name="adfdc66118e93525b7814f53c6b50e652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfdc66118e93525b7814f53c6b50e652">&#9670;&#160;</a></span>convert_theta2interpret() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::convert_theta2interpret </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lgamE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lgamS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lgamT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>sigU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>ranS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>ranT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert hyperparameters theta from the model parametrisation to the interpretable parametrisation ie. from log(gamma_E, gamma_s, gamma_t) to log(sigma.u, rangeS, rangeT) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">log(gamma_E)</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log(gamma_s)</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log(gamma_t)</td><td></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(sigma.u)</td><td>precision of random effects </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(ranS)</td><td>spatial range </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(ranT)</td><td>temporal range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adfdc66118e93525b7814f53c6b50e652" name="adfdc66118e93525b7814f53c6b50e652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfdc66118e93525b7814f53c6b50e652">&#9670;&#160;</a></span>convert_theta2interpret() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::convert_theta2interpret </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lgamE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lgamS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lgamT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>sigU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>ranS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>ranT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert hyperparameters theta from the model parametrisation to the interpretable parametrisation ie. from log(gamma_E, gamma_s, gamma_t) to log(sigma.u, rangeS, rangeT) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">log(gamma_E)</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log(gamma_s)</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log(gamma_t)</td><td></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(sigma.u)</td><td>precision of random effects </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(ranS)</td><td>spatial range </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(ranT)</td><td>temporal range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adfdc66118e93525b7814f53c6b50e652" name="adfdc66118e93525b7814f53c6b50e652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfdc66118e93525b7814f53c6b50e652">&#9670;&#160;</a></span>convert_theta2interpret() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::convert_theta2interpret </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lgamE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lgamS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lgamT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>sigU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>ranS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>ranT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert hyperparameters theta from the model parametrisation to the interpretable parametrisation ie. from log(gamma_E, gamma_s, gamma_t) to log(sigma.u, rangeS, rangeT) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">log(gamma_E)</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log(gamma_s)</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log(gamma_t)</td><td></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(sigma.u)</td><td>precision of random effects </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(ranS)</td><td>spatial range </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(ranT)</td><td>temporal range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adfdc66118e93525b7814f53c6b50e652" name="adfdc66118e93525b7814f53c6b50e652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfdc66118e93525b7814f53c6b50e652">&#9670;&#160;</a></span>convert_theta2interpret() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::convert_theta2interpret </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lgamE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lgamS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lgamT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>sigU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>ranS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>ranT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert hyperparameters theta from the model parametrisation to the interpretable parametrisation ie. from log(gamma_E, gamma_s, gamma_t) to log(sigma.u, rangeS, rangeT) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">log(gamma_E)</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log(gamma_s)</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log(gamma_t)</td><td></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(sigma.u)</td><td>precision of random effects </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(ranS)</td><td>spatial range </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(ranT)</td><td>temporal range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae9138a56d91cdca73cc350d3d5011734" name="ae9138a56d91cdca73cc350d3d5011734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9138a56d91cdca73cc350d3d5011734">&#9670;&#160;</a></span>convert_theta2interpret_spat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::convert_theta2interpret_spat </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lgamS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lgamE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>lranS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>lsigU</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert hyperparameters theta from the interpretable parametrisation to the model parametrisation ie. from log(rangeS, sigma.u) to log(gamma_s, gamma_E) for spatial model order 2 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">log(gamma_s)</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log(gamma_E)</td><td></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(ranS)</td><td>spatial range </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(sigma.u)</td><td>precision of random effects </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae9138a56d91cdca73cc350d3d5011734" name="ae9138a56d91cdca73cc350d3d5011734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9138a56d91cdca73cc350d3d5011734">&#9670;&#160;</a></span>convert_theta2interpret_spat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::convert_theta2interpret_spat </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lgamS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lgamE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>lranS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>lsigU</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert hyperparameters theta from the interpretable parametrisation to the model parametrisation ie. from log(rangeS, sigma.u) to log(gamma_s, gamma_E) for spatial model order 2 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">log(gamma_s)</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log(gamma_E)</td><td></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(ranS)</td><td>spatial range </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(sigma.u)</td><td>precision of random effects </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed82a7d83d895a856f6841b9ef701783" name="aed82a7d83d895a856f6841b9ef701783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed82a7d83d895a856f6841b9ef701783">&#9670;&#160;</a></span>convert_theta2interpret_spatTemp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::convert_theta2interpret_spatTemp </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lgamE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lgamS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lgamT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>sigU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>ranS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>ranT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert hyperparameters theta from the model parametrisation to the interpretable parametrisation ie. from log(gamma_E, gamma_s, gamma_t) to log(sigma.u, rangeS, rangeT) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">log(gamma_E)</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log(gamma_s)</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log(gamma_t)</td><td></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(sigma.u)</td><td>precision of random effects </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(ranS)</td><td>spatial range </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(ranT)</td><td>temporal range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed82a7d83d895a856f6841b9ef701783" name="aed82a7d83d895a856f6841b9ef701783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed82a7d83d895a856f6841b9ef701783">&#9670;&#160;</a></span>convert_theta2interpret_spatTemp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::convert_theta2interpret_spatTemp </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lgamE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lgamS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lgamT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>sigU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>ranS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>ranT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert hyperparameters theta from the model parametrisation to the interpretable parametrisation ie. from log(gamma_E, gamma_s, gamma_t) to log(sigma.u, rangeS, rangeT) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">log(gamma_E)</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log(gamma_s)</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">log(gamma_t)</td><td></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(sigma.u)</td><td>precision of random effects </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(ranS)</td><td>spatial range </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log(ranT)</td><td>temporal range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada8322161a4b456296baa49a3b02c159" name="ada8322161a4b456296baa49a3b02c159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada8322161a4b456296baa49a3b02c159">&#9670;&#160;</a></span>diagHess_cond_negLogPoisLik()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vect PostTheta::diagHess_cond_negLogPoisLik </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>eta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>evaluate analytical negative diagonal Hessian of log Poisson likelihood </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eta</td><td>Vector. linear predictor eta = A*x </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">diagHess</td><td>Vect. diagonal of Hessian (off-diagonal entries are zero) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af839914f0f3e7d21387530be4d1d9420" name="af839914f0f3e7d21387530be4d1d9420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af839914f0f3e7d21387530be4d1d9420">&#9670;&#160;</a></span>eval_denominator() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_denominator </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>log_det</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>mu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate denominator: conditional probability of Qx|y. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log_det</td><td>fill log determinant of conditional distribution of denominator </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">val</td><td>fill value with mu*Q*mu </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Q</td><td>construct precision matrix </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rhs</td><td>construct right-handside </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mu</td><td>insert mean of latent parameters </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5af7519622a314b59a75f5b84f15ad9a" name="a5af7519622a314b59a75f5b84f15ad9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af7519622a314b59a75f5b84f15ad9a">&#9670;&#160;</a></span>eval_denominator() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_denominator </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>mu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate denominator: conditional probability of Qx|y. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log_det</td><td>fill log determinant of conditional distribution of denominator </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">val</td><td>fill value with mu*Q*mu </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Q</td><td>construct precision matrix </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rhs</td><td>construct right-handside </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mu</td><td>insert mean of latent parameters </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5af7519622a314b59a75f5b84f15ad9a" name="a5af7519622a314b59a75f5b84f15ad9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af7519622a314b59a75f5b84f15ad9a">&#9670;&#160;</a></span>eval_denominator() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_denominator </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>mu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate denominator: conditional probability of Qx|y. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log_det</td><td>fill log determinant of conditional distribution of denominator </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">val</td><td>fill value with mu*Q*mu </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Q</td><td>construct precision matrix </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rhs</td><td>construct right-handside </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mu</td><td>insert mean of latent parameters </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5af7519622a314b59a75f5b84f15ad9a" name="a5af7519622a314b59a75f5b84f15ad9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af7519622a314b59a75f5b84f15ad9a">&#9670;&#160;</a></span>eval_denominator() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_denominator </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>mu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate denominator: conditional probability of Qx|y. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log_det</td><td>fill log determinant of conditional distribution of denominator </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">val</td><td>fill value with mu*Q*mu </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Q</td><td>construct precision matrix </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rhs</td><td>construct right-handside </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mu</td><td>insert mean of latent parameters </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5af7519622a314b59a75f5b84f15ad9a" name="a5af7519622a314b59a75f5b84f15ad9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af7519622a314b59a75f5b84f15ad9a">&#9670;&#160;</a></span>eval_denominator() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_denominator </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>mu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate denominator: conditional probability of Qx|y. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log_det</td><td>fill log determinant of conditional distribution of denominator </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">val</td><td>fill value with mu*Q*mu </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Q</td><td>construct precision matrix </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rhs</td><td>construct right-handside </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mu</td><td>insert mean of latent parameters </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5af7519622a314b59a75f5b84f15ad9a" name="a5af7519622a314b59a75f5b84f15ad9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af7519622a314b59a75f5b84f15ad9a">&#9670;&#160;</a></span>eval_denominator() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_denominator </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>mu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate denominator: conditional probability of Qx|y. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log_det</td><td>fill log determinant of conditional distribution of denominator </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">val</td><td>fill value with mu*Q*mu </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Q</td><td>construct precision matrix </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rhs</td><td>construct right-handside </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mu</td><td>insert mean of latent parameters </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5af7519622a314b59a75f5b84f15ad9a" name="a5af7519622a314b59a75f5b84f15ad9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af7519622a314b59a75f5b84f15ad9a">&#9670;&#160;</a></span>eval_denominator() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_denominator </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>mu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate denominator: conditional probability of Qx|y. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log_det</td><td>fill log determinant of conditional distribution of denominator </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">val</td><td>fill value with mu*Q*mu </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Q</td><td>construct precision matrix </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rhs</td><td>construct right-handside </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mu</td><td>insert mean of latent parameters </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5af7519622a314b59a75f5b84f15ad9a" name="a5af7519622a314b59a75f5b84f15ad9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af7519622a314b59a75f5b84f15ad9a">&#9670;&#160;</a></span>eval_denominator() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_denominator </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>mu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate denominator: conditional probability of Qx|y. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log_det</td><td>fill log determinant of conditional distribution of denominator </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">val</td><td>fill value with mu*Q*mu </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Q</td><td>construct precision matrix </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rhs</td><td>construct right-handside </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mu</td><td>insert mean of latent parameters </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5af7519622a314b59a75f5b84f15ad9a" name="a5af7519622a314b59a75f5b84f15ad9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af7519622a314b59a75f5b84f15ad9a">&#9670;&#160;</a></span>eval_denominator() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_denominator </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>mu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate denominator: conditional probability of Qx|y. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log_det</td><td>fill log determinant of conditional distribution of denominator </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">val</td><td>fill value with mu*Q*mu </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Q</td><td>construct precision matrix </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rhs</td><td>construct right-handside </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mu</td><td>insert mean of latent parameters </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5af7519622a314b59a75f5b84f15ad9a" name="a5af7519622a314b59a75f5b84f15ad9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af7519622a314b59a75f5b84f15ad9a">&#9670;&#160;</a></span>eval_denominator() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_denominator </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>mu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate denominator: conditional probability of Qx|y. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log_det</td><td>fill log determinant of conditional distribution of denominator </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">val</td><td>fill value with mu*Q*mu </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Q</td><td>construct precision matrix </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rhs</td><td>construct right-handside </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mu</td><td>insert mean of latent parameters </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d7a18584db9aace5d217437bdfe84fa" name="a3d7a18584db9aace5d217437bdfe84fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d7a18584db9aace5d217437bdfe84fa">&#9670;&#160;</a></span>eval_gradient() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_gradient </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>f_theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>grad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute gradient using central finite difference stencil. Parallelised with OpenMP. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f_theta</td><td>value of f(theta) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[mu]</td><td>mu </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">grad</td><td>inserts gradient </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo</a></b></dt><dd>don't actually need gradient? </dd></dl>

</div>
</div>
<a id="a3d7a18584db9aace5d217437bdfe84fa" name="a3d7a18584db9aace5d217437bdfe84fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d7a18584db9aace5d217437bdfe84fa">&#9670;&#160;</a></span>eval_gradient() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_gradient </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>f_theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>grad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute gradient using central finite difference stencil. Parallelised with OpenMP. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f_theta</td><td>value of f(theta) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[mu]</td><td>mu </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">grad</td><td>inserts gradient </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo</a></b></dt><dd>don't actually need gradient? </dd></dl>

</div>
</div>
<a id="a3d7a18584db9aace5d217437bdfe84fa" name="a3d7a18584db9aace5d217437bdfe84fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d7a18584db9aace5d217437bdfe84fa">&#9670;&#160;</a></span>eval_gradient() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_gradient </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>f_theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>grad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute gradient using central finite difference stencil. Parallelised with OpenMP. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f_theta</td><td>value of f(theta) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[mu]</td><td>mu </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">grad</td><td>inserts gradient </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000009">Todo</a></b></dt><dd>don't actually need gradient? </dd></dl>

</div>
</div>
<a id="a3d7a18584db9aace5d217437bdfe84fa" name="a3d7a18584db9aace5d217437bdfe84fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d7a18584db9aace5d217437bdfe84fa">&#9670;&#160;</a></span>eval_gradient() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_gradient </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>f_theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>grad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute gradient using central finite difference stencil. Parallelised with OpenMP. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f_theta</td><td>value of f(theta) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[mu]</td><td>mu </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">grad</td><td>inserts gradient </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000014">Todo</a></b></dt><dd>don't actually need gradient? </dd></dl>

</div>
</div>
<a id="a3d7a18584db9aace5d217437bdfe84fa" name="a3d7a18584db9aace5d217437bdfe84fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d7a18584db9aace5d217437bdfe84fa">&#9670;&#160;</a></span>eval_gradient() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_gradient </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>f_theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>grad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute gradient using central finite difference stencil. Parallelised with OpenMP. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f_theta</td><td>value of f(theta) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[mu]</td><td>mu </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">grad</td><td>inserts gradient </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000017">Todo</a></b></dt><dd>don't actually need gradient? </dd></dl>

</div>
</div>
<a id="a3d7a18584db9aace5d217437bdfe84fa" name="a3d7a18584db9aace5d217437bdfe84fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d7a18584db9aace5d217437bdfe84fa">&#9670;&#160;</a></span>eval_gradient() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_gradient </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>f_theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>grad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute gradient using central finite difference stencil. Parallelised with OpenMP. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f_theta</td><td>value of f(theta) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[mu]</td><td>mu </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">grad</td><td>inserts gradient </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000020">Todo</a></b></dt><dd>don't actually need gradient? </dd></dl>

</div>
</div>
<a id="a3d7a18584db9aace5d217437bdfe84fa" name="a3d7a18584db9aace5d217437bdfe84fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d7a18584db9aace5d217437bdfe84fa">&#9670;&#160;</a></span>eval_gradient() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_gradient </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>f_theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>grad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute gradient using central finite difference stencil. Parallelised with OpenMP. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f_theta</td><td>value of f(theta) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[mu]</td><td>mu </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">grad</td><td>inserts gradient </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000023">Todo</a></b></dt><dd>don't actually need gradient? </dd></dl>

</div>
</div>
<a id="a3d7a18584db9aace5d217437bdfe84fa" name="a3d7a18584db9aace5d217437bdfe84fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d7a18584db9aace5d217437bdfe84fa">&#9670;&#160;</a></span>eval_gradient() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_gradient </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>f_theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>grad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute gradient using central finite difference stencil. Parallelised with OpenMP. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f_theta</td><td>value of f(theta) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[mu]</td><td>mu </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">grad</td><td>inserts gradient </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000026">Todo</a></b></dt><dd>don't actually need gradient? </dd></dl>

</div>
</div>
<a id="a3d7a18584db9aace5d217437bdfe84fa" name="a3d7a18584db9aace5d217437bdfe84fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d7a18584db9aace5d217437bdfe84fa">&#9670;&#160;</a></span>eval_gradient() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_gradient </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>f_theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>grad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute gradient using central finite difference stencil. Parallelised with OpenMP. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f_theta</td><td>value of f(theta) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[mu]</td><td>mu </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">grad</td><td>inserts gradient </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000029">Todo</a></b></dt><dd>don't actually need gradient? </dd></dl>

</div>
</div>
<a id="a97173a441c0f2f6b9dc2a5fe85e1d6ad" name="a97173a441c0f2f6b9dc2a5fe85e1d6ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97173a441c0f2f6b9dc2a5fe85e1d6ad">&#9670;&#160;</a></span>eval_likelihood() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_likelihood </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>log_det</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute log likelihood : log_det tau*no and value -theta*yTy </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log_det</td><td>inserts log determinant of log likelihood. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">val</td><td>inserts the value of -theta*yTy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97173a441c0f2f6b9dc2a5fe85e1d6ad" name="a97173a441c0f2f6b9dc2a5fe85e1d6ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97173a441c0f2f6b9dc2a5fe85e1d6ad">&#9670;&#160;</a></span>eval_likelihood() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_likelihood </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>log_det</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute log likelihood : log_det tau*no and value -theta*yTy </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log_det</td><td>inserts log determinant of log likelihood. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">val</td><td>inserts the value of -theta*yTy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97173a441c0f2f6b9dc2a5fe85e1d6ad" name="a97173a441c0f2f6b9dc2a5fe85e1d6ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97173a441c0f2f6b9dc2a5fe85e1d6ad">&#9670;&#160;</a></span>eval_likelihood() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_likelihood </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>log_det</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute log likelihood : log_det tau*no and value -theta*yTy </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log_det</td><td>inserts log determinant of log likelihood. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">val</td><td>inserts the value of -theta*yTy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97173a441c0f2f6b9dc2a5fe85e1d6ad" name="a97173a441c0f2f6b9dc2a5fe85e1d6ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97173a441c0f2f6b9dc2a5fe85e1d6ad">&#9670;&#160;</a></span>eval_likelihood() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_likelihood </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>log_det</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute log likelihood : log_det tau*no and value -theta*yTy </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log_det</td><td>inserts log determinant of log likelihood. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">val</td><td>inserts the value of -theta*yTy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97173a441c0f2f6b9dc2a5fe85e1d6ad" name="a97173a441c0f2f6b9dc2a5fe85e1d6ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97173a441c0f2f6b9dc2a5fe85e1d6ad">&#9670;&#160;</a></span>eval_likelihood() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_likelihood </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>log_det</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute log likelihood : log_det tau*no and value -theta*yTy </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log_det</td><td>inserts log determinant of log likelihood. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">val</td><td>inserts the value of -theta*yTy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97173a441c0f2f6b9dc2a5fe85e1d6ad" name="a97173a441c0f2f6b9dc2a5fe85e1d6ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97173a441c0f2f6b9dc2a5fe85e1d6ad">&#9670;&#160;</a></span>eval_likelihood() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_likelihood </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>log_det</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute log likelihood : log_det tau*no and value -theta*yTy </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log_det</td><td>inserts log determinant of log likelihood. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">val</td><td>inserts the value of -theta*yTy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97173a441c0f2f6b9dc2a5fe85e1d6ad" name="a97173a441c0f2f6b9dc2a5fe85e1d6ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97173a441c0f2f6b9dc2a5fe85e1d6ad">&#9670;&#160;</a></span>eval_likelihood() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_likelihood </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>log_det</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute log likelihood : log_det tau*no and value -theta*yTy </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log_det</td><td>inserts log determinant of log likelihood. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">val</td><td>inserts the value of -theta*yTy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97173a441c0f2f6b9dc2a5fe85e1d6ad" name="a97173a441c0f2f6b9dc2a5fe85e1d6ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97173a441c0f2f6b9dc2a5fe85e1d6ad">&#9670;&#160;</a></span>eval_likelihood() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_likelihood </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>log_det</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute log likelihood : log_det tau*no and value -theta*yTy </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log_det</td><td>inserts log determinant of log likelihood. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">val</td><td>inserts the value of -theta*yTy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97173a441c0f2f6b9dc2a5fe85e1d6ad" name="a97173a441c0f2f6b9dc2a5fe85e1d6ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97173a441c0f2f6b9dc2a5fe85e1d6ad">&#9670;&#160;</a></span>eval_likelihood() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_likelihood </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>log_det</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute log likelihood : log_det tau*no and value -theta*yTy </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log_det</td><td>inserts log determinant of log likelihood. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">val</td><td>inserts the value of -theta*yTy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae938a9d6de15e0512300f8ce00d8ffea" name="ae938a9d6de15e0512300f8ce00d8ffea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae938a9d6de15e0512300f8ce00d8ffea">&#9670;&#160;</a></span>eval_likelihood() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_likelihood </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>log_det</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute log likelihood : log_det tau*no and value -theta*yTy </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log_det</td><td>inserts log determinant of log likelihood. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">val</td><td>inserts the value of -theta*yTy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a23229109b6bfb9eefbe605b872fc8870" name="a23229109b6bfb9eefbe605b872fc8870"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23229109b6bfb9eefbe605b872fc8870">&#9670;&#160;</a></span>eval_log_det_Qu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_log_det_Qu </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>log_det</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>evaluate log prior of random effects </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log_det</td><td>inserts log determinant. </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000028">Todo</a></b></dt><dd>construct spatial matrix (at the moment this is happening twice. FIX) </dd></dl>

</div>
</div>
<a id="ac28f2fbb4caa4b566efa484e35a2c09b" name="ac28f2fbb4caa4b566efa484e35a2c09b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac28f2fbb4caa4b566efa484e35a2c09b">&#9670;&#160;</a></span>eval_log_gaussian_prior()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_log_gaussian_prior </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>log_prior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>thetai</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>thetai_original</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>evaluate log prior using original theta value </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thetai</td><td>current theta_i value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thetai_original</td><td>original theta_i value </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log</td><td>prior is being updated.</td></tr>
  </table>
  </dd>
</dl>
<p>variance / precision of 1 : no normalising constant. computed through -0.5 * (theta_i* - theta_i)*(theta_i*-theta_i) </p>

</div>
</div>
<a id="a52137ac2ce65806e9b9e99177adecd33" name="a52137ac2ce65806e9b9e99177adecd33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52137ac2ce65806e9b9e99177adecd33">&#9670;&#160;</a></span>eval_log_gaussian_prior_hp() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_log_gaussian_prior_hp </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>log_prior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>thetai</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>thetai_original</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>evaluate log prior of the hyperparameters using original theta value </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thetai</td><td>current theta_i value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thetai_original</td><td>original theta_i value </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log</td><td>prior is being updated.</td></tr>
  </table>
  </dd>
</dl>
<p>variance / precision of 1 : no normalising constant. computed through -0.5 * (theta_i* - theta_i)*(theta_i*-theta_i) </p>

</div>
</div>
<a id="a52137ac2ce65806e9b9e99177adecd33" name="a52137ac2ce65806e9b9e99177adecd33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52137ac2ce65806e9b9e99177adecd33">&#9670;&#160;</a></span>eval_log_gaussian_prior_hp() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_log_gaussian_prior_hp </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>log_prior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>thetai</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>thetai_original</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>evaluate log prior of the hyperparameters using original theta value </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thetai</td><td>current theta_i value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thetai_original</td><td>original theta_i value </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log</td><td>prior is being updated.</td></tr>
  </table>
  </dd>
</dl>
<p>variance / precision of 1 : no normalising constant. computed through -0.5 * (theta_i* - theta_i)*(theta_i*-theta_i) </p>

</div>
</div>
<a id="a52137ac2ce65806e9b9e99177adecd33" name="a52137ac2ce65806e9b9e99177adecd33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52137ac2ce65806e9b9e99177adecd33">&#9670;&#160;</a></span>eval_log_gaussian_prior_hp() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_log_gaussian_prior_hp </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>log_prior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>thetai</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>thetai_original</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>evaluate log prior of the hyperparameters using original theta value </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thetai</td><td>current theta_i value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thetai_original</td><td>original theta_i value </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log</td><td>prior is being updated.</td></tr>
  </table>
  </dd>
</dl>
<p>variance / precision of 1 : no normalising constant. computed through -0.5 * (theta_i* - theta_i)*(theta_i*-theta_i) </p>

</div>
</div>
<a id="a52137ac2ce65806e9b9e99177adecd33" name="a52137ac2ce65806e9b9e99177adecd33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52137ac2ce65806e9b9e99177adecd33">&#9670;&#160;</a></span>eval_log_gaussian_prior_hp() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_log_gaussian_prior_hp </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>log_prior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>thetai</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>thetai_original</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>evaluate log prior of the hyperparameters using original theta value </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thetai</td><td>current theta_i value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thetai_original</td><td>original theta_i value </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log</td><td>prior is being updated.</td></tr>
  </table>
  </dd>
</dl>
<p>variance / precision of 1 : no normalising constant. computed through -0.5 * (theta_i* - theta_i)*(theta_i*-theta_i) </p>

</div>
</div>
<a id="a52137ac2ce65806e9b9e99177adecd33" name="a52137ac2ce65806e9b9e99177adecd33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52137ac2ce65806e9b9e99177adecd33">&#9670;&#160;</a></span>eval_log_gaussian_prior_hp() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_log_gaussian_prior_hp </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>log_prior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>thetai</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>thetai_original</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>evaluate log prior of the hyperparameters using original theta value </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thetai</td><td>current theta_i value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thetai_original</td><td>original theta_i value </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log</td><td>prior is being updated.</td></tr>
  </table>
  </dd>
</dl>
<p>variance / precision of 1 : no normalising constant. computed through -0.5 * (theta_i* - theta_i)*(theta_i*-theta_i) </p>

</div>
</div>
<a id="a52137ac2ce65806e9b9e99177adecd33" name="a52137ac2ce65806e9b9e99177adecd33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52137ac2ce65806e9b9e99177adecd33">&#9670;&#160;</a></span>eval_log_gaussian_prior_hp() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_log_gaussian_prior_hp </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>log_prior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>thetai</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>thetai_original</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>evaluate log prior of the hyperparameters using original theta value </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thetai</td><td>current theta_i value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thetai_original</td><td>original theta_i value </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log</td><td>prior is being updated.</td></tr>
  </table>
  </dd>
</dl>
<p>variance / precision of 1 : no normalising constant. computed through -0.5 * (theta_i* - theta_i)*(theta_i*-theta_i) </p>

</div>
</div>
<a id="a52137ac2ce65806e9b9e99177adecd33" name="a52137ac2ce65806e9b9e99177adecd33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52137ac2ce65806e9b9e99177adecd33">&#9670;&#160;</a></span>eval_log_gaussian_prior_hp() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_log_gaussian_prior_hp </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>log_prior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>thetai</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>thetai_original</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>evaluate log prior of the hyperparameters using original theta value </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thetai</td><td>current theta_i value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thetai_original</td><td>original theta_i value </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log</td><td>prior is being updated.</td></tr>
  </table>
  </dd>
</dl>
<p>variance / precision of 1 : no normalising constant. computed through -0.5 * (theta_i* - theta_i)*(theta_i*-theta_i) </p>

</div>
</div>
<a id="a52137ac2ce65806e9b9e99177adecd33" name="a52137ac2ce65806e9b9e99177adecd33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52137ac2ce65806e9b9e99177adecd33">&#9670;&#160;</a></span>eval_log_gaussian_prior_hp() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_log_gaussian_prior_hp </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>log_prior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>thetai</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>thetai_original</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>evaluate log prior of the hyperparameters using original theta value </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thetai</td><td>current theta_i value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thetai_original</td><td>original theta_i value </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log</td><td>prior is being updated.</td></tr>
  </table>
  </dd>
</dl>
<p>variance / precision of 1 : no normalising constant. computed through -0.5 * (theta_i* - theta_i)*(theta_i*-theta_i) </p>

</div>
</div>
<a id="a97c18f0138b2cce7d71181bf57261bf5" name="a97c18f0138b2cce7d71181bf57261bf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97c18f0138b2cce7d71181bf57261bf5">&#9670;&#160;</a></span>eval_log_gaussian_prior_hp() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_log_gaussian_prior_hp </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta_param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta_prior_param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>log_prior</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>evaluate log prior of the hyperparameters using original theta value </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thetai</td><td>current theta_i value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thetai_original</td><td>original theta_i value </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log</td><td>prior is being updated.</td></tr>
  </table>
  </dd>
</dl>
<p>variance / precision of 1 : no normalising constant. computed through -0.5 * (theta_i* - theta_i)*(theta_i*-theta_i) </p>

</div>
</div>
<a id="a720770da5ee996c77937a3fe3753743d" name="a720770da5ee996c77937a3fe3753743d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a720770da5ee996c77937a3fe3753743d">&#9670;&#160;</a></span>eval_log_pc_prior()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_log_pc_prior </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>log_sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta_interpret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>evaluate log prior using PC prior </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log</td><td>sum <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lambda</td><td>: parameters for penalised complexity prior </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">theta_interpret</td><td>current theta value in interpretable scale</td></tr>
  </table>
  </dd>
</dl>
<p>complicated prior. check appropriate references for details. </p>

</div>
</div>
<a id="a66f7a4987eeb15a84b1af7c784c3b6ff" name="a66f7a4987eeb15a84b1af7c784c3b6ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66f7a4987eeb15a84b1af7c784c3b6ff">&#9670;&#160;</a></span>eval_log_pc_prior_hp() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_log_pc_prior_hp </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>log_sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta_interpret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>evaluate log prior using PC prior </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log</td><td>sum <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lambda</td><td>: parameters for penalised complexity prior </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">theta_interpret</td><td>current theta value in interpretable scale</td></tr>
  </table>
  </dd>
</dl>
<p>complicated prior. check appropriate references for details. </p>

</div>
</div>
<a id="a66f7a4987eeb15a84b1af7c784c3b6ff" name="a66f7a4987eeb15a84b1af7c784c3b6ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66f7a4987eeb15a84b1af7c784c3b6ff">&#9670;&#160;</a></span>eval_log_pc_prior_hp() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_log_pc_prior_hp </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>log_sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta_interpret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>evaluate log prior using PC prior </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log</td><td>sum <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lambda</td><td>: parameters for penalised complexity prior </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">theta_interpret</td><td>current theta value in interpretable scale</td></tr>
  </table>
  </dd>
</dl>
<p>complicated prior. check appropriate references for details. </p>

</div>
</div>
<a id="a66f7a4987eeb15a84b1af7c784c3b6ff" name="a66f7a4987eeb15a84b1af7c784c3b6ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66f7a4987eeb15a84b1af7c784c3b6ff">&#9670;&#160;</a></span>eval_log_pc_prior_hp() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_log_pc_prior_hp </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>log_sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta_interpret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>evaluate log prior using PC prior </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log</td><td>sum <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lambda</td><td>: parameters for penalised complexity prior </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">theta_interpret</td><td>current theta value in interpretable scale</td></tr>
  </table>
  </dd>
</dl>
<p>complicated prior. check appropriate references for details. </p>

</div>
</div>
<a id="a66f7a4987eeb15a84b1af7c784c3b6ff" name="a66f7a4987eeb15a84b1af7c784c3b6ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66f7a4987eeb15a84b1af7c784c3b6ff">&#9670;&#160;</a></span>eval_log_pc_prior_hp() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_log_pc_prior_hp </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>log_sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta_interpret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>evaluate log prior using PC prior </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log</td><td>sum <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lambda</td><td>: parameters for penalised complexity prior </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">theta_interpret</td><td>current theta value in interpretable scale</td></tr>
  </table>
  </dd>
</dl>
<p>complicated prior. check appropriate references for details. </p>

</div>
</div>
<a id="a66f7a4987eeb15a84b1af7c784c3b6ff" name="a66f7a4987eeb15a84b1af7c784c3b6ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66f7a4987eeb15a84b1af7c784c3b6ff">&#9670;&#160;</a></span>eval_log_pc_prior_hp() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_log_pc_prior_hp </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>log_sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta_interpret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>evaluate log prior using PC prior </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log</td><td>sum <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lambda</td><td>: parameters for penalised complexity prior </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">theta_interpret</td><td>current theta value in interpretable scale</td></tr>
  </table>
  </dd>
</dl>
<p>complicated prior. check appropriate references for details. </p>

</div>
</div>
<a id="a66f7a4987eeb15a84b1af7c784c3b6ff" name="a66f7a4987eeb15a84b1af7c784c3b6ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66f7a4987eeb15a84b1af7c784c3b6ff">&#9670;&#160;</a></span>eval_log_pc_prior_hp() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_log_pc_prior_hp </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>log_sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta_interpret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>evaluate log prior using PC prior </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log</td><td>sum <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lambda</td><td>: parameters for penalised complexity prior </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">theta_interpret</td><td>current theta value in interpretable scale</td></tr>
  </table>
  </dd>
</dl>
<p>complicated prior. check appropriate references for details. </p>

</div>
</div>
<a id="a66f7a4987eeb15a84b1af7c784c3b6ff" name="a66f7a4987eeb15a84b1af7c784c3b6ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66f7a4987eeb15a84b1af7c784c3b6ff">&#9670;&#160;</a></span>eval_log_pc_prior_hp() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_log_pc_prior_hp </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>log_sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta_interpret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>evaluate log prior using PC prior </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log</td><td>sum <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lambda</td><td>: parameters for penalised complexity prior </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">theta_interpret</td><td>current theta value in interpretable scale</td></tr>
  </table>
  </dd>
</dl>
<p>complicated prior. check appropriate references for details. </p>

</div>
</div>
<a id="a66f7a4987eeb15a84b1af7c784c3b6ff" name="a66f7a4987eeb15a84b1af7c784c3b6ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66f7a4987eeb15a84b1af7c784c3b6ff">&#9670;&#160;</a></span>eval_log_pc_prior_hp() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_log_pc_prior_hp </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>log_sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta_interpret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>evaluate log prior using PC prior </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log</td><td>sum <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lambda</td><td>: parameters for penalised complexity prior </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">theta_interpret</td><td>current theta value in interpretable scale</td></tr>
  </table>
  </dd>
</dl>
<p>complicated prior. check appropriate references for details. </p>

</div>
</div>
<a id="a66f7a4987eeb15a84b1af7c784c3b6ff" name="a66f7a4987eeb15a84b1af7c784c3b6ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66f7a4987eeb15a84b1af7c784c3b6ff">&#9670;&#160;</a></span>eval_log_pc_prior_hp() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_log_pc_prior_hp </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>log_sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta_interpret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>evaluate log prior using PC prior </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log</td><td>sum <br  />
 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lambda</td><td>: parameters for penalised complexity prior </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">theta_interpret</td><td>current theta value in interpretable scale</td></tr>
  </table>
  </dd>
</dl>
<p>complicated prior. check appropriate references for details. </p>

</div>
</div>
<a id="a981439fd52c6b46c1666fd45eb5faa92" name="a981439fd52c6b46c1666fd45eb5faa92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a981439fd52c6b46c1666fd45eb5faa92">&#9670;&#160;</a></span>eval_log_prior_lat() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_log_prior_lat </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>evaluate log prior of random effects </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log_det</td><td>inserts log determinant. </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo</a></b></dt><dd>construct spatial matrix (at the moment this is happening twice. FIX) </dd></dl>

</div>
</div>
<a id="a981439fd52c6b46c1666fd45eb5faa92" name="a981439fd52c6b46c1666fd45eb5faa92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a981439fd52c6b46c1666fd45eb5faa92">&#9670;&#160;</a></span>eval_log_prior_lat() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_log_prior_lat </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>evaluate log prior of random effects </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log_det</td><td>inserts log determinant. </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo</a></b></dt><dd>construct spatial matrix (at the moment this is happening twice. FIX) </dd></dl>

</div>
</div>
<a id="a981439fd52c6b46c1666fd45eb5faa92" name="a981439fd52c6b46c1666fd45eb5faa92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a981439fd52c6b46c1666fd45eb5faa92">&#9670;&#160;</a></span>eval_log_prior_lat() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_log_prior_lat </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>evaluate log prior of random effects </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log_det</td><td>inserts log determinant. </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000008">Todo</a></b></dt><dd>construct spatial matrix (at the moment this is happening twice. FIX) </dd></dl>

</div>
</div>
<a id="a981439fd52c6b46c1666fd45eb5faa92" name="a981439fd52c6b46c1666fd45eb5faa92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a981439fd52c6b46c1666fd45eb5faa92">&#9670;&#160;</a></span>eval_log_prior_lat() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_log_prior_lat </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>evaluate log prior of random effects </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log_det</td><td>inserts log determinant. </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000013">Todo</a></b></dt><dd>construct spatial matrix (at the moment this is happening twice. FIX) </dd></dl>

</div>
</div>
<a id="a981439fd52c6b46c1666fd45eb5faa92" name="a981439fd52c6b46c1666fd45eb5faa92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a981439fd52c6b46c1666fd45eb5faa92">&#9670;&#160;</a></span>eval_log_prior_lat() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_log_prior_lat </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>evaluate log prior of random effects </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log_det</td><td>inserts log determinant. </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000016">Todo</a></b></dt><dd>construct spatial matrix (at the moment this is happening twice. FIX) </dd></dl>

</div>
</div>
<a id="a981439fd52c6b46c1666fd45eb5faa92" name="a981439fd52c6b46c1666fd45eb5faa92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a981439fd52c6b46c1666fd45eb5faa92">&#9670;&#160;</a></span>eval_log_prior_lat() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_log_prior_lat </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>evaluate log prior of random effects </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log_det</td><td>inserts log determinant. </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000019">Todo</a></b></dt><dd>construct spatial matrix (at the moment this is happening twice. FIX) </dd></dl>

</div>
</div>
<a id="a981439fd52c6b46c1666fd45eb5faa92" name="a981439fd52c6b46c1666fd45eb5faa92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a981439fd52c6b46c1666fd45eb5faa92">&#9670;&#160;</a></span>eval_log_prior_lat() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_log_prior_lat </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>evaluate log prior of random effects </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log_det</td><td>inserts log determinant. </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000022">Todo</a></b></dt><dd>construct spatial matrix (at the moment this is happening twice. FIX) </dd></dl>

</div>
</div>
<a id="a981439fd52c6b46c1666fd45eb5faa92" name="a981439fd52c6b46c1666fd45eb5faa92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a981439fd52c6b46c1666fd45eb5faa92">&#9670;&#160;</a></span>eval_log_prior_lat() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_log_prior_lat </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>evaluate log prior of random effects </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log_det</td><td>inserts log determinant. </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000025">Todo</a></b></dt><dd>construct spatial matrix (at the moment this is happening twice. FIX) </dd></dl>

</div>
</div>
<a id="a39be6fb891850dcb5d3042fc20cf9e51" name="a39be6fb891850dcb5d3042fc20cf9e51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39be6fb891850dcb5d3042fc20cf9e51">&#9670;&#160;</a></span>eval_log_prior_lat() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::eval_log_prior_lat </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>evaluate log prior of random effects </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>current theta vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">log_det</td><td>inserts log determinant. </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000011">Todo</a></b></dt><dd>construct spatial matrix (at the moment this is happening twice. FIX) </dd></dl>

</div>
</div>
<a id="a437a6716c8fe32396f0643f3dba43e5b" name="a437a6716c8fe32396f0643f3dba43e5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a437a6716c8fe32396f0643f3dba43e5b">&#9670;&#160;</a></span>eval_post_theta() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double PostTheta::eval_post_theta </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>mu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Core function. Evaluate posterior of theta. mu are latent parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>hyperparameter vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mu</td><td>vector of the conditional mean </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>f(theta) value </dd></dl>

</div>
</div>
<a id="a437a6716c8fe32396f0643f3dba43e5b" name="a437a6716c8fe32396f0643f3dba43e5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a437a6716c8fe32396f0643f3dba43e5b">&#9670;&#160;</a></span>eval_post_theta() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double PostTheta::eval_post_theta </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>mu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Core function. Evaluate posterior of theta. mu are latent parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>hyperparameter vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mu</td><td>vector of the conditional mean </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>f(theta) value </dd></dl>

</div>
</div>
<a id="a437a6716c8fe32396f0643f3dba43e5b" name="a437a6716c8fe32396f0643f3dba43e5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a437a6716c8fe32396f0643f3dba43e5b">&#9670;&#160;</a></span>eval_post_theta() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double PostTheta::eval_post_theta </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>mu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Core function. Evaluate posterior of theta. mu are latent parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>hyperparameter vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mu</td><td>vector of the conditional mean </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>f(theta) value </dd></dl>

</div>
</div>
<a id="a437a6716c8fe32396f0643f3dba43e5b" name="a437a6716c8fe32396f0643f3dba43e5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a437a6716c8fe32396f0643f3dba43e5b">&#9670;&#160;</a></span>eval_post_theta() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double PostTheta::eval_post_theta </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>mu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Core function. Evaluate posterior of theta. mu are latent parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>hyperparameter vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mu</td><td>vector of the conditional mean </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>f(theta) value </dd></dl>

</div>
</div>
<a id="a437a6716c8fe32396f0643f3dba43e5b" name="a437a6716c8fe32396f0643f3dba43e5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a437a6716c8fe32396f0643f3dba43e5b">&#9670;&#160;</a></span>eval_post_theta() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double PostTheta::eval_post_theta </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>mu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Core function. Evaluate posterior of theta. mu are latent parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>hyperparameter vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mu</td><td>vector of the conditional mean </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>f(theta) value </dd></dl>

</div>
</div>
<a id="a437a6716c8fe32396f0643f3dba43e5b" name="a437a6716c8fe32396f0643f3dba43e5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a437a6716c8fe32396f0643f3dba43e5b">&#9670;&#160;</a></span>eval_post_theta() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double PostTheta::eval_post_theta </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>mu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Core function. Evaluate posterior of theta. mu are latent parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>hyperparameter vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mu</td><td>vector of the conditional mean </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>f(theta) value </dd></dl>

</div>
</div>
<a id="a6a3133494a5479b3f1f8a557e9490a35" name="a6a3133494a5479b3f1f8a557e9490a35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a3133494a5479b3f1f8a557e9490a35">&#9670;&#160;</a></span>eval_post_theta() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double PostTheta::eval_post_theta </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayXi &amp;&#160;</td>
          <td class="paramname"><em>fact_to_rank_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Core function. Evaluate posterior of theta. mu are latent parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>hyperparameter vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mu</td><td>vector of the conditional mean </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>f(theta) value </dd></dl>

</div>
</div>
<a id="a6a3133494a5479b3f1f8a557e9490a35" name="a6a3133494a5479b3f1f8a557e9490a35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a3133494a5479b3f1f8a557e9490a35">&#9670;&#160;</a></span>eval_post_theta() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double PostTheta::eval_post_theta </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayXi &amp;&#160;</td>
          <td class="paramname"><em>fact_to_rank_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Core function. Evaluate posterior of theta. mu are latent parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>hyperparameter vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mu</td><td>vector of the conditional mean </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>f(theta) value </dd></dl>

</div>
</div>
<a id="a6a3133494a5479b3f1f8a557e9490a35" name="a6a3133494a5479b3f1f8a557e9490a35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a3133494a5479b3f1f8a557e9490a35">&#9670;&#160;</a></span>eval_post_theta() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double PostTheta::eval_post_theta </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayXi &amp;&#160;</td>
          <td class="paramname"><em>fact_to_rank_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Core function. Evaluate posterior of theta. mu are latent parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>hyperparameter vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mu</td><td>vector of the conditional mean </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>f(theta) value </dd></dl>

</div>
</div>
<a id="a6a3133494a5479b3f1f8a557e9490a35" name="a6a3133494a5479b3f1f8a557e9490a35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a3133494a5479b3f1f8a557e9490a35">&#9670;&#160;</a></span>eval_post_theta() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double PostTheta::eval_post_theta </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayXi &amp;&#160;</td>
          <td class="paramname"><em>fact_to_rank_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Core function. Evaluate posterior of theta. mu are latent parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>hyperparameter vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mu</td><td>vector of the conditional mean </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>f(theta) value </dd></dl>

</div>
</div>
<a id="a94652237d86e5b575f65b7bdaf97b02e" name="a94652237d86e5b575f65b7bdaf97b02e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94652237d86e5b575f65b7bdaf97b02e">&#9670;&#160;</a></span>FD_diag_hessian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::FD_diag_hessian </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>eta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>diag_hess</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute finite difference diagonal of hessian. 2nd order central difference. currently stepsize h fixed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">extraCoeffVecLik</td><td>Vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eta</td><td>Vector. linear predictor eta = A*x. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lik_func</td><td>function. defines the likelihood </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">diag_hess</td><td>Vector. diagonal of Hessian. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7787133900ea7bed116af5ea6cf46d91" name="a7787133900ea7bed116af5ea6cf46d91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7787133900ea7bed116af5ea6cf46d91">&#9670;&#160;</a></span>FD_gradient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::FD_gradient </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>eta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>grad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute finite difference gradient. 1st order central difference. currently stepsize h fixed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">extraCoeffVecLik</td><td>Vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eta</td><td>Vector. linear predictor eta = A*x. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lik_func</td><td>function. defines the likelihood </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">grad</td><td>Vector. gradient. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9eb8efdc44447d6224893f6debf29540" name="a9eb8efdc44447d6224893f6debf29540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eb8efdc44447d6224893f6debf29540">&#9670;&#160;</a></span>get_Covariance() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MatrixXd PostTheta::get_Covariance </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute Covariance matrix of hyperparameters theta, at theta. </p>
<p>computes the hessian of f(theta) using a second order finite difference stencil and then inverts the hessian. Gaussian assumption. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>hyperparameter Vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cov covariance matrix of the hyperparameters </dd></dl>

</div>
</div>
<a id="a9eb8efdc44447d6224893f6debf29540" name="a9eb8efdc44447d6224893f6debf29540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eb8efdc44447d6224893f6debf29540">&#9670;&#160;</a></span>get_Covariance() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MatrixXd PostTheta::get_Covariance </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute Covariance matrix of hyperparameters theta, at theta. </p>
<p>computes the hessian of f(theta) using a second order finite difference stencil and then inverts the hessian. Gaussian assumption. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>hyperparameter Vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cov covariance matrix of the hyperparameters </dd></dl>

</div>
</div>
<a id="a9eb8efdc44447d6224893f6debf29540" name="a9eb8efdc44447d6224893f6debf29540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eb8efdc44447d6224893f6debf29540">&#9670;&#160;</a></span>get_Covariance() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MatrixXd PostTheta::get_Covariance </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute Covariance matrix of hyperparameters theta, at theta. </p>
<p>computes the hessian of f(theta) using a second order finite difference stencil and then inverts the hessian. Gaussian assumption. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>hyperparameter Vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cov covariance matrix of the hyperparameters </dd></dl>

</div>
</div>
<a id="a9eb8efdc44447d6224893f6debf29540" name="a9eb8efdc44447d6224893f6debf29540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eb8efdc44447d6224893f6debf29540">&#9670;&#160;</a></span>get_Covariance() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MatrixXd PostTheta::get_Covariance </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute Covariance matrix of hyperparameters theta, at theta. </p>
<p>computes the hessian of f(theta) using a second order finite difference stencil and then inverts the hessian. Gaussian assumption. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>hyperparameter Vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cov covariance matrix of the hyperparameters </dd></dl>

</div>
</div>
<a id="a9eb8efdc44447d6224893f6debf29540" name="a9eb8efdc44447d6224893f6debf29540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eb8efdc44447d6224893f6debf29540">&#9670;&#160;</a></span>get_Covariance() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MatrixXd PostTheta::get_Covariance </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute Covariance matrix of hyperparameters theta, at theta. </p>
<p>computes the hessian of f(theta) using a second order finite difference stencil and then inverts the hessian. Gaussian assumption. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>hyperparameter Vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cov covariance matrix of the hyperparameters </dd></dl>

</div>
</div>
<a id="a9eb8efdc44447d6224893f6debf29540" name="a9eb8efdc44447d6224893f6debf29540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eb8efdc44447d6224893f6debf29540">&#9670;&#160;</a></span>get_Covariance() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MatrixXd PostTheta::get_Covariance </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute Covariance matrix of hyperparameters theta, at theta. </p>
<p>computes the hessian of f(theta) using a second order finite difference stencil and then inverts the hessian. Gaussian assumption. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>hyperparameter Vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cov covariance matrix of the hyperparameters </dd></dl>

</div>
</div>
<a id="a9eb8efdc44447d6224893f6debf29540" name="a9eb8efdc44447d6224893f6debf29540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eb8efdc44447d6224893f6debf29540">&#9670;&#160;</a></span>get_Covariance() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MatrixXd PostTheta::get_Covariance </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute Covariance matrix of hyperparameters theta, at theta. </p>
<p>computes the hessian of f(theta) using a second order finite difference stencil and then inverts the hessian. Gaussian assumption. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>hyperparameter Vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cov covariance matrix of the hyperparameters </dd></dl>

</div>
</div>
<a id="a9eb8efdc44447d6224893f6debf29540" name="a9eb8efdc44447d6224893f6debf29540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eb8efdc44447d6224893f6debf29540">&#9670;&#160;</a></span>get_Covariance() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MatrixXd PostTheta::get_Covariance </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute Covariance matrix of hyperparameters theta, at theta. </p>
<p>computes the hessian of f(theta) using a second order finite difference stencil and then inverts the hessian. Gaussian assumption. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>hyperparameter Vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cov covariance matrix of the hyperparameters </dd></dl>

</div>
</div>
<a id="a9eb8efdc44447d6224893f6debf29540" name="a9eb8efdc44447d6224893f6debf29540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eb8efdc44447d6224893f6debf29540">&#9670;&#160;</a></span>get_Covariance() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MatrixXd PostTheta::get_Covariance </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute Covariance matrix of hyperparameters theta, at theta. </p>
<p>computes the hessian of f(theta) using a second order finite difference stencil and then inverts the hessian. Gaussian assumption. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>hyperparameter Vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cov covariance matrix of the hyperparameters </dd></dl>

</div>
</div>
<a id="ab8824cb165bee60e50b66f0b753428ed" name="ab8824cb165bee60e50b66f0b753428ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8824cb165bee60e50b66f0b753428ed">&#9670;&#160;</a></span>get_Covariance() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MatrixXd PostTheta::get_Covariance </td>
          <td>(</td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute Covariance matrix of hyperparameters theta, at theta. </p>
<p>computes the hessian of f(theta) using a second order finite difference stencil and then inverts the hessian. Gaussian assumption. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>hyperparameter Vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cov covariance matrix of the hyperparameters </dd></dl>

</div>
</div>
<a id="afe3237450eed420a2a2bb8217afaa428" name="afe3237450eed420a2a2bb8217afaa428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe3237450eed420a2a2bb8217afaa428">&#9670;&#160;</a></span>get_fullFact_marginals_f() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::get_fullFact_marginals_f </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat &amp;&#160;</td>
          <td class="paramname"><em>Qinv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the marginal variances of the latent parameters at theta. Using selected inversion procedure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vector</td><td>theta. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Vector</td><td>with selected inverse for all non-zero entries of Q. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe3237450eed420a2a2bb8217afaa428" name="afe3237450eed420a2a2bb8217afaa428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe3237450eed420a2a2bb8217afaa428">&#9670;&#160;</a></span>get_fullFact_marginals_f() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::get_fullFact_marginals_f </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat &amp;&#160;</td>
          <td class="paramname"><em>Qinv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the marginal variances of the latent parameters at theta. Using selected inversion procedure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vector</td><td>theta. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Vector</td><td>with selected inverse for all non-zero entries of Q. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b59d9c23fb21cf517f281ae48ac970d" name="a6b59d9c23fb21cf517f281ae48ac970d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b59d9c23fb21cf517f281ae48ac970d">&#9670;&#160;</a></span>get_grad() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vect PostTheta::get_grad </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns current gradient of theta. </p>
<dl class="section return"><dt>Returns</dt><dd>gradient_theta </dd></dl>

</div>
</div>
<a id="a6b59d9c23fb21cf517f281ae48ac970d" name="a6b59d9c23fb21cf517f281ae48ac970d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b59d9c23fb21cf517f281ae48ac970d">&#9670;&#160;</a></span>get_grad() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vect PostTheta::get_grad </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns current gradient of theta. </p>
<dl class="section return"><dt>Returns</dt><dd>gradient_theta </dd></dl>

</div>
</div>
<a id="a6b59d9c23fb21cf517f281ae48ac970d" name="a6b59d9c23fb21cf517f281ae48ac970d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b59d9c23fb21cf517f281ae48ac970d">&#9670;&#160;</a></span>get_grad() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vect PostTheta::get_grad </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns current gradient of theta. </p>
<dl class="section return"><dt>Returns</dt><dd>gradient_theta </dd></dl>

</div>
</div>
<a id="a6b59d9c23fb21cf517f281ae48ac970d" name="a6b59d9c23fb21cf517f281ae48ac970d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b59d9c23fb21cf517f281ae48ac970d">&#9670;&#160;</a></span>get_grad() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vect PostTheta::get_grad </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns current gradient of theta. </p>
<dl class="section return"><dt>Returns</dt><dd>gradient_theta </dd></dl>

</div>
</div>
<a id="a6b59d9c23fb21cf517f281ae48ac970d" name="a6b59d9c23fb21cf517f281ae48ac970d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b59d9c23fb21cf517f281ae48ac970d">&#9670;&#160;</a></span>get_grad() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vect PostTheta::get_grad </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns current gradient of theta. </p>
<dl class="section return"><dt>Returns</dt><dd>gradient_theta </dd></dl>

</div>
</div>
<a id="a6b59d9c23fb21cf517f281ae48ac970d" name="a6b59d9c23fb21cf517f281ae48ac970d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b59d9c23fb21cf517f281ae48ac970d">&#9670;&#160;</a></span>get_grad() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vect PostTheta::get_grad </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns current gradient of theta. </p>
<dl class="section return"><dt>Returns</dt><dd>gradient_theta </dd></dl>

</div>
</div>
<a id="a6b59d9c23fb21cf517f281ae48ac970d" name="a6b59d9c23fb21cf517f281ae48ac970d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b59d9c23fb21cf517f281ae48ac970d">&#9670;&#160;</a></span>get_grad() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vect PostTheta::get_grad </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns current gradient of theta. </p>
<dl class="section return"><dt>Returns</dt><dd>gradient_theta </dd></dl>

</div>
</div>
<a id="a6b59d9c23fb21cf517f281ae48ac970d" name="a6b59d9c23fb21cf517f281ae48ac970d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b59d9c23fb21cf517f281ae48ac970d">&#9670;&#160;</a></span>get_grad() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vect PostTheta::get_grad </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns current gradient of theta. </p>
<dl class="section return"><dt>Returns</dt><dd>gradient_theta </dd></dl>

</div>
</div>
<a id="a6b59d9c23fb21cf517f281ae48ac970d" name="a6b59d9c23fb21cf517f281ae48ac970d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b59d9c23fb21cf517f281ae48ac970d">&#9670;&#160;</a></span>get_grad() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vect PostTheta::get_grad </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns current gradient of theta. </p>
<dl class="section return"><dt>Returns</dt><dd>gradient_theta </dd></dl>

</div>
</div>
<a id="a6b59d9c23fb21cf517f281ae48ac970d" name="a6b59d9c23fb21cf517f281ae48ac970d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b59d9c23fb21cf517f281ae48ac970d">&#9670;&#160;</a></span>get_grad() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vect PostTheta::get_grad </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns current gradient of theta. </p>
<dl class="section return"><dt>Returns</dt><dd>gradient_theta </dd></dl>

</div>
</div>
<a id="a59a304945cc0ac88a80717dfd2f6975a" name="a59a304945cc0ac88a80717dfd2f6975a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59a304945cc0ac88a80717dfd2f6975a">&#9670;&#160;</a></span>get_marginals_f() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::get_marginals_f </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the marginal variances of the latent parameters at theta. Using selected inversion procedure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vector</td><td>theta. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Vector</td><td>with marginals of f. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6d01ba1dcfedc1e9b250586c0f6ab98" name="ab6d01ba1dcfedc1e9b250586c0f6ab98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6d01ba1dcfedc1e9b250586c0f6ab98">&#9670;&#160;</a></span>get_marginals_f() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::get_marginals_f </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the marginal variances of the latent parameters at theta. Using selected inversion procedure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vector</td><td>theta. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Vector</td><td>with marginals of f. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6d01ba1dcfedc1e9b250586c0f6ab98" name="ab6d01ba1dcfedc1e9b250586c0f6ab98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6d01ba1dcfedc1e9b250586c0f6ab98">&#9670;&#160;</a></span>get_marginals_f() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::get_marginals_f </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the marginal variances of the latent parameters at theta. Using selected inversion procedure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vector</td><td>theta. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Vector</td><td>with marginals of f. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6d01ba1dcfedc1e9b250586c0f6ab98" name="ab6d01ba1dcfedc1e9b250586c0f6ab98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6d01ba1dcfedc1e9b250586c0f6ab98">&#9670;&#160;</a></span>get_marginals_f() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::get_marginals_f </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the marginal variances of the latent parameters at theta. Using selected inversion procedure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vector</td><td>theta. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Vector</td><td>with marginals of f. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6d01ba1dcfedc1e9b250586c0f6ab98" name="ab6d01ba1dcfedc1e9b250586c0f6ab98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6d01ba1dcfedc1e9b250586c0f6ab98">&#9670;&#160;</a></span>get_marginals_f() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::get_marginals_f </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the marginal variances of the latent parameters at theta. Using selected inversion procedure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vector</td><td>theta. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Vector</td><td>with marginals of f. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6d01ba1dcfedc1e9b250586c0f6ab98" name="ab6d01ba1dcfedc1e9b250586c0f6ab98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6d01ba1dcfedc1e9b250586c0f6ab98">&#9670;&#160;</a></span>get_marginals_f() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::get_marginals_f </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the marginal variances of the latent parameters at theta. Using selected inversion procedure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vector</td><td>theta. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Vector</td><td>with marginals of f. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6d01ba1dcfedc1e9b250586c0f6ab98" name="ab6d01ba1dcfedc1e9b250586c0f6ab98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6d01ba1dcfedc1e9b250586c0f6ab98">&#9670;&#160;</a></span>get_marginals_f() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::get_marginals_f </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the marginal variances of the latent parameters at theta. Using selected inversion procedure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vector</td><td>theta. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Vector</td><td>with marginals of f. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6d01ba1dcfedc1e9b250586c0f6ab98" name="ab6d01ba1dcfedc1e9b250586c0f6ab98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6d01ba1dcfedc1e9b250586c0f6ab98">&#9670;&#160;</a></span>get_marginals_f() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::get_marginals_f </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the marginal variances of the latent parameters at theta. Using selected inversion procedure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vector</td><td>theta. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Vector</td><td>with marginals of f. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6d01ba1dcfedc1e9b250586c0f6ab98" name="ab6d01ba1dcfedc1e9b250586c0f6ab98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6d01ba1dcfedc1e9b250586c0f6ab98">&#9670;&#160;</a></span>get_marginals_f() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::get_marginals_f </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the marginal variances of the latent parameters at theta. Using selected inversion procedure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vector</td><td>theta. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Vector</td><td>with marginals of f. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6d01ba1dcfedc1e9b250586c0f6ab98" name="ab6d01ba1dcfedc1e9b250586c0f6ab98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6d01ba1dcfedc1e9b250586c0f6ab98">&#9670;&#160;</a></span>get_marginals_f() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::get_marginals_f </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the marginal variances of the latent parameters at theta. Using selected inversion procedure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Vector</td><td>theta. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Vector</td><td>with marginals of f. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff0f3a13e200dc7833ad7297dc67d0b9" name="aff0f3a13e200dc7833ad7297dc67d0b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff0f3a13e200dc7833ad7297dc67d0b9">&#9670;&#160;</a></span>get_mu() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::get_mu </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>mu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get conditional mean mu for theta. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>hyperparameter vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mu</td><td>vector of the conditional mean </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff0f3a13e200dc7833ad7297dc67d0b9" name="aff0f3a13e200dc7833ad7297dc67d0b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff0f3a13e200dc7833ad7297dc67d0b9">&#9670;&#160;</a></span>get_mu() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::get_mu </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>mu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get conditional mean mu for theta. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>hyperparameter vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mu</td><td>vector of the conditional mean </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff0f3a13e200dc7833ad7297dc67d0b9" name="aff0f3a13e200dc7833ad7297dc67d0b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff0f3a13e200dc7833ad7297dc67d0b9">&#9670;&#160;</a></span>get_mu() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::get_mu </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>mu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get conditional mean mu for theta. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>hyperparameter vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mu</td><td>vector of the conditional mean </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff0f3a13e200dc7833ad7297dc67d0b9" name="aff0f3a13e200dc7833ad7297dc67d0b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff0f3a13e200dc7833ad7297dc67d0b9">&#9670;&#160;</a></span>get_mu() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::get_mu </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>mu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get conditional mean mu for theta. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>hyperparameter vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mu</td><td>vector of the conditional mean </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff0f3a13e200dc7833ad7297dc67d0b9" name="aff0f3a13e200dc7833ad7297dc67d0b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff0f3a13e200dc7833ad7297dc67d0b9">&#9670;&#160;</a></span>get_mu() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::get_mu </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>mu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get conditional mean mu for theta. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>hyperparameter vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mu</td><td>vector of the conditional mean </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6ffad9798426544c91b1f3420e9c8c9" name="ac6ffad9798426544c91b1f3420e9c8c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6ffad9798426544c91b1f3420e9c8c9">&#9670;&#160;</a></span>get_mu() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::get_mu </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayXi &amp;&#160;</td>
          <td class="paramname"><em>fact_to_rank_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get conditional mean mu for theta. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>hyperparameter vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mu</td><td>vector of the conditional mean </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6ffad9798426544c91b1f3420e9c8c9" name="ac6ffad9798426544c91b1f3420e9c8c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6ffad9798426544c91b1f3420e9c8c9">&#9670;&#160;</a></span>get_mu() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::get_mu </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayXi &amp;&#160;</td>
          <td class="paramname"><em>fact_to_rank_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get conditional mean mu for theta. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>hyperparameter vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mu</td><td>vector of the conditional mean </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6ffad9798426544c91b1f3420e9c8c9" name="ac6ffad9798426544c91b1f3420e9c8c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6ffad9798426544c91b1f3420e9c8c9">&#9670;&#160;</a></span>get_mu() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::get_mu </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayXi &amp;&#160;</td>
          <td class="paramname"><em>fact_to_rank_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get conditional mean mu for theta. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>hyperparameter vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mu</td><td>vector of the conditional mean </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6ffad9798426544c91b1f3420e9c8c9" name="ac6ffad9798426544c91b1f3420e9c8c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6ffad9798426544c91b1f3420e9c8c9">&#9670;&#160;</a></span>get_mu() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::get_mu </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayXi &amp;&#160;</td>
          <td class="paramname"><em>fact_to_rank_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get conditional mean mu for theta. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>hyperparameter vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mu</td><td>vector of the conditional mean </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a67817f8f6c3b54ccdeee1dafd20d124b" name="a67817f8f6c3b54ccdeee1dafd20d124b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67817f8f6c3b54ccdeee1dafd20d124b">&#9670;&#160;</a></span>get_mu() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::get_mu </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>mu_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get conditional mean mu for theta &ndash; Gaussian case. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>hyperparameter vector </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mu_</td><td>vector of the conditional mean </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9869ed1f62b2833100e38412658fdd64" name="a9869ed1f62b2833100e38412658fdd64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9869ed1f62b2833100e38412658fdd64">&#9670;&#160;</a></span>grad_cond_negLogPoisLik()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Vect PostTheta::grad_cond_negLogPoisLik </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>eta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>evaluate analytical negative gradient log Poisson likelihood </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eta</td><td>Vector. linear predictor eta = A*x </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">grad</td><td>Vect. gradient. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ba126f6b1bc95b8815465debaedd650" name="a8ba126f6b1bc95b8815465debaedd650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ba126f6b1bc95b8815465debaedd650">&#9670;&#160;</a></span>hess_eval() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MatrixXd PostTheta::hess_eval </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the hessian at theta using second order finite difference. Is used be get_Covariance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>hyperparameter vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dense Matrix with Hessian. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo</a></b></dt><dd>not yet parallelised .... </dd></dl>

</div>
</div>
<a id="a8ba126f6b1bc95b8815465debaedd650" name="a8ba126f6b1bc95b8815465debaedd650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ba126f6b1bc95b8815465debaedd650">&#9670;&#160;</a></span>hess_eval() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MatrixXd PostTheta::hess_eval </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the hessian at theta using second order finite difference. Is used be get_Covariance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>hyperparameter vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dense Matrix with Hessian. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo</a></b></dt><dd>not yet parallelised .... </dd></dl>

</div>
</div>
<a id="a8ba126f6b1bc95b8815465debaedd650" name="a8ba126f6b1bc95b8815465debaedd650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ba126f6b1bc95b8815465debaedd650">&#9670;&#160;</a></span>hess_eval() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MatrixXd PostTheta::hess_eval </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the hessian at theta using second order finite difference. Is used be get_Covariance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>hyperparameter vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dense Matrix with Hessian. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo</a></b></dt><dd>not yet parallelised .... </dd></dl>

</div>
</div>
<a id="a8ba126f6b1bc95b8815465debaedd650" name="a8ba126f6b1bc95b8815465debaedd650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ba126f6b1bc95b8815465debaedd650">&#9670;&#160;</a></span>hess_eval() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MatrixXd PostTheta::hess_eval </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the hessian at theta using second order finite difference. Is used be get_Covariance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>hyperparameter vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dense Matrix with Hessian. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000012">Todo</a></b></dt><dd>not yet parallelised .... </dd></dl>

</div>
</div>
<a id="a8ba126f6b1bc95b8815465debaedd650" name="a8ba126f6b1bc95b8815465debaedd650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ba126f6b1bc95b8815465debaedd650">&#9670;&#160;</a></span>hess_eval() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MatrixXd PostTheta::hess_eval </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the hessian at theta using second order finite difference. Is used be get_Covariance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>hyperparameter vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dense Matrix with Hessian. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000015">Todo</a></b></dt><dd>not yet parallelised .... </dd></dl>

</div>
</div>
<a id="a8ba126f6b1bc95b8815465debaedd650" name="a8ba126f6b1bc95b8815465debaedd650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ba126f6b1bc95b8815465debaedd650">&#9670;&#160;</a></span>hess_eval() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MatrixXd PostTheta::hess_eval </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the hessian at theta using second order finite difference. Is used be get_Covariance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>hyperparameter vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dense Matrix with Hessian. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000018">Todo</a></b></dt><dd>not yet parallelised .... </dd></dl>

</div>
</div>
<a id="a8ba126f6b1bc95b8815465debaedd650" name="a8ba126f6b1bc95b8815465debaedd650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ba126f6b1bc95b8815465debaedd650">&#9670;&#160;</a></span>hess_eval() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MatrixXd PostTheta::hess_eval </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the hessian at theta using second order finite difference. Is used be get_Covariance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>hyperparameter vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dense Matrix with Hessian. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000021">Todo</a></b></dt><dd>not yet parallelised .... </dd></dl>

</div>
</div>
<a id="a8ba126f6b1bc95b8815465debaedd650" name="a8ba126f6b1bc95b8815465debaedd650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ba126f6b1bc95b8815465debaedd650">&#9670;&#160;</a></span>hess_eval() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MatrixXd PostTheta::hess_eval </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the hessian at theta using second order finite difference. Is used be get_Covariance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>hyperparameter vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dense Matrix with Hessian. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000024">Todo</a></b></dt><dd>not yet parallelised .... </dd></dl>

</div>
</div>
<a id="a8ba126f6b1bc95b8815465debaedd650" name="a8ba126f6b1bc95b8815465debaedd650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ba126f6b1bc95b8815465debaedd650">&#9670;&#160;</a></span>hess_eval() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MatrixXd PostTheta::hess_eval </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the hessian at theta using second order finite difference. Is used be get_Covariance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>hyperparameter vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dense Matrix with Hessian. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000027">Todo</a></b></dt><dd>not yet parallelised .... </dd></dl>

</div>
</div>
<a id="a3507f9afff34433fbec653cc82e0bee0" name="a3507f9afff34433fbec653cc82e0bee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3507f9afff34433fbec653cc82e0bee0">&#9670;&#160;</a></span>hess_eval() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MatrixXd PostTheta::hess_eval </td>
          <td>(</td>
          <td class="paramtype">Vect&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the hessian at theta using second order finite difference. Is used be get_Covariance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>hyperparameter vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Dense Matrix with Hessian. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000010">Todo</a></b></dt><dd>not yet parallelised .... </dd></dl>

</div>
</div>
<a id="a25b31d37c9d4ac9caffc332132b39e80" name="a25b31d37c9d4ac9caffc332132b39e80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25b31d37c9d4ac9caffc332132b39e80">&#9670;&#160;</a></span>link_f_sigmoid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::link_f_sigmoid </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>sigmoidX</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>link function. vectorized evaluation of sigmoid function for each entry </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Vector. current vector x. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">sigmoidX</td><td>Vector. sigmoid(x) element-wise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add8b0bea25da71ca6071a3a3fc2fa1ea" name="add8b0bea25da71ca6071a3a3fc2fa1ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add8b0bea25da71ca6071a3a3fc2fa1ea">&#9670;&#160;</a></span>NewtonIter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PostTheta::NewtonIter </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SpMat &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>log_det</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Newton iteration to find optimum of conditional distribution latent parameters of prior &amp; likelihood. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>hyperparameters. can be an empty vector. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>latent parameters. contains initial guess of mode on entry and found mode on exit. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Q</td><td>SpMat. precision matrix. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">x</td><td>log det of Q. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42c031e4b1773db975d3038ac01b0977" name="a42c031e4b1773db975d3038ac01b0977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42c031e4b1773db975d3038ac01b0977">&#9670;&#160;</a></span>operator()() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double PostTheta::operator() </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>grad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>structure required by <a class="el" href="classBFGS.html">BFGS</a> solver, requires : theta, gradient theta </p>
<dl class="section note"><dt>Note</dt><dd>Gradient call is already parallelised using nested OpenMP. --&gt; there are l1 threads (usually 8, one for each function evaluation), that themselves then split into another e.g. 8 threads, when calling PARDISO to factorise the system. --&gt; somehow introduce additional parallelism to compute f(theta), possible to do in parallel </dd></dl>

</div>
</div>
<a id="a42c031e4b1773db975d3038ac01b0977" name="a42c031e4b1773db975d3038ac01b0977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42c031e4b1773db975d3038ac01b0977">&#9670;&#160;</a></span>operator()() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double PostTheta::operator() </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>grad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>structure required by <a class="el" href="classBFGS.html">BFGS</a> solver, requires : theta, gradient theta </p>
<dl class="section note"><dt>Note</dt><dd>Gradient call is already parallelised using nested OpenMP. --&gt; there are l1 threads (usually 8, one for each function evaluation), that themselves then split into another e.g. 8 threads, when calling PARDISO to factorise the system. --&gt; somehow introduce additional parallelism to compute f(theta), possible to do in parallel </dd></dl>

</div>
</div>
<a id="a42c031e4b1773db975d3038ac01b0977" name="a42c031e4b1773db975d3038ac01b0977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42c031e4b1773db975d3038ac01b0977">&#9670;&#160;</a></span>operator()() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double PostTheta::operator() </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>grad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>structure required by <a class="el" href="classBFGS.html">BFGS</a> solver, requires : theta, gradient theta </p>
<dl class="section note"><dt>Note</dt><dd>Gradient call is already parallelised using nested OpenMP. --&gt; there are l1 threads (usually 8, one for each function evaluation), that themselves then split into another e.g. 8 threads, when calling PARDISO to factorise the system. --&gt; somehow introduce additional parallelism to compute f(theta), possible to do in parallel </dd></dl>

</div>
</div>
<a id="a42c031e4b1773db975d3038ac01b0977" name="a42c031e4b1773db975d3038ac01b0977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42c031e4b1773db975d3038ac01b0977">&#9670;&#160;</a></span>operator()() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double PostTheta::operator() </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>grad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>structure required by <a class="el" href="classBFGS.html">BFGS</a> solver, requires : theta, gradient theta </p>
<dl class="section note"><dt>Note</dt><dd>Gradient call is already parallelised using nested OpenMP. --&gt; there are l1 threads (usually 8, one for each function evaluation), that themselves then split into another e.g. 8 threads, when calling PARDISO to factorise the system. --&gt; somehow introduce additional parallelism to compute f(theta), possible to do in parallel </dd></dl>

</div>
</div>
<a id="a42c031e4b1773db975d3038ac01b0977" name="a42c031e4b1773db975d3038ac01b0977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42c031e4b1773db975d3038ac01b0977">&#9670;&#160;</a></span>operator()() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double PostTheta::operator() </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>grad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>structure required by <a class="el" href="classBFGS.html">BFGS</a> solver, requires : theta, gradient theta </p>
<dl class="section note"><dt>Note</dt><dd>Gradient call is already parallelised using nested OpenMP. --&gt; there are l1 threads (usually 8, one for each function evaluation), that themselves then split into another e.g. 8 threads, when calling PARDISO to factorise the system. --&gt; somehow introduce additional parallelism to compute f(theta), possible to do in parallel </dd></dl>

</div>
</div>
<a id="a42c031e4b1773db975d3038ac01b0977" name="a42c031e4b1773db975d3038ac01b0977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42c031e4b1773db975d3038ac01b0977">&#9670;&#160;</a></span>operator()() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double PostTheta::operator() </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>grad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>structure required by <a class="el" href="classBFGS.html">BFGS</a> solver, requires : theta, gradient theta </p>
<dl class="section note"><dt>Note</dt><dd>Gradient call is already parallelised using nested OpenMP. --&gt; there are l1 threads (usually 8, one for each function evaluation), that themselves then split into another e.g. 8 threads, when calling PARDISO to factorise the system. --&gt; somehow introduce additional parallelism to compute f(theta), possible to do in parallel </dd></dl>

</div>
</div>
<a id="a42c031e4b1773db975d3038ac01b0977" name="a42c031e4b1773db975d3038ac01b0977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42c031e4b1773db975d3038ac01b0977">&#9670;&#160;</a></span>operator()() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double PostTheta::operator() </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>grad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>structure required by <a class="el" href="classBFGS.html">BFGS</a> solver, requires : theta, gradient theta </p>
<dl class="section note"><dt>Note</dt><dd>Gradient call is already parallelised using nested OpenMP. --&gt; there are l1 threads (usually 8, one for each function evaluation), that themselves then split into another e.g. 8 threads, when calling PARDISO to factorise the system. --&gt; somehow introduce additional parallelism to compute f(theta), possible to do in parallel </dd></dl>

</div>
</div>
<a id="a42c031e4b1773db975d3038ac01b0977" name="a42c031e4b1773db975d3038ac01b0977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42c031e4b1773db975d3038ac01b0977">&#9670;&#160;</a></span>operator()() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double PostTheta::operator() </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>grad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>structure required by <a class="el" href="classBFGS.html">BFGS</a> solver, requires : theta, gradient theta </p>
<dl class="section note"><dt>Note</dt><dd>Gradient call is already parallelised using nested OpenMP. --&gt; there are l1 threads (usually 8, one for each function evaluation), that themselves then split into another e.g. 8 threads, when calling PARDISO to factorise the system. --&gt; somehow introduce additional parallelism to compute f(theta), possible to do in parallel </dd></dl>

</div>
</div>
<a id="a42c031e4b1773db975d3038ac01b0977" name="a42c031e4b1773db975d3038ac01b0977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42c031e4b1773db975d3038ac01b0977">&#9670;&#160;</a></span>operator()() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double PostTheta::operator() </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>grad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>structure required by <a class="el" href="classBFGS.html">BFGS</a> solver, requires : theta, gradient theta </p>
<dl class="section note"><dt>Note</dt><dd>Gradient call is already parallelised using nested OpenMP. --&gt; there are l1 threads (usually 8, one for each function evaluation), that themselves then split into another e.g. 8 threads, when calling PARDISO to factorise the system. --&gt; somehow introduce additional parallelism to compute f(theta), possible to do in parallel </dd></dl>

</div>
</div>
<a id="a42c031e4b1773db975d3038ac01b0977" name="a42c031e4b1773db975d3038ac01b0977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42c031e4b1773db975d3038ac01b0977">&#9670;&#160;</a></span>operator()() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double PostTheta::operator() </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vect &amp;&#160;</td>
          <td class="paramname"><em>grad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>structure required by <a class="el" href="classBFGS.html">BFGS</a> solver, requires : theta, gradient theta </p>
<dl class="section note"><dt>Note</dt><dd>Gradient call is already parallelised using nested OpenMP. --&gt; there are l1 threads (usually 8, one for each function evaluation), that themselves then split into another e.g. 8 threads, when calling PARDISO to factorise the system. --&gt; somehow introduce additional parallelism to compute f(theta), possible to do in parallel </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a87a3adb6b92056e8dacea22fa894300a" name="a87a3adb6b92056e8dacea22fa894300a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87a3adb6b92056e8dacea22fa894300a">&#9670;&#160;</a></span>Ax <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SpMat PostTheta::Ax</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>sparse matrix of size no x (nu+nb). Projects observation locations onto FEM mesh and includes covariates at the end. <br  />
 </p>

</div>
</div>
<a id="a64a371018f008f587f38fa300abe20e5" name="a64a371018f008f587f38fa300abe20e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64a371018f008f587f38fa300abe20e5">&#9670;&#160;</a></span>Ax <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SpRmMat PostTheta::Ax</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>sparse matrix of size no x (nu+nb). Projects observation locations onto FEM mesh and includes covariates at the end. <br  />
 </p>

</div>
</div>
<a id="a423fd45045112bcccaa7d7cc33028f20" name="a423fd45045112bcccaa7d7cc33028f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a423fd45045112bcccaa7d7cc33028f20">&#9670;&#160;</a></span>AxTAx</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SpMat PostTheta::AxTAx</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>conmpute t(Ax)*Ax once. spat/spat temp model <br  />
 </p>

</div>
</div>
<a id="a72ecb0734ae1e5128bf5f92221ef3b19" name="a72ecb0734ae1e5128bf5f92221ef3b19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72ecb0734ae1e5128bf5f92221ef3b19">&#9670;&#160;</a></span>AxTy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vect PostTheta::AxTy</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>compute t(Ax)*y once. spat/spat temp model <br  />
</p>
<p>compute t(Ax)*y only once, needed in dem rhs <br  />
 </p>

</div>
</div>
<a id="acc70e6f2659235075873ecee40a126cf" name="acc70e6f2659235075873ecee40a126cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc70e6f2659235075873ecee40a126cf">&#9670;&#160;</a></span>B</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MatrixXd PostTheta::B</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>if space (-time) model included in last columns of Ax. For regression only B exists. <br  />
 </p>

</div>
</div>
<a id="ac19fdbc5cba3bad224c75afee8682e0e" name="ac19fdbc5cba3bad224c75afee8682e0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac19fdbc5cba3bad224c75afee8682e0e">&#9670;&#160;</a></span>BTy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vect PostTheta::BTy</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>compute t(B)*y once. regression model only <br  />
</p>
<p>compute t(B)*y only once, needed in dem rhs <br  />
 </p>

</div>
</div>
<a id="a71833a89a8c3dc58117eb467feac7674" name="a71833a89a8c3dc58117eb467feac7674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71833a89a8c3dc58117eb467feac7674">&#9670;&#160;</a></span>c0</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SpMat PostTheta::c0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Diagonal mass matrix spatial part. <br  />
 </p>

</div>
</div>
<a id="adc24faaa8937de8de88dde11fa9020f7" name="adc24faaa8937de8de88dde11fa9020f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc24faaa8937de8de88dde11fa9020f7">&#9670;&#160;</a></span>constr</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool PostTheta::constr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>true if there is a sum to zero constraint <br  />
 </p>

</div>
</div>
<a id="a040086750ffc42de18082b4c8a82ac76" name="a040086750ffc42de18082b4c8a82ac76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a040086750ffc42de18082b4c8a82ac76">&#9670;&#160;</a></span>dim_grad_loop</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PostTheta::dim_grad_loop</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>dimension of gradient loop <br  />
 </p>

</div>
</div>
<a id="a7cd9b90c897f00da9792dbfda210ac2b" name="a7cd9b90c897f00da9792dbfda210ac2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cd9b90c897f00da9792dbfda210ac2b">&#9670;&#160;</a></span>dim_th</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PostTheta::dim_th</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>dimension of hyperparameter vector theta <br  />
 </p>

</div>
</div>
<a id="af80d7b7e847c30706a826a1c6d7c2fc1" name="af80d7b7e847c30706a826a1c6d7c2fc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af80d7b7e847c30706a826a1c6d7c2fc1">&#9670;&#160;</a></span>Dx</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const MatrixXd PostTheta::Dx</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>constraint vector, sum to zero constraint <br  />
 </p>

</div>
</div>
<a id="a5a765bc4a434d2c4926b7c035984dd66" name="a5a765bc4a434d2c4926b7c035984dd66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a765bc4a434d2c4926b7c035984dd66">&#9670;&#160;</a></span>Dxy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const MatrixXd PostTheta::Dxy</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>constraint vector, sum to zero constraint <br  />
 </p>

</div>
</div>
<a id="acf41f1b9e822c7ea3ea10bed6b6478ee" name="acf41f1b9e822c7ea3ea10bed6b6478ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf41f1b9e822c7ea3ea10bed6b6478ee">&#9670;&#160;</a></span>fct_count</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PostTheta::fct_count</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>count total number of function evaluations <br  />
 </p>

</div>
</div>
<a id="af9fbf9c2513c00af4252fd56ac955d58" name="af9fbf9c2513c00af4252fd56ac955d58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9fbf9c2513c00af4252fd56ac955d58">&#9670;&#160;</a></span>G</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MatrixXd PostTheta::G</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>orthonormal basis for finite difference stencil is Identity if smart gradient disabled <br  />
 </p>

</div>
</div>
<a id="ade2defef59b9295d794620fefb7c8b05" name="ade2defef59b9295d794620fefb7c8b05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade2defef59b9295d794620fefb7c8b05">&#9670;&#160;</a></span>g1</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SpMat PostTheta::g1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>stiffness matrix space. <br  />
 </p>

</div>
</div>
<a id="ae1be0d6e322a26924b67b6258cf55b08" name="ae1be0d6e322a26924b67b6258cf55b08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1be0d6e322a26924b67b6258cf55b08">&#9670;&#160;</a></span>g2</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SpMat PostTheta::g2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>defined as : g1 * c0^-1 * g1 <br  />
 </p>

</div>
</div>
<a id="ac59ad0f384dc3d3f73c6f340aaac2996" name="ac59ad0f384dc3d3f73c6f340aaac2996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac59ad0f384dc3d3f73c6f340aaac2996">&#9670;&#160;</a></span>g3</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SpMat PostTheta::g3</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>defined as : g1 * (c0^-1 * g1)^2. <br  />
 </p>

</div>
</div>
<a id="a6f35b1d4e2eb881fd0b8513571874bc0" name="a6f35b1d4e2eb881fd0b8513571874bc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f35b1d4e2eb881fd0b8513571874bc0">&#9670;&#160;</a></span>iter_count</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PostTheta::iter_count</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>count total number of operator() call <br  />
 </p>

</div>
</div>
<a id="ae3a7060408a27de614cc1cc8c8bdbd7c" name="ae3a7060408a27de614cc1cc8c8bdbd7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3a7060408a27de614cc1cc8c8bdbd7c">&#9670;&#160;</a></span>likelihood</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string PostTheta::likelihood</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>assumed likelihood of the observations <br  />
 </p>

</div>
</div>
<a id="a06391c3ed3d8368da520d465cc909bc0" name="a06391c3ed3d8368da520d465cc909bc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06391c3ed3d8368da520d465cc909bc0">&#9670;&#160;</a></span>M0</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SpMat PostTheta::M0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>diagonalised mass matrix time. <br  />
 </p>

</div>
</div>
<a id="af97e49a98f2a9f390abb52cdaf998577" name="af97e49a98f2a9f390abb52cdaf998577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af97e49a98f2a9f390abb52cdaf998577">&#9670;&#160;</a></span>M1</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SpMat PostTheta::M1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>diagonal matrix with diag(0.5, 0, ..., 0, 0.5) -&gt; account for boundary <br  />
 </p>

</div>
</div>
<a id="a93e3e540d2f3d3cd343f9a66867ec03a" name="a93e3e540d2f3d3cd343f9a66867ec03a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e3e540d2f3d3cd343f9a66867ec03a">&#9670;&#160;</a></span>M2</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SpMat PostTheta::M2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>stiffness matrix time. <br  />
 </p>

</div>
</div>
<a id="a48f86e8f68bce72ec4f0aed80ebebce7" name="a48f86e8f68bce72ec4f0aed80ebebce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48f86e8f68bce72ec4f0aed80ebebce7">&#9670;&#160;</a></span>manifold</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string PostTheta::manifold</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>in R^d or on the sphere </p>

</div>
</div>
<a id="a3c397bdfb45cb31699067c615b541f23" name="a3c397bdfb45cb31699067c615b541f23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c397bdfb45cb31699067c615b541f23">&#9670;&#160;</a></span>min_f_theta</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double PostTheta::min_f_theta</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>minimum of function </p>

</div>
</div>
<a id="ab87a9d6318c690344f749edb51638119" name="ab87a9d6318c690344f749edb51638119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab87a9d6318c690344f749edb51638119">&#9670;&#160;</a></span>MPI_rank</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PostTheta::MPI_rank</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>personal mpi rank <br  />
 </p>

</div>
</div>
<a id="a8050ac12b4eb6d0fe9b69a10f91d4aa2" name="a8050ac12b4eb6d0fe9b69a10f91d4aa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8050ac12b4eb6d0fe9b69a10f91d4aa2">&#9670;&#160;</a></span>MPI_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PostTheta::MPI_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>number of mpi ranks <br  />
 </p>

</div>
</div>
<a id="aa6d3402de41235b5226e1e93be4a9dbe" name="aa6d3402de41235b5226e1e93be4a9dbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6d3402de41235b5226e1e93be4a9dbe">&#9670;&#160;</a></span>mu</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vect PostTheta::mu</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>conditional mean </p>

</div>
</div>
<a id="aca3178a77f1e6e41a315faeed05674d5" name="aca3178a77f1e6e41a315faeed05674d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca3178a77f1e6e41a315faeed05674d5">&#9670;&#160;</a></span>mu_matrix</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MatrixXd PostTheta::mu_matrix</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>store all mu values from previous iteration, dim(mu_matrix) = (n, 2*dim_th+1) <br  />
 </p>

</div>
</div>
<a id="abf7a2113f8f3a83332876a0869a9a1c9" name="abf7a2113f8f3a83332876a0869a9a1c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf7a2113f8f3a83332876a0869a9a1c9">&#9670;&#160;</a></span>mu_midpoint</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vect PostTheta::mu_midpoint</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>conditional mean, at mid point \theta^k <br  />
 </p>

</div>
</div>
<a id="a1fd5d5ebe2405083469c817c667c0ada" name="a1fd5d5ebe2405083469c817c667c0ada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fd5d5ebe2405083469c817c667c0ada">&#9670;&#160;</a></span>n</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PostTheta::n</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>total number of unknowns, i.e. ns*nt + nb <br  />
 </p>

</div>
</div>
<a id="a90f7a7de632412bd9017e33a594105f4" name="a90f7a7de632412bd9017e33a594105f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90f7a7de632412bd9017e33a594105f4">&#9670;&#160;</a></span>nb</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PostTheta::nb</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>number of fixed effects <br  />
 </p>

</div>
</div>
<a id="aec066996693ada57084aa1ee52f04948" name="aec066996693ada57084aa1ee52f04948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec066996693ada57084aa1ee52f04948">&#9670;&#160;</a></span>no</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PostTheta::no</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>number of observations <br  />
 </p>

</div>
</div>
<a id="aa4ded76f64306f25a537bbba24951a94" name="aa4ded76f64306f25a537bbba24951a94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4ded76f64306f25a537bbba24951a94">&#9670;&#160;</a></span>no_f_eval</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PostTheta::no_f_eval</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>number of function evaluations per iteration <br  />
 </p>

</div>
</div>
<a id="a4def6d3a66d18ebb36f3db4e533626f6" name="a4def6d3a66d18ebb36f3db4e533626f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4def6d3a66d18ebb36f3db4e533626f6">&#9670;&#160;</a></span>ns</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PostTheta::ns</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>number of spatial grid points per timestep <br  />
 </p>

</div>
</div>
<a id="a81228e6fc37955941268fbbb7d019b86" name="a81228e6fc37955941268fbbb7d019b86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81228e6fc37955941268fbbb7d019b86">&#9670;&#160;</a></span>nss</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PostTheta::nss</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>size of add. spatial field, not def = 0 <br  />
 </p>

</div>
</div>
<a id="a04f68cd8f220fb3096f90e4d55767009" name="a04f68cd8f220fb3096f90e4d55767009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04f68cd8f220fb3096f90e4d55767009">&#9670;&#160;</a></span>nst</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PostTheta::nst</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>ns*nt, equal to nu if nss =0 <br  />
 </p>

</div>
</div>
<a id="ac84bd657538bc782335e992055a0817e" name="ac84bd657538bc782335e992055a0817e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac84bd657538bc782335e992055a0817e">&#9670;&#160;</a></span>nt</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PostTheta::nt</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>number of temporal time steps <br  />
 </p>

</div>
</div>
<a id="a81d3526dcbbd78c65ac4a4cb86200d55" name="a81d3526dcbbd78c65ac4a4cb86200d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81d3526dcbbd78c65ac4a4cb86200d55">&#9670;&#160;</a></span>nu</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PostTheta::nu</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>number of random effects, that ns*nu <br  />
 </p>

</div>
</div>
<a id="aca01706b37b53f6a888275557ee93712" name="aca01706b37b53f6a888275557ee93712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca01706b37b53f6a888275557ee93712">&#9670;&#160;</a></span>num_solvers</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PostTheta::num_solvers</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>number of pardiso solvers <br  />
 </p>

</div>
</div>
<a id="ae2ddd0a6d8bcecd2e3d2eb94ac7cb765" name="ae2ddd0a6d8bcecd2e3d2eb94ac7cb765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2ddd0a6d8bcecd2e3d2eb94ac7cb765">&#9670;&#160;</a></span>prior</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string PostTheta::prior</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>type of pripr to be used <br  />
 </p>

</div>
</div>
<a id="a9b64e68b38abf12e38c59981ca8f28a7" name="a9b64e68b38abf12e38c59981ca8f28a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b64e68b38abf12e38c59981ca8f28a7">&#9670;&#160;</a></span>Qb</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SpMat PostTheta::Qb</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>setup indices once. Only prior fixed effects. </p>

</div>
</div>
<a id="a6dd469a358f2f3645627ce8a525fe565" name="a6dd469a358f2f3645627ce8a525fe565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dd469a358f2f3645627ce8a525fe565">&#9670;&#160;</a></span>Qu</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SpMat PostTheta::Qu</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>setup indices once. Only prior random effects </p>

</div>
</div>
<a id="a6309a79e5c90152408aa04e0bb6cc722" name="a6309a79e5c90152408aa04e0bb6cc722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6309a79e5c90152408aa04e0bb6cc722">&#9670;&#160;</a></span>Qx</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SpMat PostTheta::Qx</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>setup indices once. Includes Prior RE + FE. <br  />
 </p>

</div>
</div>
<a id="a0e71ac74d633994ca296275883673fc8" name="a0e71ac74d633994ca296275883673fc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e71ac74d633994ca296275883673fc8">&#9670;&#160;</a></span>Qxy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SpMat PostTheta::Qxy</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>setup indices for Qxy once. </p>

</div>
</div>
<a id="aa24f5936cd2425d668e97832018ab172" name="aa24f5936cd2425d668e97832018ab172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa24f5936cd2425d668e97832018ab172">&#9670;&#160;</a></span>t_grad</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vect PostTheta::t_grad</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>gradient of theta </p>

</div>
</div>
<a id="a4c8a5c414b883fbc1b9566d38fa27f2d" name="a4c8a5c414b883fbc1b9566d38fa27f2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c8a5c414b883fbc1b9566d38fa27f2d">&#9670;&#160;</a></span>theta_prior_param</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vect PostTheta::theta_prior_param</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>vector with prior values. Constructs normal distribution with sd = 1 around these values. </p>

</div>
</div>
<a id="ac29adcf70188285ecd51f2659760cc2b" name="ac29adcf70188285ecd51f2659760cc2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac29adcf70188285ecd51f2659760cc2b">&#9670;&#160;</a></span>thetaDiff_initialized</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool PostTheta::thetaDiff_initialized</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>flag in smart gradient <br  />
 </p>

</div>
</div>
<a id="a4ef6bc3ffd3a8170f5540673a842e772" name="a4ef6bc3ffd3a8170f5540673a842e772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ef6bc3ffd3a8170f5540673a842e772">&#9670;&#160;</a></span>threads_level1</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int PostTheta::threads_level1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>number of threads on first level <br  />
 </p>

</div>
</div>
<a id="a862ac0e774684eb73b44cedec925eea2" name="a862ac0e774684eb73b44cedec925eea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a862ac0e774684eb73b44cedec925eea2">&#9670;&#160;</a></span>w_sum</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double PostTheta::w_sum</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>only used if validate is true <br  />
 </p>

</div>
</div>
<a id="a762b11a93e586f00ded70b7776e075ad" name="a762b11a93e586f00ded70b7776e075ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a762b11a93e586f00ded70b7776e075ad">&#9670;&#160;</a></span>y</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vect PostTheta::y</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>vector of observations y. has length no. <br  />
 </p>

</div>
</div>
<a id="adda145a9865b6216dfbd0178f2170a01" name="adda145a9865b6216dfbd0178f2170a01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adda145a9865b6216dfbd0178f2170a01">&#9670;&#160;</a></span>yTy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double PostTheta::yTy</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>compute t(y)*y once. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>INLA_CPUonly/<a class="el" href="INLA__CPUonly_2PostTheta_8h_source.html">PostTheta.h</a></li>
<li>INLA_CPUonly/<a class="el" href="INLA__CPUonly_2PostTheta__MPI_8h_source.html">PostTheta_MPI.h</a></li>
<li>INLA_CPUonly/<a class="el" href="INLA__CPUonly_2PostTheta__nestedOpenMP_8h_source.html">PostTheta_nestedOpenMP.h</a></li>
<li>INLA_main/<a class="el" href="INLA__main_2PostTheta_8h_source.html">PostTheta.h</a></li>
<li>INLA_main/<a class="el" href="INLA__main_2PostTheta__MPI_8h_source.html">PostTheta_MPI.h</a></li>
<li>INLA_main/<a class="el" href="INLA__main_2PostTheta__nestedOpenMP_8h_source.html">PostTheta_nestedOpenMP.h</a></li>
<li>INLA_predict/<a class="el" href="INLA__predict_2PostTheta_8h_source.html">PostTheta.h</a></li>
<li>INLA_predict/<a class="el" href="INLA__predict_2PostTheta__MPI_8h_source.html">PostTheta_MPI.h</a></li>
<li>INLA_predict/<a class="el" href="INLA__predict_2PostTheta__nestedOpenMP_8h_source.html">PostTheta_nestedOpenMP.h</a></li>
<li>test_scripts/MPI_example/<a class="el" href="test__scripts_2MPI__example_2PostTheta_8cpp_source.html">PostTheta.cpp</a></li>
<li>test_scripts/multi_GPU/<a class="el" href="test__scripts_2multi__GPU_2PostTheta_8h_source.html">PostTheta.h</a></li>
<li>INLA_CPUonly/<b>PostTheta.cpp</b></li>
<li>INLA_CPUonly/<b>PostTheta_MPI.cpp</b></li>
<li>INLA_CPUonly/<b>PostTheta_nestedOpenMP.cpp</b></li>
<li>INLA_main/<b>PostTheta.cpp</b></li>
<li>INLA_main/<b>PostTheta_MPI.cpp</b></li>
<li>INLA_main/<b>PostTheta_nestedOpenMP.cpp</b></li>
<li>INLA_predict/<b>PostTheta.cpp</b></li>
<li>INLA_predict/<b>PostTheta_MPI.cpp</b></li>
<li>INLA_predict/<b>PostTheta_nestedOpenMP.cpp</b></li>
<li>test_scripts/multi_GPU/<b>PostTheta.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
